diff --git a/src/build/.gitignore b/src/build/.gitignore
index 2e963395b77b..4438e841e187 100644
--- a/src/build/.gitignore
+++ b/src/build/.gitignore
@@ -22,6 +22,12 @@ ciopfs
 /x64/
 /linux/debian_*-sysroot/
 /linux/ubuntu_*-sysroot/
+# We've built anything with pios in the name
+/linux/pios_*-sysroot/
+/linux/sysroot_scripts/*pios*
+/linux/sysroot_scripts/generated_package_lists/buster.*
+/linux/sysroot_scripts/generated_package_lists/bullseye.*
+
 /ios_files
 /mac_files
 
diff --git a/src/build/config/linux/BUILD.gn b/src/build/config/linux/BUILD.gn
index 47704248bfae..192db7b2bec5 100644
--- a/src/build/config/linux/BUILD.gn
+++ b/src/build/config/linux/BUILD.gn
@@ -5,6 +5,7 @@
 import("//build/config/c++/c++.gni")
 import("//build/config/chromeos/ui_mode.gni")
 import("//build/config/linux/pkg_config.gni")
+import("//build/config/sysroot.gni")
 import("//build/config/ui.gni")
 
 group("linux") {
@@ -66,3 +67,4 @@ if (use_glib) {
 config("export_dynamic") {
   ldflags = [ "-rdynamic" ]
 }
+
diff --git a/src/build/config/linux/atk/BUILD.gn b/src/build/config/linux/atk/BUILD.gn
index bc8e27894732..f7381c1d5b58 100644
--- a/src/build/config/linux/atk/BUILD.gn
+++ b/src/build/config/linux/atk/BUILD.gn
@@ -12,7 +12,7 @@ import("//build/config/ui.gni")
 assert(!is_chromeos_ash)
 
 # These packages should _only_ be expected when building for a target.
-assert(current_toolchain == default_toolchain)
+#assert(current_toolchain == default_toolchain)
 
 if (use_atk) {
   assert(use_glib, "use_atk=true requires that use_glib=true")
diff --git a/src/build/config/linux/atspi2/BUILD.gn b/src/build/config/linux/atspi2/BUILD.gn
index 988a99568136..6ab6eef57503 100644
--- a/src/build/config/linux/atspi2/BUILD.gn
+++ b/src/build/config/linux/atspi2/BUILD.gn
@@ -6,7 +6,7 @@ import("//build/config/linux/pkg_config.gni")
 import("//build/config/ui.gni")
 
 # These packages should _only_ be expected when building for a target.
-assert(current_toolchain == default_toolchain)
+#assert(current_toolchain == default_toolchain)
 
 if (use_atk) {
   pkg_config("atspi2") {
diff --git a/src/build/config/linux/rpi/BUILD.gn b/src/build/config/linux/rpi/BUILD.gn
new file mode 100644
index 000000000000..d90f6a46759a
--- /dev/null
+++ b/src/build/config/linux/rpi/BUILD.gn
@@ -0,0 +1,20 @@
+import("//build/config/sysroot.gni")
+
+# MMAL ld flags
+config("use_mmal") {
+  if (is_linux && target_cpu == "arm") {
+    include_dirs = [
+      "$sysroot/opt/vc/include",
+      "$sysroot/opt/vc/include/interface/vcos/pthreads",
+      "$sysroot/opt/vc/include/interface/vmcs_host/linux",
+    ]
+
+    ldflags = [
+      "-L$sysroot/opt/vc/lib",
+      "-Wl,--rpath=/opt/vc/lib,--rpath-link=$sysroot/opt/vc/lib",
+      "-Wl,--start-group", "-lbcm_host", "-lmmal", "-lmmal_util", "-lmmal_core", "-lmmal_vc_client", "-lvcos", "-lvcsm", "-lvchostif", "-lvchiq_arm", "-Wl,--end-group",
+    ]
+  }
+}
+
+
diff --git a/src/build/config/linux/rpi/args.gni b/src/build/config/linux/rpi/args.gni
new file mode 100644
index 000000000000..3c4f98c7e3a9
--- /dev/null
+++ b/src/build/config/linux/rpi/args.gni
@@ -0,0 +1,22 @@
+# Options used for the Pi build
+# It could be reasonably argued that some of tehese should be elsewhere
+# (e.g. under ui or media) but keeping all the pi extra stuff in one place
+# has its own advantages
+
+declare_args() {
+  # Enable usage of MMAL decoder on platforms that support it
+  media_use_mmal = false
+}
+
+declare_args() {
+  # MMAL video decode only enabled on ARM by default
+  # This flag enables override
+  enable_mmal_video_decoder = media_use_mmal && (current_cpu == "arm64" || current_cpu == "arm")
+}
+
+declare_args() {
+  # MMAL video decode only enabled on ARM by default
+  # This flag enables override
+  enable_native_pixmap_vcsm = media_use_mmal && (current_cpu == "arm64" || current_cpu == "arm")
+}
+
diff --git a/src/cc/layers/video_frame_provider.h b/src/cc/layers/video_frame_provider.h
index 7ae08903b6b0..00689ffd64af 100644
--- a/src/cc/layers/video_frame_provider.h
+++ b/src/cc/layers/video_frame_provider.h
@@ -97,6 +97,8 @@ class CC_EXPORT VideoFrameProvider {
   // the client.
   virtual base::TimeDelta GetPreferredRenderInterval() = 0;
 
+  virtual void DidStretchFrame(uint32_t width, uint32_t height) {}
+
  protected:
   virtual ~VideoFrameProvider() {}
 };
diff --git a/src/cc/mojo_embedder/async_layer_tree_frame_sink.h b/src/cc/mojo_embedder/async_layer_tree_frame_sink.h
index bc258e3d1937..8f302c5e47a5 100644
--- a/src/cc/mojo_embedder/async_layer_tree_frame_sink.h
+++ b/src/cc/mojo_embedder/async_layer_tree_frame_sink.h
@@ -109,6 +109,7 @@ class CC_MOJO_EMBEDDER_EXPORT AsyncLayerTreeFrameSink
   void ReclaimResources(std::vector<viz::ReturnedResource> resources) override;
   void OnCompositorFrameTransitionDirectiveProcessed(
       uint32_t sequence_id) override;
+  void DidStretchFrame(uint32_t width, uint32_t height) override {}
 
   // ExternalBeginFrameSourceClient implementation.
   void OnNeedsBeginFrames(bool needs_begin_frames) override;
diff --git a/src/cc/test/test_layer_tree_frame_sink.h b/src/cc/test/test_layer_tree_frame_sink.h
index f714223d4cd2..c241ab12b74b 100644
--- a/src/cc/test/test_layer_tree_frame_sink.h
+++ b/src/cc/test/test_layer_tree_frame_sink.h
@@ -113,6 +113,7 @@ class TestLayerTreeFrameSink : public LayerTreeFrameSink,
   void OnBeginFrame(const viz::BeginFrameArgs& args,
                     const viz::FrameTimingDetailsMap& timing_details) override;
   void ReclaimResources(std::vector<viz::ReturnedResource> resources) override;
+  void DidStretchFrame(uint32_t width, uint32_t height) override {}
   void OnBeginFramePausedChanged(bool paused) override;
   void OnCompositorFrameTransitionDirectiveProcessed(
       uint32_t sequence_id) override {}
diff --git a/src/chrome/app/chrome_main_delegate.cc b/src/chrome/app/chrome_main_delegate.cc
index c64f406ba5b8..78f9ea33acb7 100644
--- a/src/chrome/app/chrome_main_delegate.cc
+++ b/src/chrome/app/chrome_main_delegate.cc
@@ -58,6 +58,7 @@
 #include "components/nacl/common/buildflags.h"
 #include "components/services/heap_profiling/public/cpp/profiling_client.h"
 #include "components/startup_metric_utils/browser/startup_metric_utils.h"
+#include "components/version_info/pi_patch_version_info.h"
 #include "components/version_info/version_info.h"
 #include "content/public/common/content_client.h"
 #include "content/public/common/content_constants.h"
@@ -328,6 +329,15 @@ bool HandleVersionSwitches(const base::CommandLine& command_line) {
   }
 #endif
 
+  if (command_line.HasSwitch(switches::kPiPatchVersion)) {
+    printf("%s %s %s\nPi patch: %s\n",
+           version_info::GetProductName().c_str(),
+           version_info::GetVersionNumber().c_str(),
+           chrome::GetChannelName(chrome::WithExtendedStable(true)).c_str(),
+           version_info::GetPiPatchVersionString().c_str());
+    return true;
+  }
+
   if (command_line.HasSwitch(switches::kVersion)) {
     printf("%s %s %s\n", version_info::GetProductName().c_str(),
            version_info::GetVersionNumber().c_str(),
diff --git a/src/chrome/common/chrome_switches.cc b/src/chrome/common/chrome_switches.cc
index aa3f88f3eb7e..adab357b3f1c 100644
--- a/src/chrome/common/chrome_switches.cc
+++ b/src/chrome/common/chrome_switches.cc
@@ -444,6 +444,9 @@ const char kPermissionRequestApiScope[]     = "permission-request-api-scope";
 // TODO(bauerb): Remove when this flag is not needed anymore.
 const char kPermissionRequestApiUrl[]       = "permission-request-api-url";
 
+// Print the patch version and return
+const char kPiPatchVersion[] = "pi-patch-version";
+
 // Used to mock the response received from the Web Permission Prediction
 // Service. Used for testing.
 const char kPredictionServiceMockLikelihood[] =
diff --git a/src/chrome/common/chrome_switches.h b/src/chrome/common/chrome_switches.h
index 12a0457572a6..153a13eec549 100644
--- a/src/chrome/common/chrome_switches.h
+++ b/src/chrome/common/chrome_switches.h
@@ -141,6 +141,7 @@ extern const char kPackExtension[];
 extern const char kPackExtensionKey[];
 extern const char kPermissionRequestApiScope[];
 extern const char kPermissionRequestApiUrl[];
+extern const char kPiPatchVersion[];
 extern const char kPredictionServiceMockLikelihood[];
 extern const char kPreinstalledWebAppsDir[];
 extern const char kPrivetIPv6Only[];
diff --git a/src/components/version_info/BUILD.gn b/src/components/version_info/BUILD.gn
index 931da8429699..a7e5a5c2175c 100644
--- a/src/components/version_info/BUILD.gn
+++ b/src/components/version_info/BUILD.gn
@@ -14,6 +14,9 @@ static_library("version_info") {
   sources = [
     "version_info.cc",
     "version_info.h",
+    "pi_patch_version_info.cc",
+    "pi_patch_version_info.h",
+    "pi_patch_version_values.h",
   ]
 
   deps = [
diff --git a/src/components/version_info/pi_patch_version_info.cc b/src/components/version_info/pi_patch_version_info.cc
new file mode 100644
index 000000000000..f7e06cb64415
--- /dev/null
+++ b/src/components/version_info/pi_patch_version_info.cc
@@ -0,0 +1,11 @@
+#include "components/version_info/pi_patch_version_info.h"
+#include "components/version_info/pi_patch_version_values.h"
+
+namespace version_info {
+
+std::string GetPiPatchVersionString() {
+  return PI_PATCH_VERSION_STRING;
+}
+
+}  // namespace version_info
+
diff --git a/src/components/version_info/pi_patch_version_info.h b/src/components/version_info/pi_patch_version_info.h
new file mode 100644
index 000000000000..d8009bdcd0ad
--- /dev/null
+++ b/src/components/version_info/pi_patch_version_info.h
@@ -0,0 +1,12 @@
+#ifndef COMPONENTS_PI_PATCH_VERSION_INFO_VERSION_INFO_H_
+#define COMPONENTS_PI_PATCH_VERSION_INFO_VERSION_INFO_H_
+
+#include <string>
+
+namespace version_info {
+
+// Returns a string with the patch tag for our patches
+std::string GetPiPatchVersionString();
+
+}  // namespace version_info
+#endif  // COMPONENTS_VERSION_INFO_VERSION_INFO_H_
diff --git a/src/components/version_info/pi_patch_version_values.h b/src/components/version_info/pi_patch_version_values.h
new file mode 100644
index 000000000000..dc1b4bf6a178
--- /dev/null
+++ b/src/components/version_info/pi_patch_version_values.h
@@ -0,0 +1,2 @@
+// Pi patch version - generated by pi-util/settag.py
+#define PI_PATCH_VERSION_STRING "rpi_1.42"
diff --git a/src/components/viz/common/resources/transferable_resource.h b/src/components/viz/common/resources/transferable_resource.h
index 8713ea10218a..674bbb6fcc19 100644
--- a/src/components/viz/common/resources/transferable_resource.h
+++ b/src/components/viz/common/resources/transferable_resource.h
@@ -81,6 +81,9 @@ struct VIZ_COMMON_EXPORT TransferableResource {
   // The number of pixels in the gpu mailbox/software bitmap.
   gfx::Size size;
 
+  // Interline stride (for images) - 0 => not an image - use width
+  uint32_t stride = 0;
+
   // The format of the pixels in the gpu mailbox/software bitmap. This should
   // almost always be RGBA_8888 for resources generated by compositor clients,
   // and must be RGBA_8888 always for software resources.
diff --git a/src/components/viz/service/display/display_resource_provider.h b/src/components/viz/service/display/display_resource_provider.h
index c9cea0ded48c..4f11925d8b97 100644
--- a/src/components/viz/service/display/display_resource_provider.h
+++ b/src/components/viz/service/display/display_resource_provider.h
@@ -38,6 +38,8 @@ class ColorSpace;
 namespace viz {
 
 class ScopedAllowGpuAccessForDisplayResourceProvider;
+class SharedBitmapManager;
+class BitmapData;
 
 // This class provides abstractions for receiving and using resources from other
 // modules/threads/processes. It abstracts away GL textures vs GpuMemoryBuffers
diff --git a/src/components/viz/service/display/software_output_device.cc b/src/components/viz/service/display/software_output_device.cc
index 0ac41068d5f9..eb33927c41f1 100644
--- a/src/components/viz/service/display/software_output_device.cc
+++ b/src/components/viz/service/display/software_output_device.cc
@@ -64,4 +64,8 @@ int SoftwareOutputDevice::MaxFramesPending() const {
   return 1;
 }
 
+gpu::SurfaceHandle SoftwareOutputDevice::GetSurfaceHandle() const {
+  return gpu::kNullSurfaceHandle;
+}
+
 }  // namespace viz
diff --git a/src/components/viz/service/display/software_output_device.h b/src/components/viz/service/display/software_output_device.h
index 6fa80d67eb80..1d49332b543a 100644
--- a/src/components/viz/service/display/software_output_device.h
+++ b/src/components/viz/service/display/software_output_device.h
@@ -12,6 +12,7 @@
 #include "base/sequenced_task_runner.h"
 #include "components/viz/service/display/software_output_device_client.h"
 #include "components/viz/service/viz_service_export.h"
+#include "gpu/ipc/common/surface_handle.h"
 #include "third_party/skia/include/core/SkSurface.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/size.h"
@@ -26,6 +27,7 @@ class VSyncProvider;
 namespace viz {
 
 class SoftwareOutputDeviceClient;
+class DisplayResourceProvider;
 
 // This is a "tear-off" class providing software drawing support to
 // OutputSurface, such as to a platform-provided window framebuffer.
@@ -75,6 +77,8 @@ class VIZ_SERVICE_EXPORT SoftwareOutputDevice {
 
   virtual int MaxFramesPending() const;
 
+  virtual gpu::SurfaceHandle GetSurfaceHandle() const;
+
  protected:
   scoped_refptr<base::SequencedTaskRunner> task_runner_;
   SoftwareOutputDeviceClient* client_ = nullptr;
diff --git a/src/components/viz/service/display/surface_aggregator.cc b/src/components/viz/service/display/surface_aggregator.cc
index bf18b592cacf..41549b809e1f 100644
--- a/src/components/viz/service/display/surface_aggregator.cc
+++ b/src/components/viz/service/display/surface_aggregator.cc
@@ -13,6 +13,7 @@
 #include "base/bind.h"
 #include "base/check_op.h"
 #include "base/containers/adapters.h"
+#include "base/logging.h"
 #include "base/macros.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/numerics/ranges.h"
@@ -1380,6 +1381,39 @@ gfx::Rect SurfaceAggregator::PrewalkRenderPass(
 
       if (child_surface) {
         gfx::Rect child_rect;
+
+#if 0
+        // **** Changed again
+        auto it = result->damage_on_surfaces.find(child_surface->surface_id());
+        if (it != result->damage_on_surfaces.end()) {
+          // the surface damage has been accummulated previously
+          child_rect = it->second;
+        } else {
+          // first encounter of the surface
+          child_rect = PrewalkSurface(child_surface, in_moved_pixel_pass,
+                                      remapped_pass_id, will_draw, result);
+
+          if (child_surface->GetActiveFrame().metadata.may_contain_video) {
+            if (child_surface->size_in_pixels() != surface_quad->rect.size())
+            {
+#if 1
+              LOG(INFO) << "Stretch: " <<  child_surface->size_in_pixels().width() << "x" <<
+                          child_surface->size_in_pixels().height() << " -> " <<
+                          surface_quad->rect.width() << "x" <<
+                          surface_quad->rect.height() << "; video=" << frame.metadata.may_contain_video << "/" <<
+                          child_surface->GetActiveFrame().metadata.may_contain_video;
+#endif
+              child_surface->DidStretchFrame(surface_quad->rect.width(),
+                                             surface_quad->rect.height());
+            }
+            else
+            {
+              child_surface->DidntStretchFrame();
+            }
+          }
+        }
+#endif
+
         float x_scale = SK_Scalar1;
         float y_scale = SK_Scalar1;
         if (surface_quad->stretch_content_to_fill_bounds) {
@@ -1422,6 +1456,26 @@ gfx::Rect SurfaceAggregator::PrewalkRenderPass(
         child_rect = PrewalkSurface(child_surface, in_moved_pixel_rp,
                                     remapped_pass_id, will_draw,
                                     accumulated_damage_in_child_space, result);
+
+
+        if (frame.metadata.may_contain_video &&
+            child_surface->GetActiveFrame().metadata.may_contain_video) {
+          if (child_surface->size_in_pixels() != surface_quad->rect.size()) {
+            child_surface->DidStretchFrame(surface_quad->rect.width(),
+                                           surface_quad->rect.height());
+          } else {
+            child_surface->DidntStretchFrame();
+          }
+#if 0
+            LOG(INFO) << "Stretch: " <<  child_surface->size_in_pixels().width() << "x" <<
+                        child_surface->size_in_pixels().height() << " -> " <<
+                        surface_quad->rect.width() << "x" <<
+                        surface_quad->rect.height() << ";  scale=" << x_scale << "x" << y_scale <<
+                        "; video=" << frame.metadata.may_contain_video << "/" <<
+                        child_surface->GetActiveFrame().metadata.may_contain_video;
+#endif
+        }
+
         child_rect = gfx::ScaleToEnclosingRect(child_rect, x_scale, y_scale);
         quad_damage_rect.Union(child_rect);
       }
diff --git a/src/components/viz/service/display_embedder/software_output_surface.cc b/src/components/viz/service/display_embedder/software_output_surface.cc
index a909718f5f17..b274fdea6974 100644
--- a/src/components/viz/service/display_embedder/software_output_surface.cc
+++ b/src/components/viz/service/display_embedder/software_output_surface.cc
@@ -31,6 +31,10 @@ SoftwareOutputSurface::SoftwareOutputSurface(
 
 SoftwareOutputSurface::~SoftwareOutputSurface() = default;
 
+gpu::SurfaceHandle SoftwareOutputSurface::GetSurfaceHandle() const {
+  return software_device()->GetSurfaceHandle();
+}
+
 void SoftwareOutputSurface::BindToClient(OutputSurfaceClient* client) {
   DCHECK(client);
   DCHECK(!client_);
diff --git a/src/components/viz/service/display_embedder/software_output_surface.h b/src/components/viz/service/display_embedder/software_output_surface.h
index 7f75e707a9fe..d842b3db93ee 100644
--- a/src/components/viz/service/display_embedder/software_output_surface.h
+++ b/src/components/viz/service/display_embedder/software_output_surface.h
@@ -29,6 +29,7 @@ class VIZ_SERVICE_EXPORT SoftwareOutputSurface : public OutputSurface {
   ~SoftwareOutputSurface() override;
 
   // OutputSurface implementation.
+  gpu::SurfaceHandle GetSurfaceHandle() const override;
   void BindToClient(OutputSurfaceClient* client) override;
   void EnsureBackbuffer() override;
   void DiscardBackbuffer() override;
diff --git a/src/components/viz/service/frame_sinks/compositor_frame_sink_support.cc b/src/components/viz/service/frame_sinks/compositor_frame_sink_support.cc
index 90ef058b804d..0fd2c1e79377 100644
--- a/src/components/viz/service/frame_sinks/compositor_frame_sink_support.cc
+++ b/src/components/viz/service/frame_sinks/compositor_frame_sink_support.cc
@@ -697,6 +697,12 @@ void CompositorFrameSinkSupport::DidPresentCompositorFrame(
   UpdateNeedsBeginFramesInternal();
 }
 
+void CompositorFrameSinkSupport::DidStretchFrame(uint32_t width, uint32_t height) {
+  if (client_)
+    client_->DidStretchFrame(width, height);
+}
+
+
 void CompositorFrameSinkSupport::DidRejectCompositorFrame(
     uint32_t frame_token,
     std::vector<TransferableResource> frame_resource_list,
diff --git a/src/components/viz/service/frame_sinks/compositor_frame_sink_support.h b/src/components/viz/service/frame_sinks/compositor_frame_sink_support.h
index 1f163e40d3c4..6b4589720145 100644
--- a/src/components/viz/service/frame_sinks/compositor_frame_sink_support.h
+++ b/src/components/viz/service/frame_sinks/compositor_frame_sink_support.h
@@ -126,6 +126,7 @@ class VIZ_SERVICE_EXPORT CompositorFrameSinkSupport
       const std::vector<TransferableResource>& resources) override;
   void UnrefResources(std::vector<ReturnedResource> resources) override;
   void ReturnResources(std::vector<ReturnedResource> resources) override;
+  void DidStretchFrame(uint32_t width, uint32_t height) override;
   void ReceiveFromChild(
       const std::vector<TransferableResource>& resources) override;
   // Takes the CopyOutputRequests that were requested for a surface with at
diff --git a/src/components/viz/service/surfaces/surface.cc b/src/components/viz/service/surfaces/surface.cc
index 9e808d5da973..84d363f6df48 100644
--- a/src/components/viz/service/surfaces/surface.cc
+++ b/src/components/viz/service/surfaces/surface.cc
@@ -11,6 +11,7 @@
 #include <limits>
 #include <utility>
 
+#include "base/logging.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/stl_util.h"
 #include "base/time/tick_clock.h"
@@ -767,6 +768,32 @@ void Surface::UnrefFrameResourcesAndRunCallbacks(
     info.Terminate();
 }
 
+void Surface::DidStretchFrame(uint32_t width, uint32_t height) {
+  // Rate limit requests if we seem to be ignoring them
+
+  if (stretch_frame_count_ != 0 && width == stretch_last_width_ && height == stretch_last_height_) {
+//    LOG(INFO) << "Sink stretch request: " << stretch_frame_count_;
+    --stretch_frame_count_;
+    return;
+  }
+//  LOG(INFO) << "Attempt stretch request";
+
+  stretch_last_width_ = width;
+  stretch_last_height_ = height;
+  stretch_frame_count_ = 32;
+
+  if (surface_client_)
+    surface_client_->DidStretchFrame(width, height);
+  else
+    LOG(INFO) << "No surface_client_";
+}
+
+void Surface::DidntStretchFrame() {
+  if (stretch_frame_count_ != 0) {
+    --stretch_frame_count_;
+  }
+}
+
 void Surface::ClearCopyRequests() {
   if (active_frame_data_) {
     for (const auto& render_pass :
diff --git a/src/components/viz/service/surfaces/surface.h b/src/components/viz/service/surfaces/surface.h
index c58755669940..31f6d6527bba 100644
--- a/src/components/viz/service/surfaces/surface.h
+++ b/src/components/viz/service/surfaces/surface.h
@@ -128,6 +128,9 @@ class VIZ_SERVICE_EXPORT Surface final {
 
   void SetPreviousFrameSurface(Surface* surface);
 
+  void DidStretchFrame(uint32_t width, uint32_t height);
+  void DidntStretchFrame();
+
   // Returns false if |frame| is invalid.
   // |frame_rejected_callback| will be called once if the frame will not be
   // displayed.
@@ -391,6 +394,10 @@ class VIZ_SERVICE_EXPORT Surface final {
 
   bool has_damage_from_interpolated_frame_ = false;
 
+  uint32_t stretch_last_width_ = 0;
+  uint32_t stretch_last_height_ = 0;
+  uint32_t stretch_frame_count_ = 0;
+
   base::WeakPtrFactory<Surface> weak_factory_{this};
 
   DISALLOW_COPY_AND_ASSIGN(Surface);
diff --git a/src/components/viz/service/surfaces/surface_client.h b/src/components/viz/service/surfaces/surface_client.h
index a3305ac2b418..79824a63f420 100644
--- a/src/components/viz/service/surfaces/surface_client.h
+++ b/src/components/viz/service/surfaces/surface_client.h
@@ -80,6 +80,9 @@ class VIZ_SERVICE_EXPORT SurfaceClient {
       const gfx::SwapTimings& swap_timings,
       const gfx::PresentationFeedback& feedback) = 0;
 
+  // OK - this probably should be pure but that makes the patch bigger...
+  virtual void DidStretchFrame(uint32_t width, uint32_t height) {}
+
   // This is called when |surface| or one of its descendents is determined to be
   // damaged at aggregation time.
   virtual void OnSurfaceAggregatedDamage(
diff --git a/src/components/viz/test/fake_compositor_frame_sink_client.h b/src/components/viz/test/fake_compositor_frame_sink_client.h
index 71af948c1f96..4872c17d14e8 100644
--- a/src/components/viz/test/fake_compositor_frame_sink_client.h
+++ b/src/components/viz/test/fake_compositor_frame_sink_client.h
@@ -28,6 +28,7 @@ class FakeCompositorFrameSinkClient : public mojom::CompositorFrameSinkClient {
   void OnBeginFrame(const BeginFrameArgs& args,
                     const FrameTimingDetailsMap& timing_details) override;
   void ReclaimResources(std::vector<ReturnedResource> resources) override;
+  void DidStretchFrame(uint32_t width, uint32_t height) override {}
   void OnBeginFramePausedChanged(bool paused) override;
   void OnCompositorFrameTransitionDirectiveProcessed(
       uint32_t sequence_id) override {}
diff --git a/src/content/browser/browser_main_loop.cc b/src/content/browser/browser_main_loop.cc
index 058bdd404d31..4d4bccb288ee 100644
--- a/src/content/browser/browser_main_loop.cc
+++ b/src/content/browser/browser_main_loop.cc
@@ -527,6 +527,12 @@ int BrowserMainLoop::EarlyInitialization() {
   DCHECK(SandboxHostLinux::GetInstance()->IsInitialized());
 #endif
 
+#if 0
+  // (Pi) The mmal shared memory passthrough requires MT X as the frame
+  // can be deleted (and detached) outside the display thread
+  if (!gfx::InitializeThreadedX11()) {
+    LOG(ERROR) << "Failed to put Xlib into threaded mode.";
+#endif
 #if defined(USE_X11)
   if (!features::IsUsingOzonePlatform() && UsingInProcessGpu() &&
       !x11::Connection::Get()->Ready()) {
diff --git a/src/content/browser/renderer_host/render_process_host_impl.cc b/src/content/browser/renderer_host/render_process_host_impl.cc
index 621f9405e1a9..9c9d05075b45 100644
--- a/src/content/browser/renderer_host/render_process_host_impl.cc
+++ b/src/content/browser/renderer_host/render_process_host_impl.cc
@@ -3499,6 +3499,15 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
 #if BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(IS_CHROMEOS_LACROS)
     switches::kSchedulerBoostUrgent,
 #endif
+
+    switches::kMmalFrameBuffers, switches::kMmalCopyMode,
+    switches::kMmalDecodeI420,   switches::kMmalDecodeOpaque,
+    switches::kMmalResizeIsp,    switches::kMmalResizeResizer,
+    switches::kMmalResizeMode,
+    switches::kMmalLowDelay,
+    switches::kMmalRedPixel,     switches::kMmalDecoders,
+    switches::kMmalDebugBench,   switches::kMmalDebugFps,
+    switches::kMmalDebugFixedSize,
   };
   renderer_cmd->CopySwitchesFrom(browser_cmd, kSwitchNames,
                                  base::size(kSwitchNames));
diff --git a/src/content/browser/sandbox_ipc_linux.cc b/src/content/browser/sandbox_ipc_linux.cc
index b0cade3d5066..0a39a6c409df 100644
--- a/src/content/browser/sandbox_ipc_linux.cc
+++ b/src/content/browser/sandbox_ipc_linux.cc
@@ -8,6 +8,7 @@
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
+#include <sys/ioctl.h>
 #include <sys/poll.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
@@ -124,6 +125,12 @@ void SandboxIPCHandler::HandleRequestFromChild(int fd) {
       sandbox::policy::SandboxLinux::METHOD_MAKE_SHARED_MEMORY_SEGMENT) {
     HandleMakeSharedMemorySegment(fd, iter, fds);
     return;
+  } else if (kind == sandbox::policy::SandboxLinux::METHOD_OPEN_DEV_VCHIQ) {
+    HandleOpenDevVchiq(fd, iter, fds);
+    return;
+  } else if (kind == sandbox::policy::SandboxLinux::METHOD_OPEN_DEV_VCSM) {
+    HandleOpenDevVcsm(fd, iter, fds);
+    return;
   }
   NOTREACHED();
 }
@@ -155,6 +162,89 @@ void SandboxIPCHandler::HandleMakeSharedMemorySegment(
   // shm_fd will close the handle which is no longer needed by this process.
 }
 
+#define IOCTL_MBOX_PROPERTY _IOWR(100, 0, char *)
+#define VCIO_PATH "/dev/vcio"
+
+static uint32_t pi_firmware_date()
+{
+  int vcio_fd = IGNORE_EINTR(open(VCIO_PATH, 0));
+
+  if (vcio_fd == -1) {
+    PLOG(ERROR) << "Failed to open " VCIO_PATH;
+    return 0;
+  }
+
+  uint32_t req_buf[256] = {
+    (4+3)*4, 0,  // 4 args, + 3 overhead
+    1, 4, 4, 0,  // args
+  };
+
+  int err = IGNORE_EINTR(ioctl(vcio_fd, IOCTL_MBOX_PROPERTY, req_buf));
+  uint32_t rv = req_buf[5];
+
+  if (err < 0) {
+    PLOG(ERROR) << VCIO_PATH ": ioctl";
+    rv = 0;
+  }
+
+  if (IGNORE_EINTR(close(vcio_fd)) < 0)
+    PLOG(ERROR) << VCIO_PATH ": close";
+  return rv;
+}
+
+void SandboxIPCHandler::HandleOpenDevVchiq(
+    int fd,
+    base::PickleIterator iter,
+    const std::vector<base::ScopedFD>& fds)
+{
+  const int vchiq_fd = IGNORE_EINTR(open("/dev/vchiq", O_RDWR));
+
+  if (vchiq_fd == -1) {
+    PLOG(ERROR) << "Failed to open vchiq";
+  }
+
+  base::Pickle reply;
+  reply.WriteUInt32(pi_firmware_date());
+  SendRendererReply(fds, reply, vchiq_fd);
+
+  if (vchiq_fd >= 0) {
+    if (IGNORE_EINTR(close(vchiq_fd)) < 0)
+      PLOG(ERROR) << "close";
+  }
+}
+
+void SandboxIPCHandler::HandleOpenDevVcsm(
+    int fd,
+    base::PickleIterator iter,
+    const std::vector<base::ScopedFD>& fds)
+{
+  bool cma;
+  if (!iter.ReadBool(&cma))
+    return;
+
+  int vcsm_fd =
+    IGNORE_EINTR(open(cma ? "/dev/vcsm-cma" : "/dev/vcsm", O_RDWR));
+
+  if (vcsm_fd == -1) {
+    cma = !cma;
+    vcsm_fd = IGNORE_EINTR(open(cma ? "/dev/vcsm-cma" : "/dev/vcsm", O_RDWR));
+  }
+
+  if (vcsm_fd == -1) {
+    PLOG(ERROR) << "Failed to open vcsm";
+  }
+
+  base::Pickle reply;
+  reply.WriteBool(cma);
+  SendRendererReply(fds, reply, vcsm_fd);
+
+  if (vcsm_fd >= 0) {
+    if (IGNORE_EINTR(close(vcsm_fd)) < 0)
+      PLOG(ERROR) << "close";
+  }
+}
+
+
 void SandboxIPCHandler::SendRendererReply(
     const std::vector<base::ScopedFD>& fds,
     const base::Pickle& reply,
diff --git a/src/content/browser/sandbox_ipc_linux.h b/src/content/browser/sandbox_ipc_linux.h
index 8a961034e97e..9868977b1f8e 100644
--- a/src/content/browser/sandbox_ipc_linux.h
+++ b/src/content/browser/sandbox_ipc_linux.h
@@ -37,6 +37,13 @@ class SandboxIPCHandler : public base::DelegateSimpleThread::Delegate {
                                      base::PickleIterator iter,
                                      const std::vector<base::ScopedFD>& fds);
 
+  void HandleOpenDevVchiq(int fd,
+                               base::PickleIterator iter,
+                               const std::vector<base::ScopedFD>& fds);
+  void HandleOpenDevVcsm(int fd,
+                               base::PickleIterator iter,
+                               const std::vector<base::ScopedFD>& fds);
+
   void SendRendererReply(const std::vector<base::ScopedFD>& fds,
                          const base::Pickle& reply,
                          int reply_fd);
diff --git a/src/content/renderer/render_thread_impl.cc b/src/content/renderer/render_thread_impl.cc
index 5bb7fec55d93..53efa5ec161c 100644
--- a/src/content/renderer/render_thread_impl.cc
+++ b/src/content/renderer/render_thread_impl.cc
@@ -110,6 +110,7 @@
 #include "media/base/decoder_factory.h"
 #include "media/base/media.h"
 #include "media/base/media_switches.h"
+#include "media/gpu/buildflags.h"
 #include "media/media_buildflags.h"
 #include "media/renderers/default_decoder_factory.h"
 #include "media/video/gpu_video_accelerator_factories.h"
@@ -1039,8 +1040,7 @@ media::GpuVideoAcceleratorFactories* RenderThreadImpl::GetGpuFactories() {
           kGpuStreamPriorityMedia);
 
   const bool enable_video_accelerator =
-
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) && !BUILDFLAG(USE_V4L2_CODEC)
       base::FeatureList::IsEnabled(media::kVaapiVideoDecodeLinux) &&
 #else
       !cmd_line->HasSwitch(switches::kDisableAcceleratedVideoDecode) &&
diff --git a/src/content/test/fake_renderer_compositor_frame_sink.h b/src/content/test/fake_renderer_compositor_frame_sink.h
index 370a9e546947..5455e6d553d5 100644
--- a/src/content/test/fake_renderer_compositor_frame_sink.h
+++ b/src/content/test/fake_renderer_compositor_frame_sink.h
@@ -39,6 +39,7 @@ class FakeRendererCompositorFrameSink
   void ReclaimResources(std::vector<viz::ReturnedResource> resources) override;
   void OnCompositorFrameTransitionDirectiveProcessed(
       uint32_t sequence_id) override {}
+  void DidStretchFrame(uint32_t width, uint32_t height) override {}
 
   // Resets test data.
   void Reset();
diff --git a/src/gpu/command_buffer/service/gl_utils.cc b/src/gpu/command_buffer/service/gl_utils.cc
index 1a284386acc5..e09d5e5a2497 100644
--- a/src/gpu/command_buffer/service/gl_utils.cc
+++ b/src/gpu/command_buffer/service/gl_utils.cc
@@ -1141,6 +1141,7 @@ bool ValidateCopyTextureCHROMIUMInternalFormats(const FeatureInfo* feature_info,
       source_internal_format == GL_LUMINANCE_ALPHA ||
       source_internal_format == GL_BGRA_EXT ||
       source_internal_format == GL_BGRA8_EXT ||
+      source_internal_format == GL_RGB_YCRCB_420_CHROMIUM ||  // RPI: Was missing - why?
       source_internal_format == GL_RGB_YCBCR_420V_CHROMIUM ||
       source_internal_format == GL_RGB_YCBCR_422_CHROMIUM ||
       source_internal_format == GL_RGB_YCBCR_P010_CHROMIUM ||
diff --git a/src/gpu/ipc/common/gpu_memory_buffer_support.cc b/src/gpu/ipc/common/gpu_memory_buffer_support.cc
index 0e0b612894b6..90294a72e1ac 100644
--- a/src/gpu/ipc/common/gpu_memory_buffer_support.cc
+++ b/src/gpu/ipc/common/gpu_memory_buffer_support.cc
@@ -106,6 +106,32 @@ bool GpuMemoryBufferSupport::IsNativeGpuMemoryBufferConfigurationSupported(
   }
   NOTREACHED();
   return false;
+#elif RPI_PIXMAP
+  switch (usage) {
+    case gfx::BufferUsage::GPU_READ:
+    case gfx::BufferUsage::SCANOUT:
+    case gfx::BufferUsage::SCANOUT_CPU_READ_WRITE:
+    case gfx::BufferUsage::GPU_READ_CPU_READ_WRITE:
+      return
+#if 0
+             format == gfx::BufferFormat::BGRA_8888 ||
+             format == gfx::BufferFormat::RGBA_8888 ||
+             format == gfx::BufferFormat::BGRX_8888 ||
+             format == gfx::BufferFormat::RGBX_8888 ||
+#endif
+             format == gfx::BufferFormat::YVU_420 ||
+             format == gfx::BufferFormat::YUV_420_BIPLANAR;
+    case gfx::BufferUsage::SCANOUT_VDA_WRITE:
+    case gfx::BufferUsage::PROTECTED_SCANOUT_VDA_WRITE:
+    case gfx::BufferUsage::SCANOUT_CAMERA_READ_WRITE:
+    case gfx::BufferUsage::CAMERA_AND_CPU_READ_WRITE:
+    case gfx::BufferUsage::SCANOUT_VEA_CPU_READ:
+    case gfx::BufferUsage::VEA_READ_CAMERA_AND_CPU_READ_WRITE:
+    case gfx::BufferUsage::SCANOUT_FRONT_RENDERING:
+      return false;
+  }
+  NOTREACHED();
+  return false;
 #elif defined(OS_ANDROID)
   if (!base::AndroidHardwareBufferCompat::IsSupportAvailable()) {
     return false;
diff --git a/src/gpu/ipc/common/gpu_memory_buffer_support.h b/src/gpu/ipc/common/gpu_memory_buffer_support.h
index 32428cc4f90e..09d8765f5669 100644
--- a/src/gpu/ipc/common/gpu_memory_buffer_support.h
+++ b/src/gpu/ipc/common/gpu_memory_buffer_support.h
@@ -18,6 +18,8 @@
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/gpu_memory_buffer.h"
 
+#define RPI_PIXMAP 1
+
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE)
 namespace gfx {
 class ClientNativePixmapFactory;
diff --git a/src/gpu/ipc/host/gpu_memory_buffer_support.cc b/src/gpu/ipc/host/gpu_memory_buffer_support.cc
index 8d4851ef934e..dcb5d05c7813 100644
--- a/src/gpu/ipc/host/gpu_memory_buffer_support.cc
+++ b/src/gpu/ipc/host/gpu_memory_buffer_support.cc
@@ -18,7 +18,7 @@ GpuMemoryBufferConfigurationSet GetNativeGpuMemoryBufferConfigurations(
   GpuMemoryBufferConfigurationSet configurations;
 
 #if defined(USE_OZONE) || defined(OS_MAC) || defined(OS_WIN) || \
-    defined(OS_ANDROID)
+    defined(OS_ANDROID) || RPI_PIXMAP
 #if defined(USE_OZONE)
   if (!features::IsUsingOzonePlatform())
     return configurations;
@@ -64,7 +64,7 @@ bool GetImageNeedsPlatformSpecificTextureTarget(gfx::BufferFormat format,
   if (!NativeBufferNeedsPlatformSpecificTextureTarget(format))
     return false;
 #if defined(USE_OZONE) || defined(OS_MAC) || defined(OS_WIN) || \
-    defined(OS_ANDROID)
+    defined(OS_ANDROID) || RPI_PIXMAP
   GpuMemoryBufferSupport support;
   GpuMemoryBufferConfigurationSet native_configurations =
       GetNativeGpuMemoryBufferConfigurations(&support);
diff --git a/src/gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap.cc b/src/gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap.cc
index b645f8b38ebd..9e7d3256436c 100644
--- a/src/gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap.cc
+++ b/src/gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap.cc
@@ -8,6 +8,7 @@
 #include "components/viz/common/gpu/vulkan_context_provider.h"
 #include "gpu/command_buffer/common/gpu_memory_buffer_support.h"
 #include "gpu/vulkan/vulkan_device_queue.h"
+#include "ui/gfx/buildflags.h"
 #include "ui/gfx/buffer_format_util.h"
 #include "ui/gfx/buffer_usage_util.h"
 #include "ui/gfx/client_native_pixmap.h"
@@ -33,6 +34,10 @@
 #include "ui/gl/gl_image_glx_native_pixmap.h"            // nogncheck
 #endif
 
+#if BUILDFLAG(ENABLE_NATIVE_PIXMAP_VCSM)
+#include "ui/gfx/linux/native_pixmap_vcsm.h"
+#endif
+
 namespace gpu {
 
 namespace {
@@ -84,6 +89,11 @@ GpuMemoryBufferFactoryNativePixmap::CreateGpuMemoryBuffer(
                                                  client_id, std::move(pixmap));
   }
 #endif
+#if BUILDFLAG(ENABLE_NATIVE_PIXMAP_VCSM)
+  scoped_refptr<gfx::NativePixmap> pixmap(CreateVCSMPixmap(size, format));
+  return CreateGpuMemoryBufferFromNativePixmap(id, size, format, usage,
+                                               client_id, std::move(pixmap));
+#else
   DCHECK_EQ(framebuffer_size, size);
 
 #if defined(USE_X11)
@@ -103,6 +113,7 @@ GpuMemoryBufferFactoryNativePixmap::CreateGpuMemoryBuffer(
   NOTIMPLEMENTED();
   return gfx::GpuMemoryBufferHandle();
 #endif
+#endif  // RPI_PIXMAP_VCSM
 }
 
 void GpuMemoryBufferFactoryNativePixmap::CreateGpuMemoryBufferAsync(
@@ -192,6 +203,11 @@ GpuMemoryBufferFactoryNativePixmap::CreateImageForGpuMemoryBuffer(
                        std::move(handle.native_pixmap_handle));
     }
 #endif
+#if BUILDFLAG(ENABLE_NATIVE_PIXMAP_VCSM)
+    // This is easy enough to build but I don't think it should ever happen
+    if (!pixmap)
+      pixmap = CreateVCSMPixmapFromHandle(size, format, std::move(handle.native_pixmap_handle));
+#endif
 #if !defined(OS_FUCHSIA)
     if (!pixmap) {
       DCHECK_EQ(surface_handle, gpu::kNullSurfaceHandle);
@@ -231,11 +247,15 @@ GpuMemoryBufferFactoryNativePixmap::CreateImageForGpuMemoryBuffer(
 }
 
 bool GpuMemoryBufferFactoryNativePixmap::SupportsCreateAnonymousImage() const {
+#if BUILDFLAG(ENABLE_NATIVE_PIXMAP_VCSM)
+  return true;
+#else
 #if defined(USE_OZONE)
   if (features::IsUsingOzonePlatform())
     return true;
 #endif
   return false;
+#endif
 }
 
 scoped_refptr<gl::GLImage>
@@ -246,6 +266,7 @@ GpuMemoryBufferFactoryNativePixmap::CreateAnonymousImage(
     SurfaceHandle surface_handle,
     bool* is_cleared) {
   scoped_refptr<gfx::NativePixmap> pixmap;
+#if defined(USE_OZONE) || BUILDFLAG(ENABLE_NATIVE_PIXMAP_VCSM)
 #if defined(USE_OZONE)
   if (features::IsUsingOzonePlatform()) {
     pixmap = ui::OzonePlatform::GetInstance()
@@ -253,6 +274,11 @@ GpuMemoryBufferFactoryNativePixmap::CreateAnonymousImage(
                  ->CreateNativePixmap(surface_handle, GetVulkanDevice(), size,
                                       format, usage);
   }
+#endif
+#if BUILDFLAG(ENABLE_NATIVE_PIXMAP_VCSM)
+  if (!pixmap)
+    pixmap = CreateVCSMPixmap(size, format);
+#endif
 #else
   NOTIMPLEMENTED();
 #endif
diff --git a/src/media/BUILD.gn b/src/media/BUILD.gn
index 740789d1dcc8..53ce9135fa00 100644
--- a/src/media/BUILD.gn
+++ b/src/media/BUILD.gn
@@ -7,6 +7,7 @@ import("//build/config/android/config.gni")
 import("//build/config/arm.gni")
 import("//build/config/features.gni")
 import("//build/config/linux/pkg_config.gni")
+import("//build/config/linux/rpi/args.gni")
 import("//build/config/ui.gni")
 import("//media/cdm/library_cdm/cdm_paths.gni")
 import("//media/media_options.gni")
@@ -37,6 +38,7 @@ buildflag_header("media_buildflags") {
     "ENABLE_MEDIA_DRM_STORAGE=$enable_media_drm_storage",
     "ENABLE_MEDIA_REMOTING=$enable_media_remoting",
     "ENABLE_MEDIA_REMOTING_RPC=$enable_media_remoting_rpc",
+    "ENABLE_MMAL_VIDEO_DECODER=$enable_mmal_video_decoder",
     "ENABLE_OPENH264=$media_use_openh264",
     "ENABLE_PLATFORM_MPEG_H_AUDIO=$enable_platform_mpeg_h_audio",
     "ENABLE_MSE_MPEG2TS_STREAM_PARSER=$enable_mse_mpeg2ts_stream_parser",
diff --git a/src/media/base/decoder.cc b/src/media/base/decoder.cc
index f14ec631d2e7..1b23386dd275 100644
--- a/src/media/base/decoder.cc
+++ b/src/media/base/decoder.cc
@@ -52,6 +52,8 @@ std::string GetDecoderName(VideoDecoderType type) {
       return "V4L2VideoDecoder";
     case VideoDecoderType::kTesting:
       return "Testing or Mock Video decoder";
+    case VideoDecoderType::kMmal:
+      return "MmalVideoDecoder";
     default:
       NOTREACHED();
       return "VideoDecoderType created through invalid static_cast";
diff --git a/src/media/base/decoder.h b/src/media/base/decoder.h
index d724edb49703..788cbe93e059 100644
--- a/src/media/base/decoder.h
+++ b/src/media/base/decoder.h
@@ -51,9 +51,10 @@ enum class VideoDecoderType : int {
   kV4L2 = 16,       // V4L2VideoDecoder
 
   kTesting = 17,  // Never send this to UKM, for tests only.
+  kMmal,
 
   // Keep this at the end and equal to the last entry.
-  kMaxValue = kTesting
+  kMaxValue = kMmal  // Keep this at the end and equal to the last entry.
 };
 
 MEDIA_EXPORT std::string GetDecoderName(AudioDecoderType type);
diff --git a/src/media/base/media_switches.cc b/src/media/base/media_switches.cc
index 7c6ca90d52ac..6cdf0a09caa3 100644
--- a/src/media/base/media_switches.cc
+++ b/src/media/base/media_switches.cc
@@ -220,6 +220,21 @@ const char kUserGestureRequiredPolicy[] = "user-gesture-required";
 
 }  // namespace autoplay
 
+const char kMmalFrameBuffers[]              = "mmal-frame-buffers";
+const char kMmalCopyMode[]                  = "mmal-copy-mode";
+const char kMmalDecodeI420[]                = "mmal-decode-i420";
+const char kMmalDecodeOpaque[]              = "mmal-decode-opaque";
+const char kMmalResizeIsp[]                 = "mmal-resize-isp";
+const char kMmalResizeResizer[]             = "mmal-resize-resizer";
+const char kMmalResizeMode[]                = "mmal-resize-mode";
+const char kMmalLowDelay[]                  = "mmal-low-delay";
+const char kMmalRedPixel[]                  = "mmal-red-pixel";
+const char kMmalDecoders[]                  = "mmal-decoders";
+
+const char kMmalDebugBench[]                = "mmal-debug-bench";
+const char kMmalDebugFps[]                  = "mmal-debug-fps";
+const char kMmalDebugFixedSize[]            = "mmal-debug-fixed-size";
+
 }  // namespace switches
 
 namespace media {
diff --git a/src/media/base/media_switches.h b/src/media/base/media_switches.h
index 69b9cfcc7b8e..7e60fc355c66 100644
--- a/src/media/base/media_switches.h
+++ b/src/media/base/media_switches.h
@@ -99,6 +99,21 @@ MEDIA_EXPORT extern const char kUserGestureRequiredPolicy[];
 
 }  // namespace autoplay
 
+MEDIA_EXPORT extern const char kMmalFrameBuffers[];
+MEDIA_EXPORT extern const char kMmalCopyMode[];
+MEDIA_EXPORT extern const char kMmalDecodeI420[];
+MEDIA_EXPORT extern const char kMmalDecodeOpaque[];
+MEDIA_EXPORT extern const char kMmalResizeIsp[];
+MEDIA_EXPORT extern const char kMmalResizeResizer[];
+MEDIA_EXPORT extern const char kMmalResizeMode[];
+MEDIA_EXPORT extern const char kMmalLowDelay[];
+MEDIA_EXPORT extern const char kMmalRedPixel[];
+MEDIA_EXPORT extern const char kMmalDecoders[];
+
+MEDIA_EXPORT extern const char kMmalDebugBench[];
+MEDIA_EXPORT extern const char kMmalDebugFps[];
+MEDIA_EXPORT extern const char kMmalDebugFixedSize[];
+
 }  // namespace switches
 
 namespace media {
diff --git a/src/media/base/video_decoder.h b/src/media/base/video_decoder.h
index 77772ab6b828..4da068baa276 100644
--- a/src/media/base/video_decoder.h
+++ b/src/media/base/video_decoder.h
@@ -130,6 +130,10 @@ class MEDIA_EXPORT VideoDecoder : public Decoder {
   // this should return the underlying type, if it is known, otherwise return
   // its own type.
   virtual VideoDecoderType GetDecoderType() const = 0;
+
+  // Alert that we would like a different frame size
+  virtual void TryResizeFrame(uint32_t width, uint32_t height) {}
+
 };
 
 }  // namespace media
diff --git a/src/media/base/video_frame.cc b/src/media/base/video_frame.cc
index d895ebf38a43..50274f86a39d 100644
--- a/src/media/base/video_frame.cc
+++ b/src/media/base/video_frame.cc
@@ -1541,4 +1541,21 @@ std::vector<size_t> VideoFrame::CalculatePlaneSize() const {
   return plane_size;
 }
 
+// Frame tracking
+
+// Not supported by default
+const base::ReadOnlySharedMemoryRegion* VideoFrame::ro_shm_region() const {
+  return nullptr;
+}
+
+bool VideoFrame::SetBitmapIdAndKillCB(const gpu::Mailbox& id, base::OnceClosure kill) {
+  return false;
+}
+
+const gpu::Mailbox& VideoFrame::GetBitmapId() const {
+  static const gpu::Mailbox empty_mailbox;
+  NOTREACHED();
+  return empty_mailbox;
+}
+
 }  // namespace media
diff --git a/src/media/base/video_frame.h b/src/media/base/video_frame.h
index 373d0268b67d..50be6f858a2b 100644
--- a/src/media/base/video_frame.h
+++ b/src/media/base/video_frame.h
@@ -16,7 +16,9 @@
 #include "base/callback.h"
 #include "base/check_op.h"
 #include "base/hash/md5.h"
+#include "base/memory/aligned_memory.h"
 #include "base/memory/free_deleter.h"
+#include "base/memory/read_only_shared_memory_region.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/unsafe_shared_memory_region.h"
 #include "base/synchronization/lock.h"
@@ -519,6 +521,13 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // mailbox, the caller must wait for the included sync point.
   const gpu::MailboxHolder& mailbox_holder(size_t texture_index) const;
 
+#if 1
+  // Shared (mmal) frame tracking
+  virtual const base::ReadOnlySharedMemoryRegion* ro_shm_region() const;
+  virtual bool SetBitmapIdAndKillCB(const gpu::Mailbox& id, base::OnceClosure kill);
+  virtual const gpu::Mailbox& GetBitmapId() const;
+#endif
+
 #if defined(OS_LINUX) || defined(OS_CHROMEOS)
   // Returns a vector containing the backing DmaBufs for this frame. The number
   // of returned DmaBufs will be equal or less than the number of planes of
@@ -638,6 +647,10 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
     data_[plane] = ptr;
   }
 
+  void set_mailbox_holder(const unsigned int plane, const gpu::MailboxHolder& mailbox_holder) {
+    mailbox_holders_[plane] = mailbox_holder;
+  }
+
  private:
   // The constructor of VideoFrame should use IsValidConfigInternal()
   // instead of the public IsValidConfig() to check the config, because we can
diff --git a/src/media/base/video_renderer_sink.h b/src/media/base/video_renderer_sink.h
index b7b034cdd020..1835ce7e1780 100644
--- a/src/media/base/video_renderer_sink.h
+++ b/src/media/base/video_renderer_sink.h
@@ -47,6 +47,8 @@ class MEDIA_EXPORT VideoRendererSink {
     // client.
     virtual base::TimeDelta GetPreferredRenderInterval() = 0;
 
+    virtual void TryResizeFrame(uint32_t width, uint32_t height) {}
+
     virtual ~RenderCallback() {}
   };
 
diff --git a/src/media/base/video_types.h b/src/media/base/video_types.h
index b0ce5ceeebfd..5f568f5e7b2a 100644
--- a/src/media/base/video_types.h
+++ b/src/media/base/video_types.h
@@ -84,6 +84,13 @@ enum VideoPixelFormat {
       PIXEL_FORMAT_RGBAF16,  // Must always be equal to largest entry logged.
 };
 
+
+// *****
+// Alias MMAL to ARGB so it is easy to spot where I've used this
+// * In the fullness of time remove this and rename to actual fmt
+#define PIXEL_FORMAT_MMAL_BUFFER PIXEL_FORMAT_XRGB
+
+
 // Returns the name of a Format as a string.
 MEDIA_SHMEM_EXPORT std::string VideoPixelFormatToString(
     VideoPixelFormat format);
diff --git a/src/media/blink/video_frame_compositor.cc b/src/media/blink/video_frame_compositor.cc
index 16e48bf22b0b..8a1563749d41 100644
--- a/src/media/blink/video_frame_compositor.cc
+++ b/src/media/blink/video_frame_compositor.cc
@@ -185,6 +185,13 @@ void VideoFrameCompositor::PutCurrentFrame() {
   rendered_last_frame_ = true;
 }
 
+void VideoFrameCompositor::DidStretchFrame(uint32_t width, uint32_t height)
+{
+  base::AutoLock lock(callback_lock_);
+  if (callback_)
+    callback_->TryResizeFrame(width, height);
+}
+
 bool VideoFrameCompositor::UpdateCurrentFrame(base::TimeTicks deadline_min,
                                               base::TimeTicks deadline_max) {
   DCHECK(task_runner_->BelongsToCurrentThread());
diff --git a/src/media/blink/video_frame_compositor.h b/src/media/blink/video_frame_compositor.h
index 2c7c535d5581..5bb086d3719f 100644
--- a/src/media/blink/video_frame_compositor.h
+++ b/src/media/blink/video_frame_compositor.h
@@ -104,6 +104,7 @@ class MEDIA_BLINK_EXPORT VideoFrameCompositor : public VideoRendererSink,
   scoped_refptr<VideoFrame> GetCurrentFrame() override;
   void PutCurrentFrame() override;
   base::TimeDelta GetPreferredRenderInterval() override;
+  void DidStretchFrame(uint32_t width, uint32_t height) override;
 
   // Returns |current_frame_|, without offering a guarantee as to how recently
   // it was updated. In certain applications, one might need to periodically
diff --git a/src/media/filters/BUILD.gn b/src/media/filters/BUILD.gn
index 9f7dc8c00369..75d66dbd8179 100644
--- a/src/media/filters/BUILD.gn
+++ b/src/media/filters/BUILD.gn
@@ -2,6 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/linux/rpi/args.gni")
 import("//media/gpu/args.gni")
 import("//media/media_options.gni")
 
@@ -97,6 +98,9 @@ source_set("filters") {
   ]
 
   libs = []
+  include_dirs = []
+  public_configs = []
+  public_deps = []
 
   if (proprietary_codecs) {
     sources += [
@@ -105,6 +109,15 @@ source_set("filters") {
     ]
   }
 
+  if (enable_mmal_video_decoder) {
+    sources += [
+      "mmal_video_decoder.cc",
+      "mmal_video_decoder.h",
+    ]
+
+    public_configs += [ "//build/config/linux/rpi:use_mmal" ]
+  }
+
   if (media_use_ffmpeg) {
     deps += [
       "//media/ffmpeg",
diff --git a/src/media/filters/decoder_stream.cc b/src/media/filters/decoder_stream.cc
index b683149d459e..fae409c58f91 100644
--- a/src/media/filters/decoder_stream.cc
+++ b/src/media/filters/decoder_stream.cc
@@ -1000,6 +1000,14 @@ void DecoderStream<StreamType>::CompletePrepare(const Output* output) {
   preparing_output_ = false;
 }
 
+template <DemuxerStream::Type StreamType>
+void DecoderStream<StreamType>::TryResizeFrame(uint32_t width, uint32_t height) const {}
+
+template <>
+void DecoderStream<DemuxerStream::VIDEO>::TryResizeFrame(uint32_t width, uint32_t height) const {
+  decoder_->TryResizeFrame(width, height);
+}
+
 template class DecoderStream<DemuxerStream::VIDEO>;
 template class DecoderStream<DemuxerStream::AUDIO>;
 
diff --git a/src/media/filters/decoder_stream.h b/src/media/filters/decoder_stream.h
index 6fe5739c8d37..cb06f33cb3dc 100644
--- a/src/media/filters/decoder_stream.h
+++ b/src/media/filters/decoder_stream.h
@@ -148,6 +148,8 @@ class MEDIA_EXPORT DecoderStream {
     return decoder_selector_;
   }
 
+  void TryResizeFrame(uint32_t width, uint32_t height) const;
+
  private:
   enum State {
     STATE_UNINITIALIZED,
@@ -313,6 +315,9 @@ bool DecoderStream<DemuxerStream::AUDIO>::CanReadWithoutStalling() const;
 template <>
 int DecoderStream<DemuxerStream::AUDIO>::GetMaxDecodeRequests() const;
 
+template <>
+void DecoderStream<DemuxerStream::VIDEO>::TryResizeFrame(uint32_t width, uint32_t height) const;
+
 using VideoDecoderStream = DecoderStream<DemuxerStream::VIDEO>;
 using AudioDecoderStream = DecoderStream<DemuxerStream::AUDIO>;
 
diff --git a/src/media/filters/mmal_video_decoder.cc b/src/media/filters/mmal_video_decoder.cc
new file mode 100644
index 000000000000..2fa70247efb2
--- /dev/null
+++ b/src/media/filters/mmal_video_decoder.cc
@@ -0,0 +1,5306 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+
+// ***
+// gpu_factories passed to constructor so we may consider generating h/w frames
+// * only want to do this is we have a h/w compositor
+// * if we can generate CMA handles we may be able to use then for full
+//   s/w passthrough, as we should both
+//      be able to use them in xcb_sm_put_image
+//      and be able to decode into them directly
+// Maybe look at
+//  media/video/gpu_memory_buffer_video_frame_pool.cc
+// for inspiration on what is needed.
+
+
+#include "media/filters/mmal_video_decoder.h"
+
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#include <algorithm>
+#include <string>
+#include <queue>
+
+//#include "base/base_switches.h"
+#include "base/bind.h"
+#include "base/callback_helpers.h"
+#include "base/command_line.h"
+#include "base/location.h"
+#include "base/single_thread_task_runner.h"
+#include "base/pickle.h"
+#include "base/memory/ptr_util.h"
+#include "base/posix/unix_domain_socket.h"
+#include "content/public/common/zygote/sandbox_support_linux.h"
+#include "gpu/command_buffer/client/shared_image_interface.h"
+#include "gpu/command_buffer/common/shared_image_usage.h"
+
+#include "media/base/bind_to_current_loop.h"
+#include "media/base/decoder_buffer.h"
+#include "media/base/limits.h"
+#include "media/base/media_switches.h"
+#include "media/base/timestamp_constants.h"
+#include "media/base/video_frame.h"
+#include "media/base/video_util.h"
+#include "media/video/gpu_video_accelerator_factories.h"
+#include "sandbox/policy/linux/sandbox_linux.h"
+#include "services/service_manager/public/cpp/connector.h"
+#include "services/viz/public/cpp/gpu/context_provider_command_buffer.h"
+
+extern "C" {
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/mmal_buffer.h>
+#include <interface/mmal/mmal_parameters_video.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_util_params.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_connection.h>
+#include <interface/mmal/core/mmal_buffer_private.h>  // *** debug
+#include <interface/mmal/vc/mmal_vc_api.h>
+#include <interface/vcsm/user-vcsm.h>
+#include <interface/vmcs_host/vc_vchi_gencmd.h>
+}
+
+#include <iomanip>
+
+// Debug & test defines
+
+// Really the DMA version should be better but in actual performance terms
+// copying on the ARM seems to work better :-(
+#define OPT_FRAME_COPY_DEFAULT FrameCopyMode::FRAME_ARGB_DMA
+//#define OPT_FRAME_COPY_DEFAULT FrameCopyMode::FRAME_ARGB_COPY
+//#define OPT_FRAME_COPY_GPU_DEFAULT FrameCopyMode::FRAME_I420
+#define OPT_FRAME_COPY_GPU_DEFAULT FrameCopyMode::FRAME_GPU_YUV_VCSM
+//#define OPT_FRAME_COPY_GPU_DEFAULT FrameCopyMode::FRAME_GPU_YUV_COPY
+//#define OPT_FRAME_COPY_GPU_DEFAULT FrameCopyMode::FRAME_NV12
+#define TRACE_COMPONENT_CREATION        0
+#define TRACE_TRAMPOLINE                0
+#define TRACE_FRAME_STASH_NEW           0  // Traces memory allocated by FrameStash
+#define TRACE_DESC                      0
+#define TRACE_BUFFER_EVENT              0
+
+// Missing defn
+#define MMAL_COMPONENT_DEFAULT_RESIZER "vc.ril.resize"
+#define MMAL_COMPONENT_ISP_RESIZER "vc.ril.isp"
+
+#define MMAL_SLICE_HEIGHT 16
+#define MMAL_ALIGN_W      32
+#define MMAL_ALIGN_H      16
+
+#define MMAL_LIMIT_WIDTH  VCOS_ALIGN_UP(1920, MMAL_ALIGN_W)
+#define MMAL_LIMIT_HEIGHT VCOS_ALIGN_UP(1088, MMAL_ALIGN_H)
+//#define MMAL_LIMIT_WIDTH  VCOS_ALIGN_UP(2048, MMAL_ALIGN_W)
+//#define MMAL_LIMIT_HEIGHT VCOS_ALIGN_UP(1280, MMAL_ALIGN_H)
+
+#define FRAME_COPY_DEFAULT_BUFFERS      2
+#define SLICE_COPY_DEFAULT_BUFFERS      16
+
+#define MAX_COPY_FRAMES_IN_FLIGHT       8
+
+#define ipc_fd ::content::GetSandboxFD
+
+namespace media {
+
+enum class FrameDescType {
+  unset,
+  SingleShm,
+  SingleGPU,
+  MultiGPU
+};
+
+enum class PortCopy {
+  unset,
+  Copy,
+  Dma,
+  Zc
+};
+
+enum class ResizeMode {
+  unset,
+  Never,
+  Always,
+  Smaller
+};
+
+
+class FrameCopyMode {
+public:
+  enum Mode {
+    unset = 0,
+    SLICE,
+    FRAME_I420,
+    FRAME_NV12,
+    FRAME_ARGB_DMA,
+    FRAME_ARGB_COPY,
+    FRAME_GPU_ARGB_DMA,
+    FRAME_GPU_ARGB_VCSM,
+    FRAME_GPU_YUV_COPY,
+    FRAME_GPU_YUV_VCSM,
+  };
+  static constexpr unsigned int MODE_COUNT = FRAME_GPU_YUV_VCSM + 1;
+
+  static const struct Xlat {
+    const char * name;
+    PortCopy port_copy;
+    unsigned int planes;
+    uint8_t bp4w[4], lp4h[4];
+    VideoPixelFormat pixel_format;
+    MMAL_FOURCC_T mmal_encoding;
+    FrameDescType frame_desc_type;
+    gfx::BufferFormat gfx_buffer_format;
+  } xlat[MODE_COUNT];
+
+  FrameCopyMode(const Mode copy_mode = unset) :
+    copy_mode_(copy_mode)
+  {
+  }
+
+  static FrameCopyMode FromString(const char * name)
+  {
+    for (unsigned int i = 0; i != MODE_COUNT; ++i) {
+      if (strcasecmp(name, xlat[i].name) == 0)
+        return FrameCopyMode((Mode)i);
+    }
+    return FrameCopyMode();
+  }
+
+  ~FrameCopyMode() = default;
+  FrameCopyMode(const FrameCopyMode&) = default;
+  FrameCopyMode& operator=(const FrameCopyMode&) = default;
+
+  FrameCopyMode& operator=(const Mode copy_mode)
+  {
+    copy_mode_ = copy_mode;
+    return *this;
+  }
+
+  operator bool() const
+  {
+    return copy_mode_ != unset;
+  }
+
+  bool operator==(const Mode mode) const
+  {
+    return copy_mode_ == mode;
+  }
+  bool operator!=(const Mode mode) const
+  {
+    return copy_mode_ != mode;
+  }
+
+  bool operator==(const FrameCopyMode& x) const
+  {
+    return copy_mode_ == x.copy_mode_;
+  }
+  bool operator!=(const FrameCopyMode& x) const
+  {
+    return copy_mode_ != x.copy_mode_;
+  }
+
+  Mode get() const
+  {
+    return copy_mode_;
+  }
+
+  gfx::BufferFormat gfx_buffer_format() const
+  {
+    DCHECK(is_gpu());
+    return xlat[copy_mode_].gfx_buffer_format;
+  }
+
+  MMAL_FOURCC_T mmal_encoding() const
+  {
+    return xlat[copy_mode_].mmal_encoding;
+  }
+
+  VideoPixelFormat pixel_format() const
+  {
+    return xlat[copy_mode_].pixel_format;
+  }
+
+  FrameDescType frame_desc_type() const
+  {
+    return xlat[copy_mode_].frame_desc_type;
+  }
+
+  PortCopy port_copy() const
+  {
+    return xlat[copy_mode_].port_copy;
+  }
+
+  bool port_has_pool() const
+  {
+    return port_copy() == PortCopy::Copy;
+  }
+
+  VideoFrame::StorageType frame_storage_type() const
+  {
+    // *** Hmmm...
+    return port_copy() == PortCopy::Zc && is_gpu() ? VideoFrame::STORAGE_DMABUFS : VideoFrame::STORAGE_UNOWNED_MEMORY;
+  }
+
+  unsigned int planes() const
+  {
+    return xlat[copy_mode_].planes;
+  }
+
+  unsigned int width_to_stride(const unsigned int plane, const unsigned width) const
+  {
+    return (xlat[copy_mode_].bp4w[plane] * width) >> 2;
+  }
+
+  unsigned int height_to_lines(const unsigned int plane, const unsigned height) const
+  {
+    return (xlat[copy_mode_].lp4h[plane] * height) >> 2;
+  }
+
+  bool is_slice() const
+  {
+    return copy_mode_ == SLICE;
+  }
+
+  bool is_gpu() const
+  {
+    return frame_desc_type() == FrameDescType::SingleGPU || frame_desc_type() == FrameDescType::MultiGPU;
+  }
+
+  bool is_yuv() const
+  {
+    return
+      copy_mode_ == FrameCopyMode::FRAME_GPU_YUV_COPY ||
+      copy_mode_ == FrameCopyMode::FRAME_GPU_YUV_VCSM ||
+      copy_mode_ == FrameCopyMode::FRAME_NV12 ||
+      copy_mode_ == FrameCopyMode::FRAME_I420;
+  }
+
+  const char * cstr() const
+  {
+    return xlat[copy_mode_].name;
+  }
+
+  friend std::ostream& operator<<(std::ostream& os, const FrameCopyMode& mode);
+
+private:
+  Mode copy_mode_;
+};
+
+#define GEO_UNSET  0, {0,  0,  0,  0}, {0,  0,  0,  0}
+#define GEO_RGBX_1 1, {16, 0,  0,  0}, {4,  0,  0,  0}
+#define GEO_YUV_3  3, {4,  2,  2,  0}, {4,  2,  2,  0}
+#define GEO_YC_2   2, {4,  4,  0,  0}, {4,  2,  0,  0}
+
+// Array designators now not allowed (v80) so have to get the order right here :-(
+const FrameCopyMode::Xlat FrameCopyMode::xlat[FrameCopyMode::MODE_COUNT] =
+{
+//  [unset]               =
+  {"unset",                 PortCopy::unset,          GEO_UNSET,
+    PIXEL_FORMAT_UNKNOWN, MMAL_ENCODING_UNKNOWN,    FrameDescType::unset,     gfx::BufferFormat::R_8},
+//  [SLICE]               =
+  {"SLICE",                 PortCopy::Copy,           GEO_RGBX_1,
+    PIXEL_FORMAT_XRGB,    MMAL_ENCODING_BGRA_SLICE, FrameDescType::SingleShm, gfx::BufferFormat::R_8},
+//  [FRAME_I420]          = 
+  {"SHM-YUV-DMA",           PortCopy::Dma,            GEO_YUV_3,
+    PIXEL_FORMAT_I420,    MMAL_ENCODING_I420,       FrameDescType::SingleShm, gfx::BufferFormat::R_8},
+//  [FRAME_NV12]          = 
+  {"SHM-YC-DMA",            PortCopy::Dma,            GEO_YC_2,
+    PIXEL_FORMAT_NV12,    MMAL_ENCODING_NV12,       FrameDescType::SingleShm, gfx::BufferFormat::R_8},
+//  [FRAME_ARGB_DMA]      = 
+  {"SHM-RGB-DMA",           PortCopy::Dma,            GEO_RGBX_1,
+    PIXEL_FORMAT_XRGB,    MMAL_ENCODING_BGRA,       FrameDescType::SingleShm, gfx::BufferFormat::R_8},
+//  [FRAME_ARGB_COPY]     = 
+  {"SHM-RGB-COPY",          PortCopy::Copy,           GEO_RGBX_1,
+    PIXEL_FORMAT_XRGB,    MMAL_ENCODING_BGRA,       FrameDescType::SingleShm, gfx::BufferFormat::R_8},
+//  [FRAME_GPU_ARGB_DMA]  = 
+  {"GPU-RGB-DMA",           PortCopy::Dma,            GEO_RGBX_1,
+    PIXEL_FORMAT_XRGB,    MMAL_ENCODING_BGRA,       FrameDescType::SingleGPU, gfx::BufferFormat::BGRX_8888},
+//  [FRAME_GPU_ARGB_VCSM] = 
+  {"GPU-RGB-ZC",            PortCopy::Zc,             GEO_RGBX_1,
+    PIXEL_FORMAT_XRGB,    MMAL_ENCODING_BGRA,       FrameDescType::SingleGPU, gfx::BufferFormat::BGRX_8888},
+//  [FRAME_GPU_YUV_COPY]  = 
+  {"GPU-YUV-COPY",          PortCopy::Copy,           GEO_YUV_3,
+    PIXEL_FORMAT_I420,    MMAL_ENCODING_I420,       FrameDescType::MultiGPU,  gfx::BufferFormat::R_8},
+//  [FRAME_GPU_YUV_VCSM]  = 
+  {"GPU-YUV-ZC",            PortCopy::Zc,             GEO_YUV_3,
+    PIXEL_FORMAT_YV12,    MMAL_ENCODING_YV12,       FrameDescType::SingleGPU, gfx::BufferFormat::YVU_420},
+};
+
+
+std::ostream& operator<<(std::ostream& os, const FrameCopyMode& mode)
+{
+  return os << mode.cstr();
+}
+
+
+// Not strictly a decoder count - this is inced @ initialisation
+static volatile base::subtle::Atomic32 decoder_count = 0;
+
+// Supported decoder bitmap (indexed by VideoCodec)
+static unsigned int supported_video_codecs = 0;
+
+// Task runner - current SingleThread - probably no reason
+// why it shouldn't be Sequenced so typedef for ease of changing
+typedef scoped_refptr<base::SequencedTaskRunner> MmalTaskRunner;
+
+
+// Some classes that we have fwd refs to
+class MmalConnectedPort;
+class MmalComponent;
+
+// ----------------------------------------------------------------------------
+//
+// Misc helper fns
+
+// Zap & release buffer
+static void buffer_release(MMAL_BUFFER_HEADER_T * const buffer)
+{
+  mmal_buffer_header_reset(buffer);
+  mmal_buffer_header_release(buffer);
+}
+
+// Calculate pixel aspect ratio
+static gfx::Size par_from_sizes(const gfx::Size& coded, const gfx::Size& natural)
+{
+  uint32_t a = coded.width() * natural.height();
+  uint32_t b = coded.height() * natural.width();
+
+  // Deal with the trivial case
+
+  if (a == b) {
+    return gfx::Size(1, 1);
+  }
+
+  // reduce - probably not needed but it might well save overflow
+  // or precision reduction later in the code
+  // We only expect to do this at init time so inefficiency isn't important
+
+  static const uint32_t primes[] = {2, 3, 5, 7, 11, 13, 17, 19};
+  for (int i = 0; i != sizeof(primes)/sizeof(primes[0]); ++i) {
+    const uint32_t p = primes[i];
+    while (a % p == 0 && b % p == 0) {
+      a /= p;
+      b /= p;
+    }
+  }
+
+  return gfx::Size(b, a);
+}
+
+// Convert a time_t to a printable string
+// * Surely there is a std C++ fn for this?
+static std::string strgmtimet(const time_t tt)
+{
+  char tbuf[32];
+  struct tm tm;
+  gmtime_r(&tt, &tm);
+  tbuf[sizeof(tbuf)-1] = 0;
+  snprintf(tbuf, sizeof(tbuf) - 1, "%04d-%02d-%02d %02d:%02d:%02d UTC",
+      tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+      tm.tm_hour, tm.tm_min, tm.tm_sec);
+  return std::string(tbuf);
+}
+
+static std::string fourcc_string(const MMAL_FOURCC_T fourcc)
+{
+  char buf[10];
+  mmal_4cc_to_string(buf, sizeof(buf), fourcc);
+  return std::string(buf);
+}
+
+
+static VideoCodec fourcc_to_video_codec(const MMAL_FOURCC_T x)
+{
+  switch (x) {
+    case MMAL_ENCODING_H264:
+      return VideoCodec::kCodecH264;
+    case MMAL_ENCODING_WVC1:
+      return VideoCodec::kCodecVC1;
+    case MMAL_ENCODING_MP1V:
+    case MMAL_ENCODING_MP2V:
+      return VideoCodec::kCodecMPEG2;
+    case MMAL_ENCODING_MP4V:
+      return VideoCodec::kCodecMPEG4;
+    case MMAL_ENCODING_THEORA:
+      return VideoCodec::kCodecTheora;
+    case MMAL_ENCODING_VP8:
+      return VideoCodec::kCodecVP8;
+    // Missing FOURCC for
+    // kCodecVP9,
+    // kCodecHEVC,
+    default:
+      break;
+  }
+  return VideoCodec::kUnknownVideoCodec;
+}
+
+static MMAL_FOURCC_T video_codec_to_fourcc(const VideoCodec x)
+{
+  switch (x) {
+    case VideoCodec::kCodecH264:
+      return MMAL_ENCODING_H264;
+    case VideoCodec::kCodecVC1:
+      return MMAL_ENCODING_WVC1;
+    case VideoCodec::kCodecMPEG2:
+      return MMAL_ENCODING_MP2V;
+    case VideoCodec::kCodecMPEG4:
+      return MMAL_ENCODING_MP4V;
+    case VideoCodec::kCodecTheora:
+      return MMAL_ENCODING_THEORA;
+    case VideoCodec::kCodecVP8:
+      return MMAL_ENCODING_VP8;
+    // Missing FOURCC for
+    // kCodecVP9,
+    // kCodecHEVC,
+    default:
+      break;
+  }
+  return MMAL_ENCODING_UNKNOWN;
+}
+
+#if 0
+static MMAL_FOURCC_T video_pixel_format_to_fourcc(const VideoPixelFormat pixel_format)
+{
+  switch (pixel_format) {
+    case PIXEL_FORMAT_I420:
+      return MMAL_ENCODING_I420;
+    case PIXEL_FORMAT_ARGB:
+      return MMAL_ENCODING_BGRA;
+    case PIXEL_FORMAT_ABGR:
+      return MMAL_ENCODING_RGBA;
+    default:
+      break;
+  }
+  return MMAL_ENCODING_UNKNOWN;
+}
+#endif
+
+static MMAL_FOURCC_T color_space_to_mmal(const VideoColorSpace &color_space)
+{
+  switch (color_space.primaries) {
+    case VideoColorSpace::PrimaryID::BT709:
+      return color_space.range == gfx::ColorSpace::RangeID::LIMITED ?
+        MMAL_COLOR_SPACE_ITUR_BT709 :
+        MMAL_COLOR_SPACE_JPEG_JFIF;
+
+    case VideoColorSpace::PrimaryID::SMPTE170M:
+      return MMAL_COLOR_SPACE_ITUR_BT601;
+
+    case VideoColorSpace::PrimaryID::SMPTE240M:
+      return MMAL_COLOR_SPACE_SMPTE240M;
+
+    case VideoColorSpace::PrimaryID::BT470M:
+      return MMAL_COLOR_SPACE_BT470_2_M;
+
+    case VideoColorSpace::PrimaryID::BT470BG:
+      return MMAL_COLOR_SPACE_BT470_2_BG;
+
+    default:
+      break;
+  }
+  return MMAL_COLOR_SPACE_UNKNOWN;
+}
+
+
+static inline uint32_t hashid(const gpu::Mailbox& id)
+{
+  uint32_t x = 0;
+  for (uint32_t c : id.name) {
+    x = x * 67 + c;
+  }
+  return x;
+}
+
+// Do a stride converting copy - if the strides are the same and line_len is
+// close then do a single block copy - we don't expect to have to preserve
+// pixels in the output frame
+static inline void mem_copy_2d(uint8_t * d_ptr, const size_t d_stride, const uint8_t * s_ptr, const size_t s_stride, size_t lines, const size_t line_len)
+{
+  if (s_stride == d_stride && s_stride < line_len + 32)
+  {
+    memcpy(d_ptr, s_ptr, s_stride * lines);
+  }
+  else
+  {
+    while (lines-- != 0) {
+      memcpy(d_ptr, s_ptr, line_len);
+      d_ptr += d_stride;
+      s_ptr += s_stride;
+    }
+  }
+}
+
+//-----------------------------------------------------------------------------
+
+class FpS
+{
+  // Average over this number of frames for running average
+  static const size_t avg_size_ = 128;
+
+  static uint64_t utime()
+  {
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    return (uint64_t)ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
+  }
+
+  uint64_t start_time_;
+  uint64_t period_time_;
+  unsigned int frame_count_;
+
+  uint64_t time_stash_[avg_size_];
+  size_t stash_n_;
+
+  void do_start(const uint64_t now)
+  {
+    start_time_ = now;
+    period_time_ = now;
+    stash_n_ = 0;
+  }
+
+public:
+  FpS() :
+    start_time_(0),
+    period_time_(0),
+    frame_count_(0),
+    time_stash_{0}
+  {
+  }
+
+  void start()
+  {
+    frame_count_ = 0;
+  }
+
+  void inc_frames()
+  {
+    const uint64_t now = utime();
+    if (frame_count_++ == 0)
+      do_start(now);
+    time_stash_[stash_n_] = now;
+    if (++stash_n_ >= avg_size_)
+      stash_n_ = 0;
+  }
+
+  bool period_expired(const uint64_t duration_us)
+  {
+    const uint64_t now = utime();
+    if (period_time_ + duration_us <= now) {
+      period_time_ += duration_us;
+      return true;
+    }
+    return false;
+  }
+
+  std::string ToString()
+  {
+    if (start_time_ == 0) {
+      return std::string("<uninit>");
+    }
+    const uint64_t now = utime();
+    if (start_time_ == now) {
+      return std::string("<inf>");
+    }
+
+    const uint64_t mFpS = ((uint64_t)frame_count_ * 1000000000) / (now - start_time_);
+    const uint64_t mFpS_avg = frame_count_ < avg_size_ ? 0 :
+      ((uint64_t)avg_size_ * 1000000000) / (now - time_stash_[stash_n_]);
+    std::ostringstream s;
+    s << frame_count_  << " @ "
+      << mFpS / 1000 << "." << std::setfill('0') << std::setw(3) << mFpS % 1000 << std::setw(0)
+      << ", avg: " << mFpS_avg / 1000 << "." << std::setfill('0') << std::setw(3) << mFpS_avg % 1000;
+
+    return s.str();
+  }
+};
+
+
+class MmalVideoDecoder::Options
+{
+  const bool single_process_;
+  const FrameCopyMode copy_mode_;
+  const bool red_pixel_;
+  const bool decode_opaque_;
+  const bool decode_i420_;
+  const bool resize_isp_;
+  const bool resize_resizer_;
+  const ResizeMode resize_mode_;
+  const bool low_delay_;
+  const unsigned int frame_buffers_;
+  const int decoders_;
+
+  const bool debug_bench_;
+  const bool debug_fps_;
+  const gfx::Size debug_fixed_size_;
+
+  size_t gpu_mem_ = 0;
+  uint32_t firmware_date_ = 0;
+  bool gpu_frames_ = false;
+  bool tex_import_ = false;
+
+  static unsigned int cl_uint(const base::CommandLine& cmd_line, const char name[], const unsigned int def_val = 0)
+  {
+    unsigned int val;
+    return base::StringToUint(cmd_line.GetSwitchValueNative(name), &val) ? val : def_val;
+  }
+
+  static int cl_int(const base::CommandLine& cmd_line, const char name[], const int def_val = 0)
+  {
+    int val;
+    return base::StringToInt(cmd_line.GetSwitchValueNative(name), &val) ? val : def_val;
+  }
+
+  static bool cl_flag(const base::CommandLine& cmd_line, const char name[])
+  {
+    return cmd_line.HasSwitch(name);
+  }
+
+  static gfx::Size cl_size(const base::CommandLine& cmd_line, const char name[])
+  {
+    base::CommandLine::StringType cl_str(cmd_line.GetSwitchValueNative(name));
+    const char * const cl(cl_str.c_str());
+    char * eoi = nullptr;
+    const unsigned long w = strtoul(cl, &eoi, 10);
+    if (*eoi != 'x' && *eoi != 'X') {
+      return gfx::Size();
+    }
+    const unsigned long h = strtoul(eoi + 1, &eoi, 10);
+    if (*eoi != '\0') {
+      return gfx::Size();
+    }
+    return gfx::Size(w, h);
+  }
+
+  static ResizeMode cl_resize_mode(const base::CommandLine& cmd_line, const char name[])
+  {
+    base::CommandLine::StringType cl_str(cmd_line.GetSwitchValueNative(name));
+    const char * const cl(cl_str.c_str());
+    if (!*cl)
+      return ResizeMode::unset;
+    else if (strcasecmp(cl, "never") == 0)
+      return ResizeMode::Never;
+    else if (strcasecmp(cl, "always") == 0)
+      return ResizeMode::Always;
+    else if (strcasecmp(cl, "smaller") == 0)
+      return ResizeMode::Smaller;
+    LOG(INFO) << "Unexpected resize mode: '" << cl << "'";
+    return ResizeMode::unset;
+  }
+
+  struct FirmwareDates {
+    static constexpr uint32_t HasOpaque = 1477958400;  // 2016-11-01
+    static constexpr uint32_t HasIsp = 1477958400;  // 2016-11-01
+  };
+
+  Options(const base::CommandLine& cmd_line) :
+    single_process_(cl_flag(cmd_line, "single-process" /*switches::kSingleProcess*/)),  // Just too hard to get libs right
+    copy_mode_(FrameCopyMode::FromString(cmd_line.GetSwitchValueNative(switches::kMmalCopyMode).c_str())),
+    red_pixel_(cl_flag(cmd_line, switches::kMmalRedPixel)),
+    decode_opaque_(cl_flag(cmd_line, switches::kMmalDecodeOpaque)),
+    decode_i420_(cl_flag(cmd_line, switches::kMmalDecodeI420)),
+    resize_isp_(cl_flag(cmd_line, switches::kMmalResizeIsp)),
+    resize_resizer_(cl_flag(cmd_line, switches::kMmalResizeResizer)),
+    resize_mode_(cl_resize_mode(cmd_line, switches::kMmalResizeMode)),
+    low_delay_(cl_flag(cmd_line, switches::kMmalLowDelay)),
+    frame_buffers_(cl_uint(cmd_line, switches::kMmalFrameBuffers)),
+    decoders_(cl_int(cmd_line, switches::kMmalDecoders, -1)),
+    debug_bench_(cl_flag(cmd_line, switches::kMmalDebugBench)),
+    debug_fps_(cl_flag(cmd_line, switches::kMmalDebugFps)),
+    debug_fixed_size_(cl_size(cmd_line, switches::kMmalDebugFixedSize))
+  {
+  }
+
+  bool opaque_good() const
+  {
+    return firmware_date_ >= FirmwareDates::HasOpaque;
+  }
+
+  bool isp_resize_good() const
+  {
+    return firmware_date_ >= FirmwareDates::HasIsp &&
+      gpu_mem_ >= (76 << 20);  // Take 76M as threshold for ISP use
+  }
+
+public:
+  static std::unique_ptr<Options> Create(const base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess())
+  {
+    return std::unique_ptr<Options>(new Options(cmd_line));
+  }
+
+  // Default encoding now opaque
+  MMAL_FOURCC_T decoder_out_encoding() const
+  {
+    return  decode_i420_ || !(decode_opaque_ || opaque_good()) ?
+      MMAL_ENCODING_I420 :
+      MMAL_ENCODING_OPAQUE;
+  }
+
+  const char * resizer_component_name() const
+  {
+    return resize_resizer_ || copy_mode_.is_slice() || !(resize_isp_ || isp_resize_good()) ?
+      MMAL_COMPONENT_DEFAULT_RESIZER :
+      MMAL_COMPONENT_ISP_RESIZER;
+  }
+
+  FrameCopyMode frame_copy_mode(const bool has_slice_resize) const
+  {
+    return
+      copy_mode_ ? copy_mode_ :
+      has_slice_resize && !isp_resize_good() ? FrameCopyMode::SLICE :
+      !gpu_frames_ ?
+        OPT_FRAME_COPY_DEFAULT :
+      !tex_import_ ?
+        FrameCopyMode::FRAME_GPU_YUV_COPY :
+        OPT_FRAME_COPY_GPU_DEFAULT;
+  }
+
+  unsigned int frame_buffers(const FrameCopyMode copy_mode) const
+  {
+    return frame_buffers_ != 0 ? frame_buffers_ :
+      copy_mode == FrameCopyMode::SLICE ? SLICE_COPY_DEFAULT_BUFFERS : FRAME_COPY_DEFAULT_BUFFERS;
+  }
+
+  bool single_process() const
+  {
+    return single_process_;
+  }
+
+  unsigned int max_decoders() const
+  {
+    return decoders_ >= 0 ? decoders_ :
+      gpu_mem_ < (64 << 20) ? 0 : 1;  // Kill MMAL decode if we clearly have insufficient GPU mem
+  }
+
+  bool red_pixel() const
+  {
+    return red_pixel_;
+  }
+
+  bool low_delay(const bool low_delay_req = false) const
+  {
+    return low_delay_ || low_delay_req;
+  }
+
+  bool debug_bench() const
+  {
+    return debug_bench_;
+  }
+
+  bool debug_fps() const
+  {
+    return debug_bench_ || debug_fps_;
+  }
+
+  bool debug_fixed_size_set() const
+  {
+    return debug_fixed_size_.width() > 0 && debug_fixed_size_.height()  > 0;
+  }
+
+  gfx::Size debug_fixed_size() const
+  {
+    return debug_fixed_size_;
+  }
+
+  bool gpu_frames() const
+  {
+    return gpu_frames_;
+  }
+
+  ResizeMode resize_mode() const
+  {
+    return resize_mode_ != ResizeMode::unset ? resize_mode_ :
+      !gpu_frames() ? ResizeMode::Always :
+        ResizeMode::Smaller;
+  }
+
+  void set_gpu_mem(const size_t size)
+  {
+    gpu_mem_ = size;
+  }
+
+  void set_firmware_date(const uint32_t date)
+  {
+    firmware_date_ = date;
+  }
+
+  void set_gpu_frames(const bool gpu_frames)
+  {
+    gpu_frames_ = gpu_frames;
+  }
+
+  void set_tex_import(const bool tex_import)
+  {
+    tex_import_ = tex_import;
+  }
+
+  std::string ToString() const
+  {
+    std::ostringstream s;
+    s << "mmal frame_buffers=" << frame_buffers_ <<
+       ", mmal_copy_mode=" << copy_mode_ <<
+       ", mmal_low_delay=" << low_delay_ <<
+       ", mmal_decode_i420/opaque=" << decode_i420_ << "/" << decode_opaque_ <<
+       ", mmal_resize_isp/resizer=" << resize_isp_ << "/" << resize_resizer_ <<
+       ", mmal_resize_mode=" << (int)resize_mode_ <<
+       ", mmal_decoders=" << decoders_ <<
+       ", mmal_debug_bench=" << debug_bench_ <<
+       ", mmal_debug_fps=" << debug_fps_ <<
+       ", mmal_debug_fixed_size=" << debug_fixed_size_.ToString() <<
+       ", gpu_mem=" << gpu_mem_ <<
+       ", firmware_date=" << strgmtimet(firmware_date_) <<
+       ", gpu_frames=" << gpu_frames_ <<
+       ", tex_import=" << tex_import_;
+    return s.str();
+  }
+
+  std::string OptString() const
+  {
+    std::ostringstream s;
+    s << "isp_resize_good=" << isp_resize_good() <<
+      ", frame_copy_mode=" << frame_copy_mode(true) <<
+      ", resizer_component=" << resizer_component_name() <<
+      ", encoding=" << fourcc_string(decoder_out_encoding());
+    return s.str();
+  }
+};
+
+
+//-----------------------------------------------------------------------------
+
+
+#if TRACE_FRAME_STASH_NEW
+volatile base::subtle::Atomic32 total_stash_alloc = 0;
+#endif
+
+class VcsmAlloc
+{
+  unsigned int handle_ = 0;
+  unsigned int vc_ = 0;
+
+public:
+  VcsmAlloc() = default;
+
+  ~VcsmAlloc()
+  {
+    if (handle_ != 0)
+      vcsm_free(handle_);
+  }
+
+  operator bool() const
+  {
+    return handle_ != 0;
+  }
+
+  unsigned int get() const
+  {
+    return handle_;
+  }
+
+  unsigned int vc() const
+  {
+    return vc_;
+  }
+
+  bool ImportDmaBuf(const int fd)
+  {
+    DCHECK(handle_ == 0);
+    if (fd < 0 || (handle_ = vcsm_import_dmabuf(fd, "ChromeVideo")) == 0) {
+      return false;
+    }
+    vc_ = vcsm_vc_hdl_from_hdl(handle_);
+    return true;
+  }
+};
+
+class VcGenCmd {
+  bool init_good;
+  VCHI_INSTANCE_T vchi_instance;
+  VCHI_CONNECTION_T *vchi_connection = nullptr;
+
+public:
+  VcGenCmd() :
+    init_good(false),
+    vchi_instance(0),
+    vchi_connection(nullptr)
+  {
+    if (vchi_initialise(&vchi_instance) != 0) {
+      LOG(ERROR) << "VCHI initialization failed";
+      return;
+    }
+
+    //create a vchi connection
+    if (vchi_connect(nullptr, 0, vchi_instance) != 0) {
+      LOG(ERROR) << "VCHI connection failed";
+      return;
+    }
+
+    vc_vchi_gencmd_init(vchi_instance, &vchi_connection, 1);
+    init_good = true;
+  }
+
+  ~VcGenCmd()
+  {
+    if (init_good) {
+      int err;
+
+      vc_gencmd_stop();
+
+      //close the vchi connection
+      if ((err = vchi_disconnect(vchi_instance)) != 0) {
+        LOG(ERROR) << "VCHI disconnect failed, err=" << err;
+      }
+    }
+  }
+
+  size_t get_memory_gpu() const
+  {
+    int err;
+
+    if (!init_good) {
+      return 0;
+    }
+
+    //send the gencmd for the argument
+    if ((err = vc_gencmd_send("get_mem gpu")) != 0) {
+      LOG(ERROR) << "vc_gencmd_send returned " << err;
+      return 0;
+    }
+
+    char rbuf[1024] = {0};
+    if ((err = vc_gencmd_read_response(rbuf, sizeof(rbuf) - 1)) != 0) {
+      LOG(ERROR) << "vc_gencmd_read_response returned " << err;
+      return 0;
+    }
+
+    if (strncmp(rbuf, "gpu=", 4) != 0) {
+      LOG(ERROR) << "Unexpected response for get_mem gpu: '" << rbuf << "'";
+      return 0;
+    }
+
+    char * p;
+    unsigned long m = strtoul(rbuf + 4, &p, 10);
+
+    if (p[0] != 'M' || p[1] !='\0') {
+      LOG(ERROR) << "Unexpected numeric for get_mem gpu: '" << rbuf << "'";
+      return 0;
+    }
+
+    return m << 20;
+  }
+};
+
+class MmalVcInit : public base::RefCountedThreadSafe<MmalVcInit>
+{
+  static base::Lock& lock_;
+  static int ref_count_;
+
+  // Firmware & gpu_mem aren't going to change mid run so read once and
+  // use everywhere
+  static uint32_t firmware_date_;
+  static size_t gpu_mem_;
+  static bool cma_opened_;
+
+  bool init_done_;
+
+  friend base::RefCountedThreadSafe<MmalVcInit>;
+  virtual ~MmalVcInit()
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ Destroy MmalVcInit done=" << init_done_ << ", count=" << ref_count_;
+#endif
+
+    if (init_done_) {
+      base::AutoLock lock(lock_);
+      if (--ref_count_ == 0) {
+        mmal_vc_deinit();
+        vcsm_exit();
+      }
+    }
+  }
+
+  MmalVcInit(const bool single_process, const bool cma_req) :
+    init_done_(false)
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ Create MmalVcInit";
+#endif
+
+    base::AutoLock lock(lock_);
+
+    // Already done in this process?
+    if (ref_count_ != 0)
+    {
+      ++ref_count_;
+      init_done_ = true;
+      return;
+    }
+
+    // 1st time init static
+    cma_opened_ = false;
+
+    // The returned fds are at a minimum duped so close unconditionally when we exit
+    base::ScopedFD vchiq_fd;
+    base::ScopedFD vcsm_fd;
+
+    if (!single_process) {
+      {
+        base::Pickle request;
+        request.WriteInt(::sandbox::policy::SandboxLinux::METHOD_OPEN_DEV_VCSM);
+        request.WriteBool(cma_req);
+
+        uint8_t reply_buf[512];
+        int fd;
+        const ssize_t reply_len = base::UnixDomainSocket::SendRecvMsgWithFlags(
+            ipc_fd(), reply_buf, sizeof(reply_buf), 0, &fd, request);
+        vcsm_fd = base::ScopedFD(fd);
+
+        if (reply_len == -1 || !vcsm_fd.is_valid()) {
+          LOG(ERROR) << "Failed to open vcsm device";
+          return;
+        }
+
+        base::Pickle reply(reinterpret_cast<char *>(reply_buf), reply_len);
+        base::PickleIterator pickle_iter(reply);
+        if (!pickle_iter.ReadBool(&cma_opened_))
+        {
+          LOG(ERROR) << "### Failed to valid vcsm open reply";
+          return;
+        }
+      }
+
+      {
+        base::Pickle request;
+        request.WriteInt(::sandbox::policy::SandboxLinux::METHOD_OPEN_DEV_VCHIQ);
+
+        uint8_t reply_buf[512];
+        int fd;
+        const ssize_t reply_len = base::UnixDomainSocket::SendRecvMsgWithFlags(
+            ipc_fd(), reply_buf, sizeof(reply_buf), 0, &fd, request);
+        vchiq_fd = base::ScopedFD(fd);
+
+        if (reply_len == -1 || !vchiq_fd.is_valid()) {
+          LOG(ERROR) << "### Failed to open /dev/vchiq";
+          return;
+        }
+
+        // * Single process version of this?
+        base::Pickle reply(reinterpret_cast<char *>(reply_buf), reply_len);
+        base::PickleIterator pickle_iter(reply);
+        if (!pickle_iter.ReadUInt32(&firmware_date_))
+        {
+          LOG(ERROR) << "### Failed to get firmware date";
+          return;
+        }
+      }
+    }
+
+    int rv = vcsm_init_ex(cma_opened_, vcsm_fd.get());
+    if (rv != 0)
+    {
+      LOG(ERROR) << "### vcsm_init_ex("  << cma_opened_ << ", " << vcsm_fd.get() <<  ") failed, rv=" << rv;
+      return;
+    }
+
+    MMAL_STATUS_T err = mmal_vc_init_fd(vchiq_fd.get());
+    if (err != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_vc_init_fd failed: fd=" << vchiq_fd.get() << ", err=" << err;
+      vcsm_exit();
+      return;
+    }
+
+    ++ref_count_;
+    init_done_ = true;
+
+    gpu_mem_ = VcGenCmd().get_memory_gpu();
+  }
+public:
+  static scoped_refptr<MmalVcInit> Init(const bool single_process, const bool cma_wanted)
+  {
+    scoped_refptr<MmalVcInit> vci(new MmalVcInit(single_process, cma_wanted));
+
+    if (!vci->init_done_)
+      return nullptr;
+
+    return vci;
+  }
+
+  uint32_t firmware_date() const
+  {
+    return firmware_date_;
+  }
+
+  uint32_t gpu_mem() const
+  {
+    return gpu_mem_;
+  }
+
+  bool cma_opened() const
+  {
+    return cma_opened_;
+  }
+};
+
+
+base::Lock& MmalVcInit::lock_ = *new base::Lock();  // Somewhat nasty way of avoiding exit-time destruction
+int MmalVcInit::ref_count_ = 0;
+uint32_t MmalVcInit::firmware_date_ = 0;
+size_t MmalVcInit::gpu_mem_ = 0;
+bool MmalVcInit::cma_opened_ = false;
+
+// ----------------------------------------------------------------------------
+
+class FrameDescGPU;
+class FrameDesc
+{
+protected:
+  const unsigned int n_;  // Number of buffers
+  const uint32_t buffer_size_;
+  const gfx::Size frame_size_;
+  const gfx::ColorSpace color_space_;
+  uint32_t length_ = 0;
+  gpu::Mailbox id_;
+  bool valid_ = false;
+
+  FrameDesc(const unsigned int n, const size_t buffer_size, const gfx::Size& frame_size, const gfx::ColorSpace& color_space) :
+    n_(n),
+    buffer_size_(buffer_size),
+    frame_size_(frame_size),
+    color_space_(color_space)
+  {
+#if TRACE_DESC
+    LOG(INFO) << __func__ << ": " << (void *)this;
+#endif
+  }
+
+public:
+  virtual ~FrameDesc() {
+#if TRACE_DESC
+    LOG(INFO) << __func__ << ": " << (void *)this;
+#endif
+  }
+
+  bool is_valid() const {
+    return valid_;
+  }
+
+  size_t size() const {
+    return buffer_size_;
+  }
+
+  unsigned int buffer_count() const
+  {
+    return n_;
+  }
+
+  const gfx::Size& frame_size() const {
+    return frame_size_;
+  }
+
+  const gfx::ColorSpace& color_space() const {
+    return color_space_;
+  }
+
+  const gpu::Mailbox& get_id() const
+  {
+    return id_;
+  }
+
+  virtual unsigned int vc_handle()
+  {
+    return 0;
+  }
+
+  virtual FrameDescGPU * as_gpu()
+  {
+    return nullptr;
+  }
+  virtual const FrameDescGPU * as_gpu() const
+  {
+    return nullptr;
+  }
+
+  // 0 => no idea (needs a pixel type)
+  virtual int stride(const unsigned int plane_no = 0) const
+  {
+    return 0;
+  }
+
+  // Frame data
+  virtual uint8_t * frame(const unsigned int plane_no = 0) = 0;  // Not const as we may map
+  virtual base::ReadOnlySharedMemoryRegion * shared_memory()
+  {
+    return nullptr;
+  }
+  virtual void set_id_and_kill_cb(const gpu::Mailbox& id, base::OnceClosure kill_cb) = 0;
+
+  static FrameDesc * Extract(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    FrameDesc *const desc = (FrameDesc *)buffer->user_data;
+    DCHECK(desc != nullptr);
+//    DCHECK(desc->frame() == buffer->data);  // ** untrue for zc
+
+    buffer->user_data = nullptr;
+    buffer->data = nullptr;
+    buffer->length = 0;
+    buffer->alloc_size = 0;
+
+    return desc;
+  }
+
+  // ?? Maybe generate an Import method?
+};
+
+
+
+class FrameDescShmSingleBuffer : public FrameDesc
+{
+  base::ReadOnlySharedMemoryRegion smr_;
+  base::WritableSharedMemoryMapping smm_;
+
+//  std::unique_ptr<base::SharedMemory> shm_;
+  base::OnceClosure on_kill_cb_;
+
+public:
+  FrameDescShmSingleBuffer(const size_t size, const gfx::Size& frame_size, const gfx::ColorSpace& color_space) :
+    FrameDesc(1, size, frame_size, color_space)
+  {
+#if TRACE_FRAME_STASH_NEW
+    const base::subtle::Atomic32 talloc = base::subtle::NoBarrier_AtomicIncrement(&total_stash_alloc, (base::subtle::Atomic32)size);
+    LOG(ERROR) << "New frame: size=" << size << ", total=" << talloc;
+#endif
+
+    base::WritableSharedMemoryRegion wsmr(base::WritableSharedMemoryRegion::Create(size));
+    if (!wsmr.IsValid())
+    {
+      LOG(ERROR) << "### Smr creation failed";
+      return;
+    }
+
+    smm_ = wsmr.Map();
+    if (!smm_.IsValid())
+    {
+      LOG(ERROR) << "### Smm creation failed";
+      return;
+    }
+
+    smr_ = base::WritableSharedMemoryRegion::ConvertToReadOnly(std::move(wsmr));
+    if (!smr_.IsValid())
+    {
+      LOG(ERROR) << "### Smr make RO failed";
+      return;
+    }
+
+    valid_ = true;
+  }
+
+  ~FrameDescShmSingleBuffer() override
+  {
+//    LOG(ERROR) << " destroy frame desc fd=" << (shm_ == nullptr ? -99 : shm_->handle().fd);
+    if (!on_kill_cb_.is_null()) {
+      std::move(on_kill_cb_).Run();
+    }
+#if TRACE_FRAME_STASH_NEW
+    if (smm_.memory()) {
+      const base::subtle::Atomic32 talloc = base::subtle::NoBarrier_AtomicIncrement(&total_stash_alloc, -(base::subtle::Atomic32)buffer_size_);
+      LOG(ERROR) << "Delete frame: size=" << buffer_size_ << ", total=" << talloc;
+    }
+#endif
+  }
+
+  uint8_t * frame(const unsigned int plane_no = 0) override
+  {
+    DCHECK(plane_no == 0);
+    return (uint8_t *)smm_.memory();
+  }
+
+  base::ReadOnlySharedMemoryRegion * shared_memory() override
+  {
+    return &smr_;
+  }
+
+  void set_id_and_kill_cb(const gpu::Mailbox& id, base::OnceClosure kill_cb) override
+  {
+    if (id.IsZero()) {
+      return;
+    }
+    if (!id_.IsZero()) {
+      if (id != id_) {
+        LOG(ERROR) << "FrameDesc::" << __func__ << " ids don't match: " << hashid(id) << " -> " << hashid(id_);
+      }
+      return;
+    }
+    id_ = id;
+//    LOG(ERROR) << "FrameDesc::" << __func__ << " id=" << MmalVideoFrame::hashid(id);
+    if (!kill_cb.is_null()) {
+      on_kill_cb_ = std::move(kill_cb);
+    }
+  }
+};
+
+class FrameDescGPU : public FrameDesc
+{
+#if 0
+  static void DoMailboxHoldersReleased(
+      GpuVideoAcceleratorFactories* const gpu_factories,
+      const gpu::SyncToken release_sync_token,
+      std::unique_ptr<base::ScopedClosureRunner> waited_cb)
+  {
+    gpu_factories->SignalSyncToken(
+        release_sync_token,
+        base::BindOnce(&base::ScopedClosureRunner::RunAndReset, std::move(waited_cb)));
+  }
+#endif
+
+protected:
+  GpuVideoAcceleratorFactories* const gpu_factories_;
+  scoped_refptr<base::SequencedTaskRunner> gpu_thread_;
+
+  FrameDescGPU(
+      GpuVideoAcceleratorFactories* const gpu_factories,
+      const unsigned int n,
+      const size_t buffer_size, const gfx::Size& frame_size, const gfx::ColorSpace& color_space) :
+    FrameDesc(n, buffer_size, frame_size, color_space),
+    gpu_factories_(gpu_factories),
+    gpu_thread_(gpu_factories->GetTaskRunner())
+  {
+#if TRACE_DESC
+    LOG(INFO) << __func__;
+#endif
+  }
+  ~FrameDescGPU() override
+  {
+  }
+
+public:
+  const FrameDescGPU * as_gpu() const override
+  {
+    return this;
+  }
+  FrameDescGPU * as_gpu() override
+  {
+    return this;
+  }
+
+  void set_id_and_kill_cb(const gpu::Mailbox &id, base::OnceClosure kill_cb) override {
+    LOG(ERROR) << __func__ << ": Unexpected for GPU frame";
+    id_ = id;
+  }
+
+  void RunInGPUThreadOnce(base::OnceClosure closure)
+  {
+    gpu_thread_->PostTask(FROM_HERE, std::move(closure));
+  }
+
+  virtual int SetSyncImage(gpu::MailboxHolder * const boxes) = 0;
+#if 0
+  void MailboxHoldersReleased(const gpu::SyncToken& release_sync_token, std::unique_ptr<base::ScopedClosureRunner> waited_cb)
+  {
+    RunInGPUThreadOnce(base::BindOnce(&FrameDescGPU::DoMailboxHoldersReleased,
+                                      base::Unretained(gpu_factories_), release_sync_token, std::move(waited_cb)));
+  }
+#endif
+};
+
+
+class FrameDescGPUSingleBuffer : public FrameDescGPU
+{
+  enum class MapState {
+    Unmapped,
+    Mapped,
+    Fail
+  };
+
+  std::unique_ptr<gfx::GpuMemoryBuffer> gpu_buf_;
+  MapState map_state_ = MapState::Unmapped;
+  VcsmAlloc vcsm_;
+  MapState vcsm_state_ = MapState::Unmapped;
+
+//  const gfx::BufferFormat buffer_format_;
+  const uint32_t texture_target_;
+  gpu::Mailbox mailbox_;  // ?? Use Frame mailbox or id_ ??
+
+  static void DestroySharedImage(GpuVideoAcceleratorFactories* const gpu_factories, gpu::Mailbox mailbox)
+  {
+    gpu::SharedImageInterface *const sii = gpu_factories->SharedImageInterface();
+    if (sii == nullptr) {
+      LOG(INFO) << __func__ << "SharedImageInterface gone away";
+    }
+    else {
+      sii->DestroySharedImage(gpu::SyncToken(), mailbox);
+    }
+  }
+
+public:
+  FrameDescGPUSingleBuffer(GpuVideoAcceleratorFactories* const gpu_factories,
+                          const size_t buffer_size, const gfx::Size& frame_size, const gfx::ColorSpace& color_space,
+                          const gfx::BufferFormat buffer_format) :
+    FrameDescGPU(gpu_factories, 1, buffer_size, frame_size, color_space),
+//    buffer_format_(buffer_format),
+    texture_target_(gpu_factories_->ImageTextureTarget(buffer_format))
+  {
+#if TRACE_DESC
+    LOG(INFO) << __func__ << ": factories=" << (void*)gpu_factories;
+//     << ": " << frame_size.ToString() << ", type=" << gpu_buf_->GetType() << ", target=" << texture_target_;
+#endif
+    gpu_buf_ = gpu_factories->CreateGpuMemoryBuffer(frame_size, buffer_format,
+                                                  gfx::BufferUsage::SCANOUT_CPU_READ_WRITE);
+    if (!gpu_buf_) {
+      vcsm_state_ = MapState::Fail;
+      LOG(WARNING) << __func__ << ": Failed to create GPU buffer";
+      return;
+    }
+
+    valid_ = true;
+  }
+
+  void DeleteTexture()
+  {
+    if (!mailbox_.IsZero()) {
+      // Annoyingly must be run on gpu thread - so do that
+      RunInGPUThreadOnce(base::BindOnce(&FrameDescGPUSingleBuffer::DestroySharedImage, gpu_factories_, mailbox_));
+      mailbox_.SetZero();
+    }
+  }
+
+  ~FrameDescGPUSingleBuffer() override {
+    DeleteTexture();
+    if (map_state_ == MapState::Mapped)
+      gpu_buf_->Unmap();
+  }
+
+  // Used by GPUMultiBuffer
+  void SetSharedImage(gpu::SharedImageInterface *const sii, gpu::MailboxHolder * const boxes)
+  {
+    if (!mailbox_.IsZero()) {
+      sii->UpdateSharedImage(gpu::SyncToken(), mailbox_);   // *** Sync?? **
+    }
+    else {
+      const uint32_t flags =
+          gpu::SHARED_IMAGE_USAGE_GLES2_FRAMEBUFFER_HINT |
+          gpu::SHARED_IMAGE_USAGE_GLES2 | gpu::SHARED_IMAGE_USAGE_RASTER |
+          gpu::SHARED_IMAGE_USAGE_DISPLAY | gpu::SHARED_IMAGE_USAGE_SCANOUT;
+
+      mailbox_ = sii->CreateSharedImage(gpu_buf_.get(),
+                                   gpu_factories_->GpuMemoryBufferManager(),
+                                   color_space_,
+                                   GrSurfaceOrigin::kTopLeft_GrSurfaceOrigin,
+                                   SkAlphaType::kOpaque_SkAlphaType,
+                                   flags);
+    }
+
+    if (mailbox_.IsZero()) {
+      LOG(ERROR) << __func__ << ": Failed to create output mailbox";
+    }
+
+    boxes[0].mailbox = mailbox_;
+    boxes[0].texture_target = texture_target_;
+  }
+
+  int SetSyncImage(gpu::MailboxHolder * const boxes) override
+  {
+    gpu::SharedImageInterface *const sii = gpu_factories_->SharedImageInterface();
+
+    if (!sii)
+      return -1;
+
+    SetSharedImage(sii, boxes);
+
+    boxes[0].sync_token = sii->GenUnverifiedSyncToken();
+    return 1;
+  }
+
+  uint8_t * frame(const unsigned int plane_no = 0) override
+  {
+    if (map_state_ == MapState::Unmapped) {
+      map_state_ = gpu_buf_->Map() ? MapState::Mapped : MapState::Fail;
+    }
+    return map_state_ != MapState::Mapped ? nullptr : (uint8_t *)gpu_buf_->memory(plane_no);
+  }
+
+  unsigned int vc_handle() override
+  {
+    if (vcsm_state_ == MapState::Unmapped)
+    {
+      vcsm_state_ = MapState::Fail;
+      if (gpu_buf_->GetType() == gfx::NATIVE_PIXMAP)
+      {
+        // We don't have a ref method so have to copy :-(
+        // Cloned handles will close with bh
+        gfx::GpuMemoryBufferHandle bh(gpu_buf_->CloneHandle());
+        if (!bh.is_null()) {
+          if (vcsm_.ImportDmaBuf(bh.native_pixmap_handle.planes[0].fd.get()))
+            vcsm_state_ = MapState::Mapped;
+        }
+      }
+    }
+    return vcsm_state_ != MapState::Mapped ? 0 : vcsm_.vc();
+  }
+
+  int stride(const unsigned int plane_no = 0) const override {
+    return gpu_buf_->stride(plane_no);
+  }
+};
+
+
+class FrameDescGPUMultiBuffer : public FrameDescGPU
+{
+  gpu::Mailbox mailbox_;  // ?? Use Frame mailbox or id_ ??
+  std::unique_ptr<FrameDescGPUSingleBuffer> planes_[4];
+
+public:
+  enum MultiType {
+    YUV,
+    YC
+  };
+
+  FrameDescGPUMultiBuffer(GpuVideoAcceleratorFactories* const gpu_factories,
+                         const size_t buffer_size, const gfx::Size& frame_size, const gfx::ColorSpace& color_space,
+                         const gfx::BufferFormat buffer_format, const MultiType mt) :
+    FrameDescGPU(gpu_factories, mt == YC ? 2 : 3, buffer_size, frame_size, color_space)
+  {
+#if TRACE_DESC
+    LOG(INFO) << __func__;
+#endif
+    // All mutitypes start with a full size plane
+    planes_[0] = std::make_unique<FrameDescGPUSingleBuffer>(gpu_factories, buffer_size, frame_size, color_space, buffer_format);
+    if (!planes_[0]->is_valid())
+      return;
+
+    switch (mt) {
+      case YUV:
+      {
+        const gfx::Size uv_size((frame_size.width() + 1) / 2, (frame_size.height() + 1) / 2);
+        planes_[1] = std::make_unique<FrameDescGPUSingleBuffer>(gpu_factories, buffer_size/4, uv_size, color_space, buffer_format);
+        if (!planes_[1]->is_valid())
+          return;
+        planes_[2] = std::make_unique<FrameDescGPUSingleBuffer>(gpu_factories, buffer_size/4, uv_size, color_space, buffer_format);
+        if (!planes_[2]->is_valid())
+          return;
+        break;
+      }
+      case YC:
+      {
+        const gfx::Size c_size(frame_size.width(), (frame_size.height() + 1) / 2);
+        planes_[1] = std::make_unique<FrameDescGPUSingleBuffer>(gpu_factories, buffer_size/2, c_size, color_space, buffer_format);
+        if (!planes_[1]->is_valid())
+          return;
+        break;
+      }
+    }
+
+    valid_ = true;
+  }
+
+  ~FrameDescGPUMultiBuffer() override
+  {
+  }
+
+  // Frame data
+  uint8_t * frame(const unsigned int plane_no = 0) override
+  {
+    return planes_[plane_no]->frame();
+  }
+
+  int stride(const unsigned int plane_no = 0) const override
+  {
+    return planes_[plane_no]->stride();
+  }
+
+  int SetSyncImage(gpu::MailboxHolder * const boxes) override
+  {
+    gpu::SharedImageInterface *const sii = gpu_factories_->SharedImageInterface();
+
+    if (!sii)
+      return -1;
+
+    for (unsigned int i = 0; i != n_; ++i)
+      planes_[i]->SetSharedImage(sii, boxes + i);
+
+    const gpu::SyncToken token(sii->GenUnverifiedSyncToken());
+
+    for (unsigned int i = 0; i != n_; ++i)
+      boxes[i].sync_token = token;
+
+    return n_;
+  }
+};
+
+// Simple class to stash frames
+// Thread unsafe - use external locks
+class FrameStash
+{
+  bool killing_ = false;
+  const size_t size_ = 0;
+  const gfx::Size frame_size_;
+  const FrameCopyMode copy_mode_;
+  const gfx::ColorSpace color_space_;
+
+  std::queue<FrameDesc *> frames_;
+  GpuVideoAcceleratorFactories* const gpu_factories_;
+
+  FrameDesc * frame_pop()
+  {
+    FrameDesc * const frame = frames_.front();
+    frames_.pop();
+    return frame;
+  }
+
+  void empty_frames()
+  {
+    while (!frames_.empty()) {
+      delete frame_pop();
+    }
+  }
+
+  FrameDesc * new_frame() const
+  {
+    switch (copy_mode_.frame_desc_type())
+    {
+      case FrameDescType::SingleShm:
+        return new FrameDescShmSingleBuffer(size_, frame_size_, color_space_);
+      case FrameDescType::SingleGPU:
+        return new FrameDescGPUSingleBuffer(gpu_factories_, size_, frame_size_, color_space_,
+                                           copy_mode_.gfx_buffer_format());
+      case FrameDescType::MultiGPU:
+        return new FrameDescGPUMultiBuffer(gpu_factories_, size_, frame_size_, color_space_,
+                                          copy_mode_.gfx_buffer_format(), FrameDescGPUMultiBuffer::MultiType::YUV);
+      case FrameDescType::unset:
+        break;
+    }
+    return nullptr;
+  }
+
+public:
+  FrameStash(GpuVideoAcceleratorFactories* const gpu_factories,
+             const uint32_t buffer_size, const gfx::Size& frame_size,
+             const FrameCopyMode& copy_mode, const gfx::ColorSpace color_space) :
+    size_(buffer_size),
+    frame_size_(frame_size),
+    copy_mode_(copy_mode),
+    color_space_(color_space),
+    gpu_factories_(gpu_factories)
+  {
+  }
+
+  virtual ~FrameStash()
+  {
+    empty_frames();
+  }
+
+  void free_frame(FrameDesc * const frame)
+  {
+    if (killing_)
+      delete frame;
+    else
+      frames_.push(frame);
+  }
+
+  FrameDesc * alloc_frame()
+  {
+    if (killing_)
+      return nullptr;
+
+//    return !frames_.empty() ? frame_pop() : new_frame();
+    // ### Keep an old one to avoid any possibility of overwrite
+    FrameDesc * const frame = frames_.size() > 1 ? frame_pop() : new_frame();
+    if (!frame)
+      return nullptr;
+    if (!frame->is_valid()) {
+      delete frame;
+      return nullptr;
+    }
+    return frame;
+  }
+
+  void free_all_frames()
+  {
+    killing_ = true;
+    empty_frames();
+  }
+
+  const FrameCopyMode& copy_mode() const
+  {
+    return copy_mode_;
+  }
+
+  GpuVideoAcceleratorFactories* gpu_factories() const {
+    return gpu_factories_;
+  }
+};
+
+//-----------------------------------------------------------------------------
+
+// If main list is being reclaimed then all subsequent extracts should fail
+// If we have one or more running extracts then they must finish before
+// reclaim starts (by definition they must be on another thread)
+
+class DeferredList;
+class DeferredReclaim;
+class DeferredBuffer
+{
+  friend DeferredList;
+
+  scoped_refptr<DeferredList> list_;
+
+  MMAL_BUFFER_HEADER_T * buffer;    // protected by list_->reclaim_lock_
+  DeferredBuffer * next = nullptr;  // protected by list_->list_lock_
+  DeferredBuffer * prev = nullptr;  // protected by list_->list_lock_
+  bool has_lock = false;
+
+  DeferredBuffer(DeferredList * const dlist, MMAL_BUFFER_HEADER_T * const buffer) :
+    list_(dlist),
+    buffer(buffer)
+  {
+    DCHECK(buffer != nullptr);
+  }
+
+public:
+  ~DeferredBuffer();
+
+  MMAL_BUFFER_HEADER_T * ExtractAndLock();
+};
+
+// Locking:
+//   Reclaim = ReclaimStart -> ReclaimFinish
+//   InUse = Extract -> DeferredBuffer destruction
+//
+//   ReclaimStart waits for !InUse
+//   Extract fails on Reclaim
+//   AddBuffer fails on Reclaim
+
+
+class DeferredList : public base::RefCountedThreadSafe<DeferredList>
+{
+  friend base::RefCountedThreadSafe<DeferredList>;
+  friend DeferredReclaim;
+  friend DeferredBuffer;
+
+  base::Lock list_lock_;
+  base::Lock reclaim_lock_;
+  bool reclaim_ = false;
+
+  DeferredBuffer * head_ = nullptr;
+  DeferredBuffer * tail_ = nullptr;
+
+  int reclaim_count_;
+
+  ~DeferredList()
+  {
+    DCHECK(head_ == nullptr);
+    DCHECK(tail_ == nullptr);
+  }
+
+  void ReclaimStart() EXCLUSIVE_LOCK_FUNCTION(reclaim_lock_)
+  {
+    {
+      base::AutoLock lock(list_lock_);
+      reclaim_ = true;
+    }
+
+    reclaim_lock_.Acquire();
+  }
+
+  MMAL_BUFFER_HEADER_T* ExtractTail() ASSERT_EXCLUSIVE_LOCK(reclaim_lock_)
+  {
+    reclaim_lock_.AssertAcquired();
+
+    base::AutoLock lock(list_lock_);
+    DeferredBuffer * const dbuf = tail_;
+    if (!dbuf)
+      return nullptr;
+
+    MMAL_BUFFER_HEADER_T *const buffer = dbuf->buffer;
+    DCHECK(buffer != nullptr);
+
+    dbuf->buffer = nullptr;
+    tail_ = dbuf->prev;
+    *(dbuf->prev ? &dbuf->prev->next : &head_) = dbuf->next;
+    dbuf->next = dbuf->prev = nullptr;
+
+    return buffer;
+  }
+
+  void ReclaimFinish() UNLOCK_FUNCTION(reclaim_lock_)
+  {
+    reclaim_ = false;
+    reclaim_lock_.Release();
+  }
+
+  MMAL_BUFFER_HEADER_T * Extract(DeferredBuffer * const dbuf) EXCLUSIVE_TRYLOCK_FUNCTION(true, reclaim_lock_)
+  {
+    if (!reclaim_lock_.Try())
+    {
+      // If we failed to get the reclaim lock assume that our buffer
+      // will be eaten by the reclaim process if it hasn't been already
+      return nullptr;
+    }
+
+    MMAL_BUFFER_HEADER_T * const buffer = dbuf->buffer;
+
+    if (!buffer) {
+      // Buffer already grabbed by reclaim
+      // Release lock & return null
+      reclaim_lock_.Release();
+      return nullptr;
+    }
+
+    base::AutoLock lock(list_lock_);
+    dbuf->buffer = nullptr;
+    *(dbuf->next ? &dbuf->next->prev : &tail_) = dbuf->prev;
+    *(dbuf->prev ? &dbuf->prev->next : &head_) = dbuf->next;
+    dbuf->next = dbuf->prev = nullptr;
+    // has_lock means we will drop the lock when the calling DBuffer is
+    // deleted
+    dbuf->has_lock = true;
+
+    return buffer;
+  }
+
+  // Only called from DeferredBuffer destructor so cleanup of
+  // dbuf vars is ignored
+  void ExtractDone() UNLOCK_FUNCTION(reclaim_lock_)
+  {
+    reclaim_lock_.Release();
+  }
+
+public:
+  DeferredList()
+  {
+  }
+
+  std::unique_ptr<DeferredBuffer> AddBuffer(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (!buffer) {
+      LOG(ERROR) << "Unexpected NULL deferred buffer";
+      return std::unique_ptr<DeferredBuffer>();
+    }
+
+    base::AutoLock lock(list_lock_);
+
+    if (reclaim_)
+      return std::unique_ptr<DeferredBuffer>();
+
+    std::unique_ptr<DeferredBuffer> dbuf(new DeferredBuffer(this, buffer));
+
+    if (head_) {
+      head_->prev = dbuf.get();
+      dbuf->next = head_;
+    }
+    else {
+      tail_ = dbuf.get();
+    }
+    head_ = dbuf.get();
+
+    return dbuf;
+  }
+};
+
+class DeferredReclaim
+{
+  scoped_refptr<DeferredList> list_;
+public:
+  DeferredReclaim(const scoped_refptr<DeferredList>& dlist) :
+    list_(dlist)
+  {
+    list_->ReclaimStart();
+  }
+  ~DeferredReclaim()
+  {
+    list_->ReclaimFinish();
+  }
+  MMAL_BUFFER_HEADER_T * Extract()
+  {
+    return list_->ExtractTail();
+  }
+};
+
+DeferredBuffer::~DeferredBuffer()
+{
+  if (buffer) {
+    MMAL_BUFFER_HEADER_T * const buf = list_->Extract(this);
+    if (buf) {
+      // Shouldn't happen - if it does then winge and do our best
+      LOG(ERROR) << __func__ << ": Buffer still valid";
+      mmal_buffer_header_release(buf);
+    }
+  }
+  if (has_lock)
+    list_->ExtractDone();
+}
+
+MMAL_BUFFER_HEADER_T *
+DeferredBuffer::ExtractAndLock()
+{
+  // has_lock get set as part of Extract
+  return list_->Extract(this);
+}
+
+
+class ESBufferHolder {
+  scoped_refptr<DecoderBuffer> buffer_;
+  VideoDecoder::DecodeCB decode_cb_;
+  const bool not_pkt_ = false;
+  uint32_t offset_ = 0;
+
+  ESBufferHolder(const scoped_refptr<DecoderBuffer>& buffer, VideoDecoder::DecodeCB decode_cb, const bool not_pkt) :
+    buffer_(buffer),
+    decode_cb_(std::move(decode_cb)),
+    not_pkt_(not_pkt)
+  {
+  }
+
+public:
+  static std::unique_ptr<ESBufferHolder>
+  Create(const scoped_refptr<DecoderBuffer>& buffer, VideoDecoder::DecodeCB decode_cb)
+  {
+    return std::unique_ptr<ESBufferHolder>(new ESBufferHolder(buffer, std::move(decode_cb), false));
+  }
+
+  static std::unique_ptr<ESBufferHolder>
+  Create(const scoped_refptr<DecoderBuffer>& buffer)
+  {
+    return std::unique_ptr<ESBufferHolder>(new ESBufferHolder(buffer, VideoDecoder::DecodeCB(), false));
+  }
+
+  static std::unique_ptr<ESBufferHolder>
+  CreateExtra(const scoped_refptr<DecoderBuffer>& buffer)
+  {
+    return std::unique_ptr<ESBufferHolder>(new ESBufferHolder(buffer, VideoDecoder::DecodeCB(), true));
+  }
+
+  ~ESBufferHolder() = default;
+
+  bool is_eos() const
+  {
+    return buffer_->end_of_stream();
+  }
+
+  bool is_start() const
+  {
+    return offset_ == 0;
+  }
+
+  bool is_done() const
+  {
+    return !buffer_;
+  }
+
+  bool is_not_pkt() const
+  {
+    return not_pkt_;
+  }
+
+  const uint8_t * data() const
+  {
+    return buffer_->data() + offset_;
+  }
+
+  uint32_t length(uint32_t max_length) const
+  {
+    return std::min(buffer_->data_size() - offset_, max_length);
+  }
+
+  VideoDecoder::DecodeCB take_callback()
+  {
+    return std::move(decode_cb_);
+  }
+
+  void Consume()
+  {
+    buffer_.reset();
+  }
+
+  void Consume(const uint32_t size)
+  {
+    if ((offset_ += size) >= buffer_->data_size()) {
+      buffer_.reset();
+    }
+  }
+
+  base::TimeDelta pts() const
+  {
+    return buffer_->timestamp();
+  }
+
+};
+
+//-----------------------------------------------------------------------------
+
+// Trampoline class
+// This allows us to attach callbacks from VideoFrames to our
+// component / port without it locking down the component.
+// If the component is dead by the time the callback arrives then it is simply
+// dropped on the floor
+//
+// * Extended well past original intention - rather more than just
+//   a trampoline now... Should be renamed
+
+// A number of functions in this class (in particular "kill") look like they
+// might cause suicide which would be bad as the AutoLock would be removed
+// after it was destroyed. This is prevented by the fact that this class should
+// only be accessed though scoped_refptrs so the calling fn should have a ref
+// on us for at least the duration of the call.
+
+class MmalTrampoline : public base::RefCountedThreadSafe<MmalTrampoline>
+{
+  typedef base::RepeatingCallback<void(const int)> MmalCopiedFramedDestructionCB;
+#if TRACE_TRAMPOLINE
+  // These two are only used for debug
+  static int seq_count_; // Seq number counter
+  const int seq_;  // Debugging sequence number
+#endif
+  // We need this for VCSM GPU stuff but there is little harm
+  // in general
+  const scoped_refptr<MmalVcInit> vc_init_;
+
+  base::Lock lock_;
+  int in_flight_;
+  bool low_traced_;
+  const int max_in_flight_;
+  MmalCopiedFramedDestructionCB destruction_cb_;
+  FrameStash frame_stash_;
+
+  friend base::RefCountedThreadSafe<MmalTrampoline>;
+  virtual ~MmalTrampoline()
+  {
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "@@@ " << __func__ << "[" << seq_ << "]";
+#endif
+  }
+public:
+  MmalTrampoline(
+      const scoped_refptr<MmalVcInit>& vc_init,
+      GpuVideoAcceleratorFactories* const gpu_factories,
+      const uint32_t buffer_size, const gfx::Size& frame_size,
+      const FrameCopyMode& copy_mode,
+      const gfx::ColorSpace& color_space,
+      const int max_in_flight,
+      const MmalCopiedFramedDestructionCB& destruction_cb) :
+#if TRACE_TRAMPOLINE
+    seq_(++seq_count_),
+#endif
+    vc_init_(vc_init),
+    in_flight_(0),
+    low_traced_(true),
+    max_in_flight_(max_in_flight),
+    destruction_cb_(destruction_cb),
+    frame_stash_(gpu_factories, buffer_size, frame_size, copy_mode, color_space)
+  {
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "@@@ " <<  __func__ << "[" << seq_ << "]";
+#endif
+  }
+
+  void kill()
+  {
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "--- "  << "[" << seq_ << "] Trampoline::kill";
+#endif
+    base::AutoLock lock(lock_);
+    destruction_cb_.Reset();
+    frame_stash_.free_all_frames();
+  }
+
+  void free_frame(FrameDesc * const frame, const int buffer_count)
+  {
+    lock_.Acquire();
+
+    // Some callbacks can call us back
+    // We don't have recursive locks - so copy the callback for later use
+    // outside the lock
+    const MmalCopiedFramedDestructionCB cb = destruction_cb_;
+
+    frame_stash_.free_frame(frame);
+
+    // in_flight_ can exceed max_in_flight_ by the number of frames
+    // that can fit in the mmal port.  Avoid stuffing more than we have had returned.
+    const int stuff_count = std::min(in_flight_ - max_in_flight_, buffer_count);
+
+    if ((in_flight_ -= buffer_count) < 0)
+      LOG(FATAL) << "Buffers in flight underflow";
+
+#if TRACE_TRAMPOLINE
+    LOG(ERROR)  << "[" << seq_ << "] killed=" << destruction_cb_.is_null() << ", in_flight:" << in_flight_ << "/" << max_in_flight_ <<
+      ", BCount=" << buffer_count <<
+      ", Stuff=" << stuff_count;
+#endif
+    // Some hysteresis on in_flight logging - do not log if killed
+    if (in_flight_ < max_in_flight_ / 2 && !low_traced_ && !cb.is_null()) {
+      low_traced_ = true;
+      LOG(INFO) << "--- In flight low: " << in_flight_ << "/" << max_in_flight_;
+    }
+    else if (in_flight_ >= max_in_flight_ - 1 && low_traced_) {
+      low_traced_ = false;
+      LOG(INFO) << "--- In flight OK: " << in_flight_ << "/" << max_in_flight_;
+    }
+
+    lock_.Release();
+
+    if (stuff_count > 0 && !cb.is_null())
+      cb.Run(std::min(buffer_count, stuff_count));
+  }
+
+  const FrameCopyMode& copy_mode() const
+  {
+    return frame_stash_.copy_mode();
+  }
+
+  // *** ?? Can size or format ever change in the lifetime of a trampoline ??
+  FrameDesc * alloc_frame()
+  {
+    base::AutoLock lock(lock_);
+    return frame_stash_.alloc_frame();
+  }
+
+  bool recycle_buffer_in_flight(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    lock_.Acquire();
+    const bool wants_recycle = (++in_flight_ <= max_in_flight_);
+    lock_.Release();
+
+    if (wants_recycle)
+    {
+#if TRACE_TRAMPOLINE
+      LOG(ERROR) << "[" << seq_ << "] recycle: in flight=" << in_flight_;
+#endif
+      return true;
+    }
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "[" << seq_ << "] release, in_flight=" << in_flight_;
+#endif
+
+    // Was Deadlock opportunity
+    // ?? pool starvation opportunity now
+
+    buffer_release(buffer);
+    return false;
+  }
+
+  bool is_stalling() const
+  {
+    return in_flight_ >= max_in_flight_;
+  }
+
+  // GPU frame only callbacks
+  // Replace the kill_id_ & id_ processing for GPU frames
+
+  void MailboxHoldersWaited(FrameDescGPU * const frame_desc)
+  {
+#if TRACE_DESC
+    LOG(INFO) << __func__ << ": " << (void*)frame_desc;
+#endif
+    free_frame(frame_desc, 1);
+  }
+
+public:
+  void MailboxHoldersReleased(FrameDescGPU * const frame_desc, const gpu::SyncToken& release_sync_token)
+  {
+#if TRACE_DESC
+    LOG(INFO) << __func__ << ": " << (void*)frame_desc;
+#endif
+
+    // TODO(sandersd): Remove once https://crbug.com/819914 is fixed. Correct
+    // clients must wait for READ_LOCK_FENCES_ENABLED frames to be read before
+    // returning the frame, so waiting on the sync token should be a no-op.
+    //
+    // If the context is lost, SignalSyncToken() drops its callbacks. Using a
+    // ScopedClosureRunner ensures MailboxHoldersWaited() is called if that
+    // happens.
+
+//    frame_desc->MailboxHoldersReleased(release_sync_token,
+//                                       std::make_unique<base::ScopedClosureRunner>(base::BindOnce(
+//                                           &::media::MmalTrampoline::MailboxHoldersWaited, this,
+//                                           frame_desc)));
+    frame_desc->RunInGPUThreadOnce(base::BindOnce(
+                                           &::media::MmalTrampoline::MailboxHoldersWaited, this,
+                                           frame_desc));
+  }
+
+};
+
+#if TRACE_TRAMPOLINE
+int MmalTrampoline::seq_count_ = 0;
+#endif
+
+//--------------------------------------------- --------------------------------
+
+
+static base::Optional<VideoFrameLayout> MakeLayout(const FrameCopyMode& copy_mode, const FrameDesc * const frame)
+{
+  const unsigned int buf_n = frame->buffer_count();
+  const unsigned int plane_n = copy_mode.planes();
+
+  std::vector<ColorPlaneLayout> planes;
+
+  size_t offset = 0;
+  for (unsigned int i = 0; i != plane_n; ++i) {
+    size_t stride = frame->stride(i);
+    if (stride == 0)
+      stride = copy_mode.width_to_stride(i, frame->frame_size().width());
+
+    const size_t size = stride * copy_mode.height_to_lines(i, frame->frame_size().height());
+
+    planes.emplace_back(stride, offset, size);
+    // Whilst we have backing buffers assume that planes match them 1:1
+    if (i + 1 >= buf_n)
+      offset += size;
+  }
+
+  if (buf_n == 1) {
+    return VideoFrameLayout::CreateWithPlanes(copy_mode.pixel_format(),
+                                              frame->frame_size(), planes); // **** Modifiers *****????
+  }
+  return VideoFrameLayout::CreateMultiPlanar(copy_mode.pixel_format(),
+                                            frame->frame_size(), planes); // **** Modifiers *****????
+}
+
+class MmalVideoFrame : public VideoFrame
+{
+protected:
+  const scoped_refptr<MmalTrampoline> trampoline_;
+  FrameDesc * const frame_desc_;
+  gpu::Mailbox id_;
+
+  ~MmalVideoFrame() override {
+#if TRACE_DESC
+    LOG(INFO) << "@@@ " << __func__ << ": " << (void*)this;
+#endif
+  }
+
+private:
+  void set_frame_data()
+  {
+    if (IsMappable()) {
+      unsigned int buf_no = 0;
+      for (size_t i = 0; i != layout().num_planes(); ++i) {
+        const size_t offset = layout().planes()[i].offset;
+        if (offset == 0 && i != 0)
+          ++buf_no;
+
+//        LOG(INFO) << "[" << i << "/" << buf_no << "] offset=" << offset;
+        set_data(i, frame_desc_->frame(buf_no) + offset);
+      }
+    }
+  }
+
+public:
+  MmalVideoFrame(
+      FrameDesc * const frame_desc,
+      const scoped_refptr<MmalTrampoline>& trampoline,
+      const gfx::Rect& visible_rect,
+      const gfx::Size& natural_size,
+      const base::TimeDelta timestamp) :
+    VideoFrame(
+      MakeLayout(trampoline->copy_mode(), frame_desc).value(),
+      trampoline->copy_mode().frame_storage_type(),
+      visible_rect, natural_size, timestamp),
+    trampoline_(trampoline),
+    frame_desc_(frame_desc),
+    id_(frame_desc->get_id())
+  {
+#if TRACE_DESC
+    LOG(INFO) << "@@@ " << __func__ << ": " << (void*)this << ": " << visible_rect.ToString();
+#endif
+    set_frame_data();
+  }
+
+  static scoped_refptr<MmalVideoFrame> Coerce(const scoped_refptr<VideoFrame>& frame)
+  {
+    if (frame->format() != PIXEL_FORMAT_MMAL_BUFFER) {
+      NOTREACHED();
+      return scoped_refptr<MmalVideoFrame>();
+    }
+    return scoped_refptr<MmalVideoFrame>(static_cast<MmalVideoFrame *>(frame.get()));
+  }
+
+  uint32_t hashid() const
+  {
+    return media::hashid(id_);
+  }
+
+  const base::ReadOnlySharedMemoryRegion * ro_shm_region() const override {
+    return frame_desc_->shared_memory();
+  }
+
+  const gpu::Mailbox& GetBitmapId() const override {
+    return id_;
+  }
+
+  void copy_buffer(const MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    for (size_t i = 0; i != layout().num_planes(); ++i) {
+      mem_copy_2d(data(i), layout().planes()[i].stride,
+                  buffer->data + buffer->type->video.offset[i], buffer->type->video.pitch[i],
+                  rows(i), row_bytes(i));
+    }
+  }
+};
+
+//-----------------------------------------------------------------------------
+
+class MmalShmVideoFrame : public media::MmalVideoFrame
+{
+  base::OnceClosure kill_id_;
+  int buffer_count_ = 0;
+
+  ~MmalShmVideoFrame() override
+  {
+    frame_desc_->set_id_and_kill_cb(id_, std::move(kill_id_));
+    trampoline_->free_frame(frame_desc_, buffer_count_);
+  }
+
+  using MmalVideoFrame::MmalVideoFrame;  // Args & init all the same as for base
+
+public:
+  static scoped_refptr<MmalShmVideoFrame> Create(
+      FrameDesc * const frame_desc,
+      const scoped_refptr<MmalTrampoline>& trampoline,
+      const gfx::Rect& visible_rect,
+      const gfx::Size& natural_size,
+      const base::TimeDelta timestamp = kNoTimestamp)
+  {
+    return new MmalShmVideoFrame(frame_desc, trampoline, visible_rect, natural_size, timestamp);
+  }
+
+  void inc_buffer_count()
+  {
+    ++buffer_count_;
+  }
+
+  bool SetBitmapIdAndKillCB(const gpu::Mailbox& id, base::OnceClosure kill) override {
+    kill_id_ = std::move(kill);
+    id_ = id;
+    return true;
+  }
+};
+
+// ----------------------------------------------------------------------------
+
+class MmalGPUVideoFrame : public media::MmalVideoFrame
+{
+  ~MmalGPUVideoFrame() override {}
+
+  // Create a VideoFrame and move the frame stash into it from
+  // the mmal buffer
+  MmalGPUVideoFrame(FrameDesc * const frame_desc,
+      const scoped_refptr<MmalTrampoline>& trampoline,
+      const gfx::Rect& visible_rect,
+      const gfx::Size& natural_size,
+      const base::TimeDelta timestamp) :
+      MmalVideoFrame(
+        frame_desc, trampoline,
+        visible_rect, natural_size, timestamp)
+  {
+#if TRACE_DESC
+    LOG(INFO) << __func__ << ": HasTextures: " << HasTextures() << ", this=" << (void*)this << ", desc=" << (void*)frame_desc_;
+#endif
+
+    metadata().allow_overlay = true;
+//    metadata().copy_mode = VideoFrameMetadata::CopyMode::kCopyMailboxesOnly;
+    metadata().read_lock_fences_enabled = true;
+  }
+
+public:
+  static scoped_refptr<MmalGPUVideoFrame> Create(FrameDesc * const frame_desc,
+      const scoped_refptr<MmalTrampoline>& trampoline,
+      const gfx::Rect& visible_rect,
+      const gfx::Size& natural_size,
+      const base::TimeDelta timestamp = kNoTimestamp)
+  {
+    return new MmalGPUVideoFrame(frame_desc, trampoline, visible_rect, natural_size, timestamp);
+  }
+
+  // Must be run in GPU thread
+  void BindAndEmit(const VideoDecoder::OutputCB& emit_cb)
+  {
+    FrameDescGPU * const gpu_desc_ = frame_desc_->as_gpu();
+
+    {
+      gpu::MailboxHolder mbh[3];
+      const int n = gpu_desc_->SetSyncImage(mbh);
+
+      if (n <= 0) {
+        LOG(WARNING) << __func__ << ": SetSyncImage failed";
+        trampoline_->free_frame(gpu_desc_, 1);
+        return;
+      }
+
+      for (int i = 0; i < n; ++i) {
+        set_mailbox_holder(i, mbh[i]);
+      }
+    }
+
+    SetReleaseMailboxCB(
+        base::BindOnce(&MmalTrampoline::MailboxHoldersReleased, trampoline_, base::Unretained(gpu_desc_)));
+
+    emit_cb.Run(this);
+  }
+};
+
+// ----------------------------------------------------------------------------
+
+
+// Pool base class - can be instantiated
+class MmalPool
+{
+  const scoped_refptr<MmalVcInit> vc_init_;
+
+public:
+  typedef base::RepeatingCallback<bool(MMAL_BUFFER_HEADER_T * buffer)> MmalPoolBufferReleaseCB;
+  typedef base::RepeatingCallback<void(MMAL_BUFFER_HEADER_T * buffer)> MmalPoolBufferGetCB;
+
+private:
+  MmalPoolBufferReleaseCB pool_cb_;
+  MmalPoolBufferGetCB get_cb_;
+
+protected:
+  virtual bool do_pool_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    return pool_cb_.Run(buffer);
+  }
+
+private:
+  static MMAL_BOOL_T static_pool_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata)
+  {
+    return ((MmalPool *)userdata)->do_pool_cb(buffer);
+  }
+
+protected:
+  MMAL_POOL_T * pool_;
+
+  MmalPool(const scoped_refptr<MmalVcInit>& vc_init) :
+    vc_init_(vc_init),
+    pool_(nullptr)
+  {
+  }
+
+  // Must be called as part of create if you ever want callbacks to work
+  void set_static_pool_cb()
+  {
+    mmal_pool_callback_set(pool_, static_pool_cb, this);
+  }
+
+public:
+  // N.B. Overriding classes are responsible for freeing pool_ correctly
+  virtual ~MmalPool()
+  {
+  }
+
+  virtual const char * pool_type_name() const
+  {
+    return "PoolBase";
+  }
+
+  virtual MMAL_BUFFER_HEADER_T * get_timeout(const uint32_t timeout_ms)
+  {
+    MMAL_BUFFER_HEADER_T * const buf = mmal_queue_timedwait(pool_->queue, timeout_ms);
+    if (buf)
+      get_cb_.Run(buf);
+    return buf;
+  }
+
+  virtual MMAL_BUFFER_HEADER_T * get()
+  {
+    MMAL_BUFFER_HEADER_T * buf = mmal_queue_get(pool_->queue);
+    if (buf)
+      get_cb_.Run(buf);
+    return buf;
+  }
+
+  virtual void put(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    mmal_queue_put(pool_->queue, buffer);
+  }
+
+  // Do the equivalent of put then get
+  // Will refresh buffer->data if required
+  virtual MMAL_BUFFER_HEADER_T * put_get(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    return buffer;
+  }
+
+  uint32_t length() const
+  {
+    return mmal_queue_length(pool_->queue);
+  }
+
+  // Pool size (not data size)
+  uint32_t size() const
+  {
+    return pool_->headers_num;
+  }
+
+  // Thing we are servicing may have changed shape
+  // By default ignore
+  virtual int port_resized(const uint32_t num, const uint32_t buf_size, const gfx::Size& frame_size)
+  {
+    return 0;
+  }
+
+  virtual int create(const uint32_t num, const uint32_t buf_size, const gfx::Size& frame_size) = 0;
+
+  // Enable/disable aren't required fns but add helpful hints
+  // to some derived classes
+  // * Could be used to debug unexpected pool movement
+  virtual int disable()
+  {
+    get_cb_.Reset();
+    pool_cb_.Reset();
+    return 0;
+  }
+
+  virtual int enable(const MmalPoolBufferGetCB& gcb, const MmalPoolBufferReleaseCB& rcb)
+  {
+    pool_cb_ = rcb;
+    get_cb_ = gcb;
+    return 0;
+  }
+
+  // This isn't exactly part of a base pool implementation
+  // but it saves a spurious extra layer
+  virtual void set_trampoline(const scoped_refptr<MmalTrampoline>& trampoline)
+  {
+  }
+};
+
+//-----------------------------------------------------------------------------
+//
+// Pool attached to a port
+class MmalPortPool : public MmalPool
+{
+  MMAL_PORT_T * const port_;
+public:
+  MmalPortPool(const scoped_refptr<MmalVcInit>& vc_init, MMAL_PORT_T * const port) :
+    MmalPool(vc_init),
+    port_(port)
+  {
+  }
+
+  ~MmalPortPool() override
+  {
+    if (pool_) {
+      mmal_port_pool_destroy(port_, pool_);
+    }
+  }
+
+  const char * pool_type_name() const override
+  {
+    return "PoolPort";
+  }
+
+  int create(const uint32_t num, const uint32_t buf_size, const gfx::Size& frame_size) override
+  {
+    if (!(pool_ = mmal_port_pool_create(port_, num, buf_size)))
+    {
+      LOG(ERROR) << "### mmal_port_pool_create failed: " << num << "*" << buf_size;
+      return -1;
+    }
+    set_static_pool_cb();
+    return 0;
+  }
+};
+
+//-----------------------------------------------------------------------------
+//
+// Pool not attached to a port
+
+class MmalUserPool : public MmalPool
+{
+public:
+  MmalUserPool(const scoped_refptr<MmalVcInit>& vc_init) :
+    MmalPool(vc_init)
+  {
+  }
+
+  ~MmalUserPool() override
+  {
+    if (pool_) {
+      mmal_pool_destroy(pool_);
+    }
+  }
+
+  const char * pool_type_name() const override
+  {
+    return "PoolUser";
+  }
+
+  int create(const uint32_t num, const uint32_t buf_size, const gfx::Size& frame_size) override
+  {
+    if (!(pool_ = mmal_pool_create(num, buf_size)))
+    {
+      LOG(ERROR) << "### mmal_pool_create failed: " << num << "*" << buf_size;
+      return -1;
+    }
+    set_static_pool_cb();
+    return 0;
+  }
+};
+
+//-----------------------------------------------------------------------------
+//
+// Pool that has detachable frame buffers allocated by our trampoline
+// Buffers in the pool have no frame buffers attached
+// Buffers are attached on get and detached on release
+// * For a more generic version we could have callback alloc/free fns
+class MmalFramePool : public MmalUserPool
+{
+protected:
+  scoped_refptr<MmalTrampoline> trampoline_;
+  size_t buffer_size_ = 0;
+  gfx::Size frame_size_;
+  const FrameCopyMode copy_mode_;
+
+  virtual MMAL_BUFFER_HEADER_T * attach_data_buffer(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    // Ignore null
+    if (buffer != nullptr) {
+      if (buffer->data != nullptr) {
+        LOG(FATAL) << "Buffer already in use";
+      }
+
+      FrameDesc * frame;
+      if ((frame = trampoline_->alloc_frame()) == nullptr)
+      {
+        LOG(ERROR) << "### " << __func__ << ": alloc frame failed";
+        // If we cannot alloc then release buffer back to pool as we are about
+        // to lose track of it
+        buffer_release(buffer);
+        return nullptr;
+      }
+      buffer->user_data = frame;
+      buffer->data = frame->frame();
+      buffer->alloc_size = frame->size();
+    }
+    return buffer;
+  }
+
+  MMAL_BUFFER_HEADER_T * detach_data_buffer(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer != nullptr && buffer->data != nullptr) {
+      // This is called on buffer release so should have no "in-flight" component
+      trampoline_->free_frame((FrameDesc *)buffer->user_data, 0);
+      buffer->user_data = nullptr;
+      buffer->data = nullptr;
+      buffer->alloc_size = 0;
+    }
+    return buffer;  // For convienience
+  }
+
+  bool do_pool_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    return MmalUserPool::do_pool_cb(detach_data_buffer(buffer));
+  }
+
+public:
+  MmalFramePool(const scoped_refptr<MmalVcInit>& vc_init, FrameCopyMode copy_mode) :
+    MmalUserPool(vc_init),
+    copy_mode_(copy_mode)
+  {
+  }
+
+  const char * pool_type_name() const override
+  {
+    return "PoolFrame";
+  }
+
+  int create(const uint32_t num, const uint32_t buf_size, const gfx::Size& frame_size) override
+  {
+    if (MmalUserPool::create(num, 0, frame_size) != 0) {
+      return -1;
+    }
+
+    buffer_size_ = buf_size;
+    frame_size_ = frame_size;
+    return 0;
+  }
+
+  MMAL_BUFFER_HEADER_T * get_timeout(const uint32_t timeout_ms) override
+  {
+    return attach_data_buffer(MmalUserPool::get_timeout(timeout_ms));
+  }
+
+  MMAL_BUFFER_HEADER_T * get() override
+  {
+    return attach_data_buffer(MmalUserPool::get());
+  }
+
+  void put(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    MmalUserPool::put(detach_data_buffer(buffer));
+  }
+
+  // This is effectively a realloc to the current size and will
+  // attach a buffer if none was attached before
+  // Useful when recycling a buffer directly back into a port
+  MMAL_BUFFER_HEADER_T * put_get(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    if (buffer->alloc_size == buffer_size_)
+      return buffer;
+
+//    LOG(INFO) << "### Realloc buffer size: " << buffer->alloc_size << "->" << buffer_size_;
+    return attach_data_buffer(detach_data_buffer(buffer));
+  }
+
+  int disable() override
+  {
+    // Avoid keeping an otherwise unused trampoline alive longer than needed
+    trampoline_.reset();
+    return MmalUserPool::disable();
+  }
+
+  int port_resized(const uint32_t num, const uint32_t buf_size, const gfx::Size& frame_size) override
+  {
+    // Remember for future allocation and that is all we want to do
+    buffer_size_ = buf_size;
+    frame_size_ = frame_size;
+    return 0;
+  }
+
+  // As this has no locking this should only be called when disabled
+  // (in most cases this means that the port we are servicing is disabled)
+  void set_trampoline(const scoped_refptr<MmalTrampoline>& trampoline) override
+  {
+    trampoline_ = trampoline;
+  }
+};
+
+class MmalFramePoolZc : public MmalFramePool
+{
+protected:
+  MMAL_BUFFER_HEADER_T * attach_data_buffer(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    // Ignore null
+    if (buffer != nullptr) {
+      if (buffer->data != nullptr) {
+        LOG(FATAL) << "Buffer already in use";
+      }
+
+      FrameDesc * frame;
+      if ((frame = trampoline_->alloc_frame()) == nullptr)
+      {
+        LOG(ERROR) << "### " << __func__ << ": alloc frame failed";
+        // If we cannot alloc then release buffer back to pool as we are about
+        // to lose track of it
+        buffer_release(buffer);
+        return nullptr;
+      }
+      buffer->user_data = frame;
+      buffer->data = (uint8_t *)(void *)frame->vc_handle();
+      buffer->alloc_size = frame->size();
+
+      if (buffer->data == nullptr) {
+        LOG(ERROR) << "Frame has no VCSM handle";
+        buffer_release(buffer);
+        return nullptr;
+      }
+    }
+    return buffer;
+  }
+
+public:
+  using MmalFramePool::MmalFramePool;
+
+  const char * pool_type_name() const override
+  {
+    return "PoolFrameZc";
+  }
+};
+
+//=============================================================================
+//
+// Wrapper for an mmal port
+
+class MmalPort
+{
+  // Actually connection should be a subclass?
+  friend class MmalConnection;
+
+protected:
+  const scoped_refptr<MmalVcInit> vc_init_;
+
+  MMAL_PORT_T * port_;
+  bool killing_;
+
+public:
+  virtual void event_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    LOG(ERROR) << "### Unexpected ES data";
+    mmal_buffer_header_release(buffer);
+  }
+
+  virtual void cmd_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer->cmd == MMAL_EVENT_ERROR) {
+      LOG(WARNING) << "### Mmal reports error " << *(uint32_t *)buffer->data;
+    } else if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED) {
+      mmal_log_dump_port(port_);
+      const MMAL_EVENT_FORMAT_CHANGED_T *const fc = mmal_event_format_changed_get(buffer);
+      LOG(INFO) << "Mmal format changed: size_min:" << fc->buffer_size_min <<
+        ", num_min:" << fc->buffer_num_min <<
+          ", size_rec:" << fc->buffer_size_recommended <<
+          ", num_rec:" << fc->buffer_num_recommended;
+      if (fc->format != nullptr) {
+        mmal_log_dump_format(fc->format);
+      }
+    } else {
+        char s[20];
+        LOG(WARNING) << "### Mmal unexpected command: " << mmal_4cc_to_string(s, sizeof(s), buffer->cmd);
+    }
+
+    // Commands are allocated from a different pool to ES data
+    // return to sender...
+    mmal_buffer_header_release(buffer);
+  }
+
+private:
+  void callback_common(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer->cmd != 0) {
+      // Cmd buffers are not allocated from the main pool
+      cmd_cb(buffer);
+    }
+    else
+    {
+      if (killing_) {
+        // If flushing always release the buffer
+        mmal_buffer_header_release(buffer);
+      }
+      else {
+        event_cb(buffer);
+      }
+    }
+  }
+
+  static void callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+  {
+    MmalPort *p = static_cast<MmalPort*>((void*)port->userdata);
+
+    if (p == nullptr) {
+      LOG(ERROR) << __func__ << "### Port NULL";
+    }
+    else
+    {
+      p->callback_common(buffer);
+    }
+  }
+
+public:
+  virtual int enable()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if (killing_) {
+      LOG(ERROR) << "### port enable when killed";
+      return -1;
+    }
+
+    if ((err = mmal_port_enable(port_, callback)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_enable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  virtual int disable()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if (port_ && port_->is_enabled) {
+      err = mmal_port_disable(port_);
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  bool is_enabled() const
+  {
+    return port_ != nullptr && port_->is_enabled;
+  }
+
+  virtual int commit()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if ((err = mmal_port_format_commit(port_)) != MMAL_SUCCESS)
+    {
+      LOG(ERROR) << "### mmal_port_format_commit failed: err=" << err;
+      mmal_log_dump_port(port_);
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  // (stride_in_pixels , (padded_)height)
+  gfx::Size frame_size() const
+  {
+    // * Could have a Video sub-class and lose this test
+    return port_->format->type != MMAL_ES_TYPE_VIDEO ? gfx::Size() :
+        gfx::Size(port_->format->es->video.width, port_->format->es->video.height);
+  }
+
+  uint32_t buffer_size() const
+  {
+    return port_->buffer_size;
+  }
+
+  uint32_t buffer_num() const
+  {
+    return port_->buffer_num;
+  }
+
+  // This set of fns are overridden by MmalConnectedPort
+  // to provide max of connected ports
+  virtual uint32_t buffer_size_recommended() const
+  {
+    return port_->buffer_size_recommended;
+  }
+
+  virtual uint32_t buffer_size_min() const
+  {
+    return port_->buffer_size_recommended;
+  }
+
+  virtual uint32_t buffer_num_recommended() const
+  {
+    return port_->buffer_num_recommended;
+  }
+
+  virtual uint32_t buffer_num_min() const
+  {
+    return port_->buffer_num_min;
+  }
+
+  virtual int set_buffers(const uint32_t size, const uint32_t num)
+  {
+    port_->buffer_num = num;
+    port_->buffer_size = size;
+    return 0;
+  }
+
+  int set_buffers_recommended()
+  {
+    return set_buffers(buffer_size_recommended(), buffer_num_recommended());
+  }
+
+  int set_parameter(const uint32_t param, const uint32_t val) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_set_uint32(port_, param, val)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_set_uint32 failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  inline int set_parameter(const uint32_t param, const int val) const
+  {
+    return set_parameter(param, (uint32_t)(val));
+  }
+
+  int set_parameter(const uint32_t param, const bool val) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_set_boolean(port_, param, val ? MMAL_TRUE : MMAL_FALSE)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_set_boolean failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int get_parameter(MMAL_PARAMETER_HEADER_T * const param) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_get(port_, param)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_get failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  // class for storing the supported encodings parameter info
+  class SupportedEncodings
+  {
+    static const int max_encodings_ = 64;
+    struct {
+       MMAL_PARAMETER_HEADER_T header_;
+       MMAL_FOURCC_T encodings_[max_encodings_];
+    } supported_;
+    int n_;
+
+  public:
+    typedef const MMAL_FOURCC_T * iterator;
+
+    SupportedEncodings(const MmalPort& port) :
+      supported_({{MMAL_PARAMETER_SUPPORTED_ENCODINGS, sizeof(supported_)}, {0}}),
+      n_(-1)
+    {
+      if (port.get_parameter(&supported_.header_) == 0)
+      {
+        n_ = (supported_.header_.size - sizeof(supported_.header_)) /
+          sizeof(supported_.encodings_[0]);
+      }
+    }
+
+    virtual ~SupportedEncodings()
+    {
+    }
+
+    // Default copy is OK
+
+    iterator begin() const
+    {
+      return supported_.encodings_;
+    }
+
+    iterator end() const
+    {
+      return supported_.encodings_ + n_;
+    }
+
+    bool is_supported(const MMAL_FOURCC_T x) const
+    {
+      // If we end up doing this a lot for any reason then use a better lookup
+      for (auto &enc : *this) {
+        if (x == enc) {
+          return true;
+        }
+      }
+      return false;
+    }
+
+    std::string ToString() const
+    {
+      std::ostringstream s;
+      for (int i = 0; i < n_; ++i) {
+        char buf[8];
+        if (i != 0)
+          s << ",";
+        s << mmal_4cc_to_string(buf, sizeof(buf), supported_.encodings_[i]);
+      }
+      return s.str();
+    }
+  };
+
+  SupportedEncodings get_parameter_supported_encodings() const
+  {
+    return SupportedEncodings(*this);
+  }
+
+  int set_video_encoding(
+    const MMAL_FOURCC_T encoding,
+    const MMAL_FOURCC_T encoding_variant = MMAL_ENCODING_VARIANT_DEFAULT,
+    const uint32_t flags = 0)
+  {
+    MMAL_ES_FORMAT_T *const format = port_->format;
+
+    format->type = MMAL_ES_TYPE_VIDEO;
+    format->encoding = encoding;
+    format->encoding_variant = encoding_variant;
+    format->flags = 0;
+    format->bitrate = 0;
+    return 0;
+  }
+
+  // Fill in all of a MMAL_VIDEO_FORMAT_T
+  int set_video_format(
+      const gfx::Size& size,
+      const gfx::Rect& crop,
+      const gfx::Size& par,
+      const MMAL_FOURCC_T mmal_color_space) const
+  {
+    MMAL_ES_FORMAT_T *const format = port_->format;
+    MMAL_VIDEO_FORMAT_T *const video = &format->es->video;
+    const bool isyuv = (format->encoding == MMAL_ENCODING_I420 ||
+                        format->encoding == MMAL_ENCODING_YV12 ||
+                        format->encoding == MMAL_ENCODING_NV12);
+
+    const uint32_t w = size.width();
+    const uint32_t h = size.height();
+
+    video->width = VCOS_ALIGN_UP(w, isyuv ? 32 : 16);
+    video->height = VCOS_ALIGN_UP(h, 16);
+    video->crop.x = crop.x();
+    video->crop.y = crop.y();
+    video->crop.width = crop.width();
+    video->crop.height = crop.height();
+    video->frame_rate.num = 30000;  // Not in config - make something valid up
+    video->frame_rate.den = 1001;
+    video->par.num = par.width();
+    video->par.den = par.height();
+    video->color_space = mmal_color_space;
+    return 0;
+  }
+
+  // Disable once we forget about it
+  virtual ~MmalPort()
+  {
+    disable();
+  }
+
+  MmalPort(const scoped_refptr<MmalVcInit>& vc_init) :
+    vc_init_(vc_init),
+    port_(nullptr),
+    killing_(false)
+  {
+  }
+
+  virtual void set_port(MMAL_PORT_T * const port)
+  {
+    if (port_) {
+      LOG(ERROR) << "### Port not null";
+      return;
+    }
+
+    port->userdata = (struct MMAL_PORT_USERDATA_T *)(void *)this;
+    port_ = port;
+  }
+
+  // Submit a buffer - on failure (or kill) buffer is released
+  int submit(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    MMAL_STATUS_T err;
+
+    if (killing_ || !port_->is_enabled) {
+      mmal_buffer_header_release(buffer);
+      return 0;
+    }
+
+    if ((err = mmal_port_send_buffer(port_, buffer)) != MMAL_SUCCESS)
+    {
+      // Release buffer on error
+      mmal_buffer_header_release(buffer);
+      LOG(ERROR) << "#### mmal_send_buffer (" << buffer << ") failed: err=" << err;
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  virtual void kill()
+  {
+    killing_ = true;
+    disable();
+  }
+
+  void dump_video_format()
+  {
+    const MMAL_ES_FORMAT_T * const format = port_->format;
+    const MMAL_VIDEO_FORMAT_T *const video = &format->es->video;
+    char buf1[10], buf2[10];
+
+    LOG(ERROR) << port_->name << ": Encoding:" << mmal_4cc_to_string(buf1, sizeof(buf1), format->encoding) <<
+    ":" << mmal_4cc_to_string(buf2, sizeof(buf2), format->encoding_variant) <<
+        ", " << video->width << "x" << video->height <<
+        ", crop: " << video->crop.x << "," << video->crop.y <<
+        " " << video->crop.width << "x" << video->crop.height;
+  }
+
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalConnection : public base::RefCountedThreadSafe<MmalConnection>
+{
+  friend MmalConnectedPort;
+
+  const scoped_refptr<MmalVcInit> vc_init_;
+
+  bool enabled_;
+  MMAL_CONNECTION_T * connection_;
+  MmalConnectedPort * src_;
+  MmalConnectedPort * dest_;
+
+  friend base::RefCountedThreadSafe<MmalConnection>;
+  virtual ~MmalConnection()
+  {
+    if (connection_) {
+      mmal_connection_destroy(connection_);
+    }
+  }
+
+  MmalConnection(const scoped_refptr<MmalVcInit>& vc_init) :
+    vc_init_(vc_init),
+    enabled_(false),
+    connection_(nullptr),
+    src_(nullptr),
+    dest_(nullptr)
+  {
+  }
+
+  void disconnect();
+  int connect(MmalConnectedPort * const src, MmalConnectedPort * const dest);
+
+  int enable()
+  {
+    MMAL_STATUS_T err;
+
+    if (enabled_) {
+      // Bad stuff (tm) seems to happen if we multiply en/disable connections
+      return 0;
+    }
+
+    if ((err = mmal_connection_enable(connection_)) != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_connection_enable failed: err=" << err;
+      return -1;
+    }
+
+    enabled_ = true;
+    return 0;
+  }
+
+  int disable()
+  {
+    MMAL_STATUS_T err;
+
+    if (!enabled_) {
+      // Bad stuff (tm) seems to happen if we multiply en/disable connections
+      return 0;
+    }
+
+    // Mark as disabled even if we fail as in this case I have no idea how
+    // to recover and retry is very unlikely to help
+    enabled_ = false;
+
+    if ((err = mmal_connection_disable(connection_)) != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_connection_disable failed: err=" << err;
+      return -1;
+    }
+
+    return 0;
+  }
+
+  uint32_t buffer_size_recommended() const;
+  uint32_t buffer_num_recommended() const;
+  uint32_t buffer_size_min() const;
+  uint32_t buffer_num_min() const;
+  int set_buffers(uint32_t s, uint32_t n);
+};
+
+// ----------------------------------------------------------------------------
+//
+// Port that we are expecting to be attached to another port by an MmalConnection
+
+class MmalConnectedPort : public MmalPort
+{
+  scoped_refptr<MmalConnection> connection_;
+
+public:
+  void set_connection(MmalConnection * connection)
+  {
+    connection_ = connection;
+  }
+
+  int disconnect()
+  {
+    if (connection_) {
+      connection_->disconnect();
+    }
+    return 0;
+  }
+
+  int enable() override
+  {
+    return connection_->enable();
+  }
+
+  int disable() override
+  {
+    return !connection_ ? 0 : connection_->disable();
+  }
+
+  void kill() override
+  {
+    MmalPort::kill();
+    disconnect();
+  }
+
+  int connect_to_src(MmalConnectedPort * const src)
+  {
+    scoped_refptr<MmalConnection> connection(new MmalConnection(vc_init_));
+    return connection->connect(src, this);
+  }
+
+  uint32_t buffer_size_recommended() const override
+  {
+    return connection_->buffer_size_recommended();
+  }
+
+  uint32_t buffer_num_recommended() const override
+  {
+    return connection_->buffer_num_recommended();
+  }
+
+  uint32_t buffer_size_min() const override
+  {
+    return connection_->buffer_size_min();
+  }
+
+  uint32_t buffer_num_min() const override
+  {
+    return connection_->buffer_num_min();
+  }
+
+  int set_buffers(const uint32_t s, const uint32_t n) override
+  {
+    return connection_->set_buffers(s, n);
+  }
+
+  MmalConnectedPort(const scoped_refptr<MmalVcInit>& vc_init) :
+    MmalPort(vc_init)
+  {
+  }
+
+  ~MmalConnectedPort() override
+  {
+    disconnect();
+  }
+};
+
+// ----------------------------------------------------------------------------
+
+class MmalPortAndPool : public MmalPort
+{
+  typedef scoped_refptr<MmalPortAndPool> AutoRef;
+
+  MmalComponent * const component_;
+
+  std::unique_ptr<MmalPool> pool_;
+
+public:
+  // These allow us to use scoped_refptr on this object
+  // They trampoline to the enclosing component
+  void AddRef();
+  void Release();
+  bool HasOneRef() const;
+  bool HasAtLeastOneRef() const;
+
+  const MmalTaskRunner& task_runner() const;
+
+protected:
+  virtual void buffer_event_cb(MMAL_BUFFER_HEADER_T * const buffer) = 0;
+
+private:
+  // * Having this static is a relic? Not actually wanted?
+  static bool pool_rel_cb(scoped_refptr<MmalPortAndPool> mpp, MMAL_BUFFER_HEADER_T *buffer)
+  {
+    // As the release can cause us to commit suicide we must put the buffer
+    // back by hand before calling Release as if we try to do it afterwards
+    // the Q may have vanished and we would crash.
+    mpp->pool_->put(buffer);
+    mpp->Release();
+    return false;  // We did the put back ourselves
+  }
+
+  void pool_get_cb(MMAL_BUFFER_HEADER_T *buffer)
+  {
+    // Add reference immediately after pool retrieval
+    AddRef();
+  }
+
+  // Given that we now have ref counts that can hit zero when all buffers are
+  // returned to the pool ensure that we can't commit untimely suicide by
+  // holding a ref on ourselves until the callback is over.
+  // This could probably be ensured by careful coding of the overriding
+  // callbacks but this removes the possibility of unexpected surprises
+  void event_cb(MMAL_BUFFER_HEADER_T * const buffer) final
+  {
+    AutoRef(this)->buffer_event_cb(buffer);
+  }
+
+protected:
+  int set_pool(MmalPool *const pool, const uint32_t num)
+  {
+    pool_ = std::unique_ptr<MmalPool>(pool);
+    if (pool_->create(num, port_->buffer_size, frame_size()) != 0) {
+      return -1;
+    }
+    return 0;
+  }
+
+  int set_pool(MmalPool *const pool)
+  {
+    if (pool == nullptr) {
+      pool_.reset();
+      return 0;
+    }
+    return set_pool(pool, port_->buffer_num);
+  }
+
+public:
+  void task_run(base::OnceClosure cb)
+  {
+    task_runner()->PostTask(FROM_HERE, std::move(cb));
+  }
+
+  MmalPortAndPool(const scoped_refptr<MmalVcInit>& vc_init, MmalComponent * const component) :
+    MmalPort(vc_init),
+    component_(component)
+  {
+//    LOG(ERROR) << __func__;
+  }
+
+  ~MmalPortAndPool() override
+  {
+    disable();
+  }
+
+  int create_port_pool()
+  {
+    return set_pool(new MmalPortPool(vc_init_, port_));
+  }
+
+  int create_user_pool(const uint32_t buffer_num)
+  {
+    return set_pool(new MmalUserPool(vc_init_), buffer_num);
+  }
+
+  MMAL_BUFFER_HEADER_T * pool_get(const bool wait = false)
+  {
+    if (!pool_) {
+      LOG(ERROR) << "### Pool not set up\n";
+      return nullptr;
+    }
+
+    MMAL_BUFFER_HEADER_T * const header =  wait ?
+      pool_->get_timeout(5000) : pool_->get();
+
+    return header;
+  }
+
+  int pool_size() const
+  {
+    return pool_->size();
+  }
+
+  int queue_length() const
+  {
+    return pool_->length();
+  }
+
+  int stuff(int stuff_count, const bool wait = false)
+  {
+    while (--stuff_count >= 0)
+    {
+      MMAL_BUFFER_HEADER_T * buffer;
+      if (!(buffer = pool_get(wait)))
+      {
+        LOG(ERROR) << "### Unexpected pool_get_failure";
+        return -1;
+      }
+
+      // When flushing/disabling we may have left stuff with lengths in the pool
+      mmal_buffer_header_reset(buffer);
+      if (submit(buffer) != 0)
+        return -1;
+    }
+    return 0;
+  }
+
+  void recycle(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    mmal_buffer_header_reset(buffer);
+    submit(pool_->put_get(buffer));
+  }
+
+  int enable() override
+  {
+    if (pool_ == nullptr)
+    {
+      LOG(ERROR) << "MmalPoolAndPort::enable: pool NULL";
+      return -1;
+    }
+
+    if (pool_->port_resized(buffer_num(), buffer_size(), frame_size()) != 0 ||
+        pool_->enable(
+//            base::BindRepeating(MmalPortAndPool::pool_get_cb, scoped_refptr<MmalPortAndPool>(this)),
+            base::BindRepeating(&MmalPortAndPool::pool_get_cb, this),
+            base::BindRepeating(MmalPortAndPool::pool_rel_cb, scoped_refptr<MmalPortAndPool>(this))) != 0)
+      return -1;
+
+    return MmalPort::enable();
+  }
+
+  int disable_port()
+  {
+    return MmalPort::disable();
+  }
+  int disable_pool()
+  {
+    return (pool_ != nullptr && pool_->disable() != 0) ? -1 : 0;
+  }
+
+  int disable() override
+  {
+    const int rv = disable_port();
+    return (disable_pool() != 0) ? -1 : rv;
+  }
+
+  int commit() override
+  {
+    const int rv = MmalPort::commit();
+    // ** Notify pool that size may have changed
+    return rv;
+  }
+
+  void set_trampoline(scoped_refptr<MmalTrampoline>& trampoline)
+  {
+    pool_->set_trampoline(trampoline);
+  }
+};
+
+// ----------------------------------------------------------------------------
+
+class MmalVideoESPort : public MmalPortAndPool
+{
+  struct ESBufferUserData {
+    VideoDecoder::DecodeCB decode_cb_;
+
+    ESBufferUserData(VideoDecoder::DecodeCB decode_cb) :
+      decode_cb_(std::move(decode_cb))
+    {
+    }
+
+    ~ESBufferUserData() = default;
+  };
+
+  std::queue<std::unique_ptr<ESBufferHolder>> es_q_;
+
+  bool low_delay_;
+
+public:
+  MmalVideoESPort(const scoped_refptr<MmalVcInit>& vc_init, MmalComponent * const component) :
+    MmalPortAndPool(vc_init, component),
+    low_delay_(false)
+  {
+  }
+  ~MmalVideoESPort() override
+  {
+  }
+
+  void set_port(MMAL_PORT_T * const port) override
+  {
+    MmalPort::set_port(port);
+  }
+
+  // Only checks the codec type if we had to set the encoding bitmask
+  bool set_supported_video_codecs() const
+  {
+    if (supported_video_codecs != 0)
+      return false;
+
+    const MmalPort::SupportedEncodings encodings(get_parameter_supported_encodings());
+
+    // We always claim to support H264
+    unsigned int bits = 1 << VideoCodec::kCodecH264;
+
+    for (auto& enc : encodings) {
+      bits |= 1 << fourcc_to_video_codec(enc);
+    }
+
+    // Mask out unknown
+    supported_video_codecs = bits & ~(1 << VideoCodec::kUnknownVideoCodec);
+
+    LOG(INFO) << "Supported video encodings: " << encodings.ToString() << ", bits=" << std::hex << bits;
+    return true;
+  }
+
+  int config(const VideoDecoderConfig& config, const bool low_delay)
+  {
+    const VideoCodec codec = config.codec();
+
+    if (set_supported_video_codecs())
+    {
+      // We set the supported mask - check if we expect this to work...
+      // If we didn't set it then assume we have already checked
+      if ((supported_video_codecs & (1 << codec)) == 0) {
+        // return silently
+        return -1;
+      }
+    }
+
+    low_delay_ = low_delay;
+
+    const MMAL_FOURCC_T encoding = video_codec_to_fourcc(codec);
+
+    if (encoding == MMAL_ENCODING_UNKNOWN) {
+      LOG(ERROR) << "### Unexpected video codec:" << config.codec();
+      return -1;
+    }
+
+    set_video_encoding(encoding, MMAL_ENCODING_VARIANT_DEFAULT, MMAL_ES_FORMAT_FLAG_FRAMED);
+
+    set_video_format(config.coded_size(),
+        config.visible_rect(),
+        par_from_sizes(config.visible_rect().size(), config.natural_size()),
+        color_space_to_mmal(config.color_space_info()));
+
+    return 0;
+  }
+
+private:
+  int submit_data(const std::unique_ptr<ESBufferHolder>& esb)
+  {
+    uint32_t bsent = 0;
+    ESBufferUserData * user_data = nullptr;
+
+    MMAL_BUFFER_HEADER_T * const buffer = pool_get(esb->is_not_pkt());
+    if (!buffer) {
+      return 0;
+    }
+
+//    LOG(ERROR) << "-- submit len=" << len << ", pts=" << pts;
+
+    // resets length, offset, flags, pts, dts
+    mmal_buffer_header_reset(buffer);
+    buffer->user_data = nullptr;
+    buffer->cmd = 0;
+
+    if (esb->is_eos())
+    {
+      buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;
+      // As this is zero length avoid poking the data
+      bsent = 1; // 0 means did nothing so pick another number
+
+      esb->Consume();
+    }
+    else
+    {
+      if (esb->is_start())
+      {
+        buffer->pts = (esb->pts() == kNoTimestamp) ? MMAL_TIME_UNKNOWN : esb->pts().InMicroseconds();
+//            buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;
+        buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START | MMAL_BUFFER_HEADER_FLAG_USER0;
+      }
+
+      bsent = buffer->length = esb->length(buffer->alloc_size);
+
+      if (mmal_buffer_header_mem_lock(buffer) != MMAL_SUCCESS)
+      {
+          LOG(ERROR) << "#### Cannot lock buffer";
+          buffer_release(buffer);
+          return -1;
+      }
+
+      if (esb->is_not_pkt())
+          buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;
+
+      memcpy(buffer->data, esb->data(), buffer->length);
+      esb->Consume(bsent);
+
+      mmal_buffer_header_mem_unlock(buffer);
+
+      if (esb->is_done())
+      {
+          buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
+
+          VideoDecoder::DecodeCB cb(esb->take_callback());
+          if (cb) {
+            user_data = new ESBufferUserData(std::move(cb));
+            buffer->user_data = (void *)user_data;
+          }
+      }
+    }
+
+//    LOG(ERROR) << "Submit: flags=" << std::hex << buffer->flags << std::dec << ", len=" << buffer->length << ", pts=" << buffer->pts;
+
+    if (MmalPortAndPool::submit(buffer) != 0)
+    {
+      // Given ordinary port pool we have to free this ourselves on failure
+      if (user_data) {
+        delete user_data;
+      }
+      return -1;
+    }
+
+    return (int)bsent;
+  }
+
+  void submit_poll()
+  {
+    for (; !es_q_.empty(); es_q_.pop())
+    {
+      while (!es_q_.front()->is_done()) {
+        const int bsent = submit_data(es_q_.front());
+
+//        LOG(ERROR) << "es submit bsent=" << bsent << ", pql=" << queue_length();
+
+        if (bsent == 0) {
+          // Q full - give up now
+          return;
+        } else if (bsent < 0) {
+          es_q_.front()->take_callback().Run(Status(StatusCode::kDecoderFailedDecode, "submit_data failed"));
+        }
+      }
+    }
+  }
+
+  void buffer_event_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    if (buffer->user_data) {
+      std::unique_ptr<ESBufferUserData> user_data((ESBufferUserData *)buffer->user_data);
+      buffer->user_data = nullptr;
+      std::move(user_data->decode_cb_).Run(OkStatus());  // decode_cb_ already bound to correct thread
+    }
+
+    buffer_release(buffer);
+
+    task_run(base::BindOnce(&MmalVideoESPort::submit_poll, this));
+  }
+
+
+public:
+  int submit_decoder_buffer(std::unique_ptr<ESBufferHolder> bh)
+  {
+    // * If we aren't in the same thread as task_runner_ at this point
+    //   then this lot is unsafe...
+
+    es_q_.push(std::move(bh));
+
+    submit_poll();
+    return 0;
+  }
+
+  int disable() override
+  {
+    // Get and kill any pending submit_callback
+    for (; !es_q_.empty(); es_q_.pop()) {
+      es_q_.front()->take_callback().Run(StatusCode::kAborted);
+    }
+    return MmalPortAndPool::disable();
+  }
+};
+
+
+// ----------------------------------------------------------------------------
+//
+// * It might be nice to split this into ZC & Copy versions but as it stands
+//   the port is declared directly in the component which makes that tricky
+
+class MmalVideoARGBPort : public MmalPortAndPool
+{
+  GpuVideoAcceleratorFactories* const gpu_factories_;
+  scoped_refptr<base::SequencedTaskRunner> gpu_thread_;
+
+  FrameCopyMode copy_mode_;
+  gfx::Size req_size_;
+  unsigned int stride_ = 0;
+  VideoDecoder::OutputCB output_cb_;
+  VideoDecoder::DecodeCB eos_cb_;
+  base::Lock req_lock_;
+  bool red_pixel_;
+  scoped_refptr<MmalTrampoline> frame_trampoline_;
+  scoped_refptr<MmalShmVideoFrame> sliced_frame_;
+  int sliced_y_;
+  base::TimeDelta last_pts_;
+  bool debug_bench_;
+  bool resize_disabled_;
+  scoped_refptr<DeferredList> deferred_list_;
+  gfx::ColorSpace color_space_;
+
+  std::unique_ptr<FpS> fps_;
+
+  void inline RunInGPUThreadOnce(base::OnceClosure closure)
+  {
+    gpu_thread_->PostTask(FROM_HERE, std::move(closure));
+  }
+
+  bool inline eos_pending() const
+  {
+    return !eos_cb_.is_null();
+  }
+
+  void kill_trampoline()
+  {
+    if (frame_trampoline_)
+    {
+      frame_trampoline_->kill();
+      frame_trampoline_.reset();
+    }
+  }
+
+  // Mostly required to discard the return value
+  void posted_submit(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+//    LOG(ERROR) << "--- " << __func__;
+    submit(buffer);
+  }
+
+  // Unlocks buffer & recycles it
+  // Called from trampoline on free_frame
+  // so may come from a random thread
+  void copied_frame_destruction_cb(const int buffer_count)
+  {
+    // stuff may have to wait for a buffer as the recycling
+    // cannot be protected by the trampoline lock with the current
+    // code so we have a race
+    if (stuff(buffer_count, true) == -1)
+      LOG(FATAL) << "No buffers to back up recycle request";
+  }
+
+  void resize_posted()
+  {
+    gfx::Size req_size;
+
+    {
+      base::AutoLock lock(req_lock_);
+
+      // Take consistent copy inside lock (no blocking ops inside this lock)
+      req_size = req_size_;
+
+      // ?? and likely the same size
+
+      if (req_size == size())
+        return;
+
+      // Must avoid disable/enable if
+      //   (a) Already disabled
+      //   (b) EOS pending (will confuse the process)
+
+      if (eos_pending()) {
+        LOG(INFO) << __func__ << ": abort due to EOS";
+        // If EOS pending then do nothing - we shouldn't get more stream
+        // until at least a reset
+        // Reset req_size to whatever we are so we will get recalled if needed
+        // * Locking ??
+        req_size_ = size();
+        return;
+      }
+    }
+
+    LOG(INFO) << "Resize to " << req_size.ToString();
+
+    const bool was_enabled = is_enabled();
+
+    if (was_enabled) {
+      disable();
+    }
+
+    set_size(req_size);
+    commit();
+
+    // *** Pool resize for new frame size
+    //     Mucky!
+    if (copy_mode_ != FrameCopyMode::SLICE) {
+      set_buffers(buffer_size_recommended(), buffer_num());
+      if (copy_mode_.port_has_pool()) {
+        // In this case the allocation is done by mmal so we need to recreate the
+        set_pool(nullptr);  // Kill before realloc so we never have 2 sets alloce
+        create_port_pool();
+      }
+    }
+
+    if (was_enabled)
+      enable();
+  }
+
+public:
+  void reset_reqs()
+  {
+    base::AutoLock lock(req_lock_);
+    req_size_ = gfx::Size(port_->format->es->video.crop.width, port_->format->es->video.crop.height);
+  }
+
+  void resize_cb(const gfx::Size& size)
+  {
+    {
+      base::AutoLock lock(req_lock_);
+
+      if (size == req_size_ || resize_disabled_) {
+        return;
+      }
+      req_size_ = size;
+    }
+
+    // Avoid running in the callback - run on our own thread
+    task_run(base::BindOnce(&MmalVideoARGBPort::resize_posted, this));
+  }
+
+  gfx::Size size() const
+  {
+    return gfx::Size(port_->format->es->video.crop.width, port_->format->es->video.crop.height);
+  }
+
+  gfx::Rect visible_rect() const
+  {
+    return gfx::Rect(
+        port_->format->es->video.crop.x, port_->format->es->video.crop.y,
+        port_->format->es->video.crop.width, port_->format->es->video.crop.height);
+  }
+
+  gfx::Size coded_size() const
+  {
+    return gfx::Size(port_->format->es->video.width, port_->format->es->video.height);
+  }
+
+  gfx::Size natural_size() const
+  {
+    const unsigned int par_n = port_->format->es->video.par.num;
+    const unsigned int par_d = port_->format->es->video.par.den;
+    const unsigned int width = port_->format->es->video.crop.width;
+    const unsigned int height = port_->format->es->video.crop.height;
+
+    if (par_n == 0 || par_d == 0)
+      return gfx::Size(width, height);
+
+    return gfx::Size((width * par_n + par_d / 2) / par_d, height);
+  }
+
+  size_t stride() const
+  {
+    return stride_;
+  }
+
+private:
+
+  // Recycles buffer too
+  void mov_frame_block(const scoped_refptr<MmalShmVideoFrame>& frame,
+      MMAL_BUFFER_HEADER_T * const buffer,
+      const size_t width,
+      const size_t start_y,
+      const int lines)
+  {
+    MMAL_STATUS_T err;
+
+    if ((err = mmal_buffer_header_mem_lock(buffer)) != MMAL_SUCCESS)
+    {
+      LOG(ERROR) << "### Unable to lock buffer; err=" << err;
+      return;
+    }
+
+    const uint8_t * s = buffer->data + buffer->type->video.offset[0];
+    const size_t s_stride = buffer->type->video.pitch[0];
+    const size_t d_stride = frame->stride(0);
+    uint8_t * d = frame->data(0) + start_y * d_stride;
+    const size_t line_size = width * 4;
+
+    for (int i = 0; i < lines; ++i, s += s_stride, d += d_stride)
+      memcpy(d, s, line_size);
+
+    // Unlock & recycles
+    mmal_buffer_header_mem_unlock(buffer);
+
+    // Count buffers used by this frame
+    frame->inc_buffer_count();
+
+    if (frame_trampoline_->recycle_buffer_in_flight(buffer)) {
+      recycle(buffer);
+    }
+  }
+
+  // Do final ops for all sync output
+  void emit_copied_frame(const scoped_refptr<VideoFrame>& frame, MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    frame->set_color_space(color_space_);
+
+    if (buffer && frame_trampoline_->recycle_buffer_in_flight(buffer)) {
+      recycle(buffer);
+    }
+
+    if (frame->timestamp() != kNoTimestamp)
+      last_pts_ = frame->timestamp();
+
+    if (debug_bench_) {
+      // In bench mode just drop the frame on the floor
+      return;
+    }
+    if (red_pixel_) {
+      // Mark our frames with happy red pixels
+      uint8_t * d = frame->data(0);
+      const size_t d_stride = frame->stride(0);
+
+      for (int i = 0; i != 8; ++i, d += d_stride) {
+          for (int j = 0; j != 8 * 4; j += 4) {
+              d[j+0] = 0;
+              d[j+1] = 0;
+              d[j+2] = 0xff;
+              d[j+3] = 0xff;
+          }
+      }
+    }
+
+    // Kick the output cb onto another thread so we can return from here ASAP
+    // to free up the MMAL CB thread
+    task_run(base::BindOnce(output_cb_, frame));
+  }
+
+  void deferred_gpu_buffer(std::unique_ptr<DeferredBuffer> dbuf,
+                           const base::TimeDelta pts)
+  {
+    MMAL_BUFFER_HEADER_T * const buffer = dbuf->ExtractAndLock();
+
+    // Buffer will be null if our port has been disabled between
+    // task scheduling & now
+    if (!buffer)
+      return;
+
+    const bool is_copy = copy_mode_.port_copy() == PortCopy::Copy;
+    FrameDesc * const frame_desc = is_copy ?
+      frame_trampoline_->alloc_frame() :
+      FrameDesc::Extract(buffer);
+
+    // Copy on our side...
+    scoped_refptr<MmalGPUVideoFrame> frame(MmalGPUVideoFrame::Create(
+        frame_desc,
+        frame_trampoline_,
+        visible_rect(), natural_size(),
+        pts));
+
+    // Set colour unless YUV-VCSM as that is bust (colours go all wrong)
+    if (copy_mode_.get() != FrameCopyMode::FRAME_GPU_YUV_VCSM)
+      frame->set_color_space(color_space_);
+
+    if (is_copy)
+      frame->copy_buffer(buffer);
+
+    if (frame_trampoline_->recycle_buffer_in_flight(buffer)) {
+      recycle(buffer);
+    }
+
+    dbuf.reset();  // Done with buffer
+
+    frame->BindAndEmit(output_cb_);
+  }
+
+protected:
+  void buffer_event_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    // Halfway recent firmwares now set buffer->type->video.pitch[0]
+    // Older ones had zeros but that is old enough to ignore now
+    const gfx::Size cur_size = size();
+
+//    const base::TimeDelta pts(kNoTimestamp);
+
+    const base::TimeDelta pts(buffer->pts == MMAL_TIME_UNKNOWN ?
+        kNoTimestamp :
+        base::TimeDelta::FromMicroseconds(buffer->pts));
+
+#if TRACE_BUFFER_EVENT
+    if ((buffer->flags & MMAL_BUFFER_HEADER_FLAG_FRAME_END) != 0) {
+      LOG(INFO) << "-- Got frame from resizer: copy_mode=" << copy_mode_ << ", len=" << buffer->length <<
+          ", size = " << port_->format->es->video.width << "x" << port_->format->es->video.height << ", req=" << cur_size.ToString() <<
+          ", rec size=" << port_->buffer_size_recommended << ", cur_size=" << port_->buffer_size <<
+          ", stride=" << buffer->type->video.pitch[0] << "/" << stride() << ", pts=" << buffer->pts <<
+          ", flags=" << std::hex << buffer->flags << std::dec << ", enabled=" << port_->is_enabled <<
+          ", pts_delta=" << (pts - last_pts_).InMicroseconds() << ", user=" << (void *)buffer->user_data;
+        ;
+    }
+#endif
+
+    if ((buffer->flags & MMAL_BUFFER_HEADER_FLAG_EOS) != 0) {
+      LOG(INFO) << ">>> EOS";
+      if (fps_ != nullptr) {
+        LOG(ERROR) << "@@@@ EOS: fps=" << fps_->ToString();
+      }
+      // Finally call the decode CB
+      if (eos_pending()) {
+        std::move(eos_cb_).Run(OkStatus());
+      }
+      // Remember to recycle the buffer!
+      recycle(buffer);
+      return;
+    }
+
+    if (buffer->length == 0 || !is_enabled()) {
+      // Flushing or empty buffer
+      recycle(buffer);
+      return;
+    }
+
+    switch (copy_mode_.get()) {
+      case FrameCopyMode::unset:
+        LOG(ERROR) << "### copy mode unset";
+        recycle(buffer);
+        break;
+
+      case FrameCopyMode::FRAME_NV12:
+      case FrameCopyMode::FRAME_I420:
+      case FrameCopyMode::FRAME_ARGB_DMA:
+      case FrameCopyMode::FRAME_ARGB_COPY:
+      {
+        const bool is_copy = copy_mode_.port_copy() == PortCopy::Copy;
+        FrameDesc * const frame_desc = is_copy ?
+          frame_trampoline_->alloc_frame() :
+          FrameDesc::Extract(buffer);
+
+        scoped_refptr<MmalShmVideoFrame> frame(MmalShmVideoFrame::Create(
+          frame_desc,
+          frame_trampoline_,
+          visible_rect(), natural_size(),
+          pts));
+
+        if (is_copy)
+          frame->copy_buffer(buffer);
+
+        frame->inc_buffer_count();
+
+        emit_copied_frame(frame, buffer);
+        break;
+      }
+
+      case FrameCopyMode::FRAME_GPU_ARGB_VCSM:   // DMA processing is good enough
+      case FrameCopyMode::FRAME_GPU_ARGB_DMA:
+      case FrameCopyMode::FRAME_GPU_YUV_VCSM:
+      case FrameCopyMode::FRAME_GPU_YUV_COPY:
+      {
+        // Needs to run on GPU thread so kick over
+        // Any op that changes frame sizes will disable the port
+        // which in turn will reclaim the bufer from the deferred list
+        // so sizes etc. will still be valid in the callback if we have a
+        // buffer (and if we don't then we give up early)
+
+        std::unique_ptr<DeferredBuffer> dbuf(deferred_list_->AddBuffer(buffer));
+
+        if (!dbuf)
+          recycle(buffer);
+        else
+          RunInGPUThreadOnce(base::BindOnce(&MmalVideoARGBPort::deferred_gpu_buffer, this, std::move(dbuf), pts));
+        break;
+      }
+
+      case FrameCopyMode::SLICE:
+      {
+        // Remember end of frame flag as we kill the buffer before using it
+        const bool eof = (buffer->flags & MMAL_BUFFER_HEADER_FLAG_FRAME_END) != 0;
+
+        if (!sliced_frame_) {
+          sliced_y_ = 0;
+          // pts only correct at eof
+          sliced_frame_ = MmalShmVideoFrame::Create(
+              frame_trampoline_->alloc_frame(),
+              frame_trampoline_,
+              visible_rect(), natural_size());
+        }
+
+        mov_frame_block(sliced_frame_, buffer, cur_size.width(), sliced_y_,
+            std::min(MMAL_SLICE_HEIGHT, sliced_frame_->rows(0) - sliced_y_));
+
+        if ((sliced_y_ += MMAL_SLICE_HEIGHT) < sliced_frame_->rows(0))
+        {
+          // Partial - stop now
+          if (eof) {
+            // Partial frame - discard
+            sliced_frame_.reset();
+            LOG(WARNING) << "### frame underrun";
+          }
+          return;
+        }
+        if (!eof) {
+          // Overrun
+          LOG(WARNING) << "### frame overrun";
+        }
+        sliced_frame_->set_timestamp(pts);
+
+        // Make sure sliced_frame_ is NULL before we do output callbacks
+        // that might cause us to look at it
+        emit_copied_frame(std::move(sliced_frame_), nullptr);
+        break;
+      }
+    }
+
+    if (fps_ != nullptr) {
+      fps_->inc_frames();
+      if (fps_->period_expired(1000000))
+      {
+        LOG(ERROR) << "--- fps = " << fps_->ToString();
+      }
+    }
+  }
+
+public:
+  MmalVideoARGBPort(const scoped_refptr<MmalVcInit>& vc_init, MmalComponent * const component, GpuVideoAcceleratorFactories* const gpu_factories) :
+    MmalPortAndPool(vc_init, component),
+    gpu_factories_(gpu_factories),
+    red_pixel_(false),
+    last_pts_(kNoTimestamp),
+    debug_bench_(false),
+    resize_disabled_(false),
+    deferred_list_(new DeferredList())
+  {
+    if (gpu_factories)
+      gpu_thread_ = gpu_factories->GetTaskRunner();
+  }
+
+  ~MmalVideoARGBPort() override
+  {
+    kill_trampoline();
+  }
+
+  int create_frame_pool(const bool zc)
+  {
+    return set_pool(zc ? new MmalFramePoolZc(vc_init_, copy_mode_) : new MmalFramePool(vc_init_, copy_mode_));
+  }
+
+  void set_port(MMAL_PORT_T * const port) override
+  {
+    MmalPort::set_port(port);
+
+    port_->format->type = MMAL_ES_TYPE_VIDEO;
+  }
+
+  void set_copy_mode(const FrameCopyMode copy_mode, const VideoColorSpace& video_color_space)
+  {
+    copy_mode_ = copy_mode;
+
+    //??? probably should refactor this lot for req/cur s.t. everything happens on commit
+    port_->format->encoding = copy_mode_.mmal_encoding();
+    port_->format->encoding_variant = MMAL_ENCODING_VARIANT_DEFAULT;
+
+    if (copy_mode_.is_yuv()) {
+      color_space_ = video_color_space.ToGfxColorSpace();
+      port_->format->es->video.color_space = color_space_to_mmal(video_color_space);
+    }
+    else {
+      color_space_ = gfx::ColorSpace::CreateSRGB();
+      port_->format->es->video.color_space = MMAL_COLOR_SPACE_UNKNOWN;
+    }
+  }
+
+  int set_size(const gfx::Size& req_size)
+  {
+    set_video_format(req_size, gfx::Rect(req_size), gfx::Size(), port_->format->es->video.color_space);
+    stride_ = mmal_encoding_width_to_stride(port_->format->encoding, port_->format->es->video.width);
+    return 0;
+  }
+
+  void set_eos_cb(VideoDecoder::DecodeCB eos_cb)
+  {
+    eos_cb_ = std::move(eos_cb);
+  }
+
+  int set_debug_bench(const bool enable_bench, const bool enable_fps)
+  {
+    debug_bench_ = enable_bench;
+    fps_ = std::unique_ptr<FpS>(!enable_fps ? nullptr : new FpS());
+    return 0;
+  }
+
+  int set_resize_disabled(const bool disable)
+  {
+    resize_disabled_ = disable;
+    return 0;
+  }
+
+  void set_red_pixel(const bool red)
+  {
+    red_pixel_ = red;
+  }
+
+public:
+  int enable() override
+  {
+    if (is_enabled()) {
+      LOG(INFO) << "Already enabled";
+    }
+    DCHECK(!is_enabled());
+
+    kill_trampoline();  // Shouldn't be needed but good to make sure
+
+    const int buffers_per_frame = !copy_mode_.is_slice() ? 1 :
+        (port_->format->es->video.crop.height + MMAL_SLICE_HEIGHT - 1) / MMAL_SLICE_HEIGHT;
+
+    frame_trampoline_ = new MmalTrampoline(vc_init_, gpu_factories_,
+        buffer_size() * buffers_per_frame, frame_size(),
+        copy_mode_, color_space_,
+        buffers_per_frame * MAX_COPY_FRAMES_IN_FLIGHT,
+        base::BindRepeating(&MmalVideoARGBPort::copied_frame_destruction_cb, this));
+
+    set_trampoline(frame_trampoline_);
+
+    if (MmalPortAndPool::enable() != 0)
+      return  -1;
+
+    if (fps_ != nullptr) {
+      fps_->start();
+    }
+
+    if (stuff(buffer_num())) {
+      LOG(INFO) << __func__ << ": Failed to stuff all " << buffer_num() << " buffers";
+      disable();
+      return -1;
+    }
+
+    return 0;
+  }
+
+  int enable(const VideoDecoder::OutputCB& output_cb)
+  {
+    output_cb_ = output_cb;
+    return enable();
+  }
+
+  int disable() override
+  {
+    int rv;
+
+    {
+      DeferredReclaim reclaim(deferred_list_);
+
+      // Nothing should be added to the deferred list after ReclaimStart
+      MMAL_BUFFER_HEADER_T * buffer;
+      while ((buffer = reclaim.Extract()) != nullptr) {
+        recycle(buffer);
+      }
+
+      rv = MmalPortAndPool::disable();
+
+      // ReclaimFinish
+    }
+
+    // Worry about class status vars after disable to avoid race conditions
+    kill_trampoline();
+
+    sliced_frame_.reset();  // Forget any partial frame info
+
+    if (eos_pending()) {
+      LOG(INFO) << ">>> EOS (abort)";
+      std::move(eos_cb_).Run(StatusCode::kAborted);
+    }
+//    LOG(ERROR) << "@@@@ disable: fps=" << fps.ToString();
+
+    return rv;
+  }
+
+  bool is_stalling() const
+  {
+    // If trampoline is null for some reason e.g. decoder reset
+    // then assume that in_flight is 0 as it will be when we regenerate the
+    // trampoline
+    return frame_trampoline_ != nullptr && frame_trampoline_->is_stalling();
+  }
+};
+
+  // ---------------------------------------------------------------------------
+
+class MmalComponent : public base::RefCountedThreadSafe<MmalComponent>
+{
+  const scoped_refptr<MmalVcInit> vc_init_;
+
+protected:
+  MMAL_COMPONENT_T * component_;
+private:
+  MmalTaskRunner task_runner_;
+
+protected:
+  int create_by_name(const char * const name)
+  {
+    MMAL_STATUS_T err;
+    if ((err = mmal_component_create(name, &component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_create(" << name << ") failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  friend class base::RefCountedThreadSafe<MmalComponent>;
+  virtual ~MmalComponent()
+  {
+    if (component_) {
+      mmal_component_release(component_);
+    }
+  }
+
+  virtual MmalConnectedPort * input_port() = 0;
+  virtual MmalConnectedPort * output_port() = 0;
+
+public:
+  MmalComponent(const scoped_refptr<MmalVcInit>& vc_init) :
+    vc_init_(vc_init),
+    component_(nullptr),
+//    task_runner_(base::ThreadTaskRunnerHandle::Get())
+    task_runner_(base::SequencedTaskRunnerHandle::Get())
+  {
+  }
+
+  const MmalTaskRunner& task_runner() const
+  {
+    return task_runner_;
+  }
+
+  virtual const char * name() const = 0;
+
+  int connect_to_output(scoped_refptr<MmalComponent> src)
+  {
+    MmalConnectedPort * const dest = input_port();
+    if (dest->connect_to_src(src->output_port()) != 0)
+      return -1;
+    if (dest->enable() != 0) {
+      dest->disconnect();
+      return -1;
+    }
+    return 0;
+  }
+
+  int enable()
+  {
+    MMAL_STATUS_T err;
+
+    if ((err = mmal_component_enable(component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_enable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int disable()
+  {
+    MMAL_STATUS_T err;
+    if ((err = mmal_component_disable(component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_disable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  // Shut this component down
+  // Reclaim all resources as they return & attempt to zero our internal
+  // ref count so we will die when the decoder derefs us.
+  // The reclaim process may be async so we may die some time later
+  virtual void kill() = 0;
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalVideoDecoderComponent : public MmalComponent
+{
+  MmalVideoESPort port_in_;
+  MmalConnectedPort port_out_;
+  MmalPort port_ctrl_;
+
+protected:
+  ~MmalVideoDecoderComponent() override
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ ~MmalVideoDecoderComponent";
+#endif
+  }
+
+  MmalConnectedPort * input_port() override
+  {
+    return nullptr;
+  }
+
+  MmalConnectedPort * output_port() override
+  {
+    return &port_out_;
+  }
+
+
+public:
+  MmalVideoDecoderComponent(const scoped_refptr<MmalVcInit>& vc_init) :
+    MmalComponent(vc_init),
+    port_in_(vc_init, this),
+    port_out_(vc_init),
+    port_ctrl_(vc_init)
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ MmalVideoDecoderComponent";
+#endif
+  }
+
+  const char * name() const override
+  {
+    return "VideoDecoder";
+  }
+
+  int create(const MmalVideoDecoder::Options& opt, const VideoDecoderConfig& config, const bool low_delay)
+  {
+    if (create_by_name(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER) != 0) {
+      return -1;
+    }
+
+    // Attach control structures to ports
+    port_in_.set_port(component_->input[0]);
+    port_out_.set_port(component_->output[0]);
+    port_ctrl_.set_port(component_->control);
+
+    if (
+        port_ctrl_.enable() != 0 ||
+
+        port_in_.set_parameter(MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS, low_delay ? -5 : -10) != 0 ||
+//        port_in_.set_parameter(MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS, -3) != 0 ||
+        port_in_.config(config, low_delay) != 0 ||
+        port_in_.commit() != 0 ||
+
+//        port_out_.set_parameter(MMAL_PARAMETER_EXTRA_BUFFERS, 6) != 0 ||
+        port_out_.set_parameter(MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS, false) != 0 ||
+        port_out_.set_video_encoding(opt.decoder_out_encoding()) != 0 ||
+        port_out_.set_video_format(config.coded_size(),
+            config.visible_rect(),
+            par_from_sizes(config.visible_rect().size(), config.natural_size()),
+            color_space_to_mmal(config.color_space_info())) != 0 ||
+        port_out_.commit() != 0 ||
+
+        port_in_.set_buffers(0x10000, 8) != 0 ||
+        port_in_.set_parameter(MMAL_PARAMETER_ZERO_COPY, false) != 0 ||  // ### Z-Copy is bust here
+        port_in_.create_port_pool() != 0 ||
+
+        port_in_.enable() != 0)
+    {
+      goto fail;
+    }
+
+    return 0;
+
+fail:
+    return -1;
+  }
+
+  void kill() override
+  {
+    port_in_.kill();
+    port_out_.kill();
+  }
+
+  void reset1()
+  {
+    port_in_.disable();
+    port_out_.disable();
+  }
+
+  void reset2()
+  {
+    port_out_.enable();
+    port_in_.enable();
+  }
+
+
+  int submit(std::unique_ptr<ESBufferHolder> bh)
+  {
+    return port_in_.submit_decoder_buffer(std::move(bh));
+  }
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalVideoResizerComponent : public MmalComponent
+{
+  FrameCopyMode copy_mode_;
+  gfx::Size cur_size_;
+  MmalConnectedPort port_in_;
+  MmalVideoARGBPort port_out_;
+  MmalPort port_ctrl_;
+
+protected:
+  ~MmalVideoResizerComponent() override
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ ~MmalVideoResizerComponent";
+#endif
+  }
+
+  MmalConnectedPort * input_port() override
+  {
+    return &port_in_;
+  }
+
+  MmalConnectedPort * output_port() override
+  {
+    return nullptr;
+  }
+
+
+public:
+  MmalVideoResizerComponent(const scoped_refptr<MmalVcInit>& vc_init, GpuVideoAcceleratorFactories* const gpu_factories) :
+    MmalComponent(vc_init),
+    copy_mode_(FrameCopyMode::unset),
+    port_in_(vc_init),
+    port_out_(vc_init, this, gpu_factories),
+    port_ctrl_(vc_init)
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ MmalVideoResizerComponent";
+#endif
+  }
+
+  const char * name() const override
+  {
+    return "Resizer";
+  }
+
+  int create(const MmalVideoDecoder::Options& opt)
+  {
+    if (create_by_name(opt.resizer_component_name()) != 0) {
+      return -1;
+    }
+
+    // Attach control structures to ports
+    port_in_.set_port(component_->input[0]);
+    port_out_.set_port(component_->output[0]);
+    port_ctrl_.set_port(component_->control);
+    return 0;
+  }
+
+  bool is_copy_mode_supported(const FrameCopyMode mode) const
+  {
+    return port_out_.get_parameter_supported_encodings().is_supported(mode.mmal_encoding());
+  }
+
+  // output_cb - always offloaded from the mmal cb thread so no point
+  //  in having it bound to current thread before calling.
+  int configure(const MmalVideoDecoder::Options& opt,
+      const VideoDecoderConfig& config, const VideoDecoder::OutputCB& output_cb)
+  {
+    const gfx::Size& size = config.natural_size();
+
+    copy_mode_ = opt.frame_copy_mode(is_copy_mode_supported(FrameCopyMode::SLICE));
+
+    port_out_.set_copy_mode(copy_mode_, config.color_space_info());
+
+    if (port_ctrl_.enable() != 0 ||
+        port_out_.set_size(opt.debug_fixed_size_set() ? opt.debug_fixed_size() : size) != 0 ||
+        port_out_.set_resize_disabled(opt.debug_fixed_size_set()) != 0 ||
+        port_out_.set_debug_bench(opt.debug_bench(), opt.debug_fps()) != 0 ||
+        port_out_.commit() != 0)
+    {
+      goto fail;
+    }
+
+    // Set req values to current values
+    port_out_.reset_reqs();
+
+    switch (copy_mode_.get()) {
+      case FrameCopyMode::SLICE:
+        if (port_out_.set_buffers(MMAL_SLICE_HEIGHT * MMAL_LIMIT_WIDTH * 4, opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, true) != 0 ||
+          port_out_.create_port_pool() != 0)
+        {
+          goto fail;
+        }
+        break;
+
+      case FrameCopyMode::FRAME_GPU_YUV_VCSM:
+      case FrameCopyMode::FRAME_GPU_ARGB_VCSM:
+        // Zero copy into provided VCSM buffers
+        if (port_out_.set_buffers(port_out_.buffer_size_recommended(), opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, true) != 0 ||
+          port_out_.create_frame_pool(true) != 0)
+        {
+          goto fail;
+        }
+        break;
+
+      case FrameCopyMode::FRAME_I420:
+      case FrameCopyMode::FRAME_NV12:
+      case FrameCopyMode::FRAME_ARGB_DMA:
+      case FrameCopyMode::FRAME_GPU_ARGB_DMA:
+        // Firmware-side frame copy
+        if (port_out_.set_buffers(port_out_.buffer_size_recommended(), opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, false) != 0 ||
+          port_out_.create_frame_pool(false) != 0)
+        {
+          goto fail;
+        }
+        break;
+
+      case FrameCopyMode::FRAME_GPU_YUV_COPY:
+      case FrameCopyMode::FRAME_ARGB_COPY:
+        if (port_out_.set_buffers(port_out_.buffer_size_recommended(), opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, true) != 0 ||
+          port_out_.create_port_pool() != 0)
+        {
+          goto fail;
+        }
+        break;
+
+      case FrameCopyMode::unset:
+        goto fail;
+    }
+
+    if (port_out_.enable(output_cb) != 0)
+      goto fail;
+
+    cur_size_ = size;
+    return 0;
+
+fail:
+    return -1;
+  }
+
+  void kill() override
+  {
+    port_in_.kill();
+    port_out_.kill();
+  }
+
+  void reset1()
+  {
+    port_in_.disable();
+    port_out_.disable();
+  }
+
+  void reset2()
+  {
+    port_out_.enable();
+    port_in_.enable();
+  }
+
+  void set_eos_cb(VideoDecoder::DecodeCB eos_cb)
+  {
+    port_out_.set_eos_cb(std::move(eos_cb));
+  }
+
+  void set_red_pixel(const bool red)
+  {
+    port_out_.set_red_pixel(red);
+  }
+
+  bool is_output_stalling() const
+  {
+    return port_out_.is_stalling();
+  }
+
+  void resize(const gfx::Size& new_size)
+  {
+    port_out_.resize_cb(new_size);
+  }
+};
+
+
+// ---------------------------------------------------------------------------
+
+void MmalConnection::disconnect()
+{
+  if (!src_ || !dest_) {
+    LOG(ERROR) << "#### src or dest NULL";
+    return;
+  }
+
+  disable();
+
+  // Commit suicide by killing our refs
+  // Both ends should still exist as the destruction of either
+  // should call this fn
+  src_->set_connection(nullptr);
+  dest_->set_connection(nullptr);
+}
+
+int MmalConnection::connect(MmalConnectedPort * const src, MmalConnectedPort * const dest)
+{
+  MMAL_STATUS_T err;
+
+  // MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS means
+  // that enable will actually observe the buffer_num
+  // and size fields - otherwise it will always ignore
+  // them
+  if ((err = mmal_connection_create(&connection_, src->port_, dest->port_,
+      MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS | MMAL_CONNECTION_FLAG_TUNNELLING)) != MMAL_SUCCESS) {
+    LOG(ERROR) << "### mmal_connection_create failed: err=" << err;
+    connection_ = nullptr;  // Just in case
+    return -1;
+  }
+
+  src->set_connection(this);
+  dest->set_connection(this);
+
+  src_ = src;
+  dest_ = dest;
+
+  // As we have asked for our choices to be respected we should make sure they
+  // are set to something sensible
+  set_buffers(buffer_size_recommended(), buffer_num_recommended());
+
+  mmal_log_dump_port(src->port_);
+  mmal_log_dump_port(dest->port_);
+  return 0;
+}
+
+uint32_t MmalConnection::buffer_size_recommended() const
+{
+  return std::max(src_->MmalPort::buffer_size_recommended(), dest_->MmalPort::buffer_size_recommended());
+}
+
+uint32_t MmalConnection::buffer_num_recommended() const
+{
+  return std::max(src_->MmalPort::buffer_num_recommended(), dest_->MmalPort::buffer_num_recommended());
+}
+
+uint32_t MmalConnection::buffer_size_min() const
+{
+  return std::max(src_->MmalPort::buffer_size_min(), dest_->MmalPort::buffer_size_min());
+}
+
+uint32_t MmalConnection::buffer_num_min() const
+{
+  return std::max(src_->MmalPort::buffer_num_min(), dest_->MmalPort::buffer_num_min());
+}
+
+int MmalConnection::set_buffers(uint32_t s, uint32_t n)
+{
+  src_->MmalPort::set_buffers(s, n);
+  dest_->MmalPort::set_buffers(s, n);
+  return 0;
+}
+
+
+// ---------------------------------------------------------------------------
+
+// Any refs required are applied to our enclosing object
+void MmalPortAndPool::AddRef()
+{
+  component_->AddRef();
+}
+
+// Any refs required are applied to our enclosing object
+void MmalPortAndPool::Release()
+{
+  component_->Release();
+}
+
+bool MmalPortAndPool::HasOneRef() const
+{
+  return component_->HasOneRef();
+}
+
+bool MmalPortAndPool::HasAtLeastOneRef() const
+{
+  return component_->HasAtLeastOneRef();
+}
+
+const MmalTaskRunner& MmalPortAndPool::task_runner() const
+{
+  return component_->task_runner();
+}
+
+// ---------------------------------------------------------------------------
+
+// static
+bool MmalVideoDecoder::IsCodecSupported(VideoCodec codec) {
+//  LOG(ERROR) << "Test codec: " << codec;
+  // If we have checked what we can do then use that otherwise press on
+  // if we have any chance (i.e. can find a valid 4cc)
+  return (supported_video_codecs & (1 << codec)) != 0 ||
+         (supported_video_codecs == 0 && video_codec_to_fourcc(codec) != MMAL_ENCODING_UNKNOWN);
+}
+
+bool MmalVideoDecoder::IsSizeSupported(const gfx::Size& size)
+{
+  return size.width() <= MMAL_LIMIT_WIDTH &&
+    size.height() <= MMAL_LIMIT_HEIGHT &&
+    size.width() >= 32 &&
+    size.height() >= 32;
+}
+
+// Resizer can deal with larger values than the limits we want on the decoder
+// Pick limits that might not kill us (at least till Pi4)
+static bool IsResizeSizeSupported(const gfx::Size& size)
+{
+  return size.width() <= 2048 &&
+    size.height() <= 1280 &&
+    size.width() >= 32 &&
+    size.height() >= 32;
+}
+
+MmalVideoDecoder::MmalVideoDecoder(GpuVideoAcceleratorFactories* gpu_factories) :
+  gpu_factories_(gpu_factories && gpu_factories->ShouldUseGpuMemoryBuffersForVideoFrames(false) ? gpu_factories : nullptr),
+  state_(MmalDecoderState::kNew),
+  counted_(false),
+  wants_extra_data_(false),
+  opt_(Options::Create()),
+  vc_init_(MmalVcInit::Init(opt_->single_process(), bool(gpu_factories_))),  // ****** Want better cma choice
+  weak_factory_(this)
+{
+#if TRACE_COMPONENT_CREATION
+  LOG(INFO) << "@@@ Create Decoder pid=" << getpid() << ", ppid=" << getppid() << ", gpu=" << (void *)gpu_factories <<
+    ", use_gpu:" << (bool)gpu_factories_;
+#endif
+
+  if (!vc_init_) {
+    state_ = MmalDecoderState::kFatal;
+    return;
+  }
+
+  opt_->set_firmware_date(vc_init_->firmware_date());
+  opt_->set_gpu_mem(vc_init_->gpu_mem());
+  opt_->set_gpu_frames((bool)gpu_factories_); // ***** VCSM/copied GPU?
+
+  if (gpu_factories_)
+  {
+    // Select YUV copy if we don't have tex import
+    // * Really should have better logic downstream s.t. stuff all works but
+    //   for now this will fix the crash
+    scoped_refptr<viz::RasterContextProvider> context_provider(gpu_factories_->GetMediaContextProvider());
+    const gpu::Capabilities& capabilities = context_provider->ContextCapabilities();
+    // tex_import false if unset
+    opt_->set_tex_import(capabilities.egl_image_external);
+  }
+
+  LOG(INFO) << opt_->ToString();
+  LOG(INFO) << opt_->OptString();
+
+  state_ = MmalDecoderState::kUninitialised;
+  return;
+}
+
+MmalVideoDecoder::~MmalVideoDecoder() {
+#if TRACE_COMPONENT_CREATION
+  LOG(INFO) << "@@@ Destroy Decoder";
+#endif
+
+  uninitialise();
+
+  if (counted_) {
+    base::subtle::NoBarrier_AtomicIncrement(&decoder_count, -1);
+  }
+}
+
+void MmalVideoDecoder::uninitialise(const MmalDecoderState new_state)
+{
+  if (decoder_) {
+    decoder_->kill();
+    decoder_.reset();
+  }
+  if (resizer_) {
+    resizer_->kill();
+    resizer_.reset();
+  }
+
+  extra_data_.reset();
+  wants_extra_data_ = false;
+
+  state_ = new_state;
+}
+
+// EOS callback - accessed via WeakPtr so if we are destroyed
+// whilst EOS is still pending this won't happen
+//
+// We call Reset on EOS.  This has a couple of benefits
+// 1) It reclaims memory as soon as possible (there's a decent chance we
+//    are done with this decoder now)
+// 2) It should allow us to go <decode> <eos> <decode> which is defined to
+//    work in the Decode spec (even if it doesn't seem to happen in reality)
+
+void MmalVideoDecoder::eos_cb(DecodeCB decode_cb, Status status)
+{
+//  LOG(ERROR) << "+++ EOS(" << status << ")";
+  Reset(base::BindOnce(std::move(decode_cb), status));
+}
+
+// Initializes a VideoDecoder with the given |config|, executing the
+// |init_cb| upon completion. |output_cb| is called for each output frame
+// decoded by Decode().
+//
+// If |low_delay| is true then the decoder is not allowed to queue frames,
+// except for out-of-order frames, i.e. if the next frame can be returned it
+// must be returned without waiting for Decode() to be called again.
+// Initialization should fail if |low_delay| is true and the decoder cannot
+// satisfy the requirements above.
+//
+// |cdm_context| can be used to handle encrypted buffers. May be null if the
+// stream is not encrypted.
+//
+// |waiting_cb| is called whenever the decoder is stalled waiting for
+// something, e.g. decryption key. May be called at any time after
+// Initialize().
+//
+// Note:
+// 1) The VideoDecoder will be reinitialized if it was initialized before.
+//    Upon reinitialization, all internal buffered frames will be dropped.
+// 2) This method should not be called during pending decode or reset.
+// 3) No VideoDecoder calls should be made before |init_cb| is executed.
+// 4) VideoDecoders should take care to run |output_cb| as soon as the frame
+// is ready (i.e. w/o thread trampolining) since it can strongly affect frame
+// delivery times with high-frame-rate material.  See Decode() for additional
+// notes.
+// 5) |init_cb| may be called before this returns.
+void MmalVideoDecoder::Initialize(const VideoDecoderConfig& config,
+                        bool low_delay,
+                        CdmContext* cdm_context,
+                        InitCB init_cb,
+                        const OutputCB& output_cb,
+                        const WaitingCB& waiting_cb)
+{
+  base::AutoLock lock(lock_);
+  Status fail_status(StatusCode::kDecoderFailedInitialization);
+
+  LOG(INFO) << "Mmal Init: low_delay=" << low_delay << ", config=" << config.AsHumanReadableString();
+
+  DCHECK(config.IsValidConfig());
+  DCHECK(!output_cb.is_null());
+
+  InitCB bound_init_cb(BindToCurrentLoop(std::move(init_cb)));
+
+  // If dead - give up now
+  if (state_ <= MmalDecoderState::kFatal) {
+    LOG(ERROR) << __func__ << ": FATAL";
+    std::move(bound_init_cb).Run(fail_status);
+    return;
+  }
+
+  // If already inited (or failed) then kill
+  if (state_ != kUninitialised) {
+    // * This is unsubtle in the extreme
+    // and we would really prefer to wait for the kill ops to finish
+    // before continuing so we don't have an overlap where we have
+    // two sets of resizer buffers ... or preserve the resizer...
+    // or something...
+    uninitialise();
+  }
+
+  if (state_ != kUninitialised) {
+    LOG(ERROR) << __func__ << ": Unexpected state: " << state_;
+    goto fail;
+  }
+
+  // Do we support this?
+  if (config.is_encrypted()) {
+    fail_status = Status(StatusCode::kEncryptedContentUnsupported);
+    goto fail;
+  }
+  if (!IsCodecSupported(config.codec())) {
+    fail_status = Status(StatusCode::kDecoderUnsupportedCodec);
+    goto fail;
+  }
+  if (!IsSizeSupported(config.coded_size())) {
+    fail_status = Status(StatusCode::kDecoderUnsupportedConfig);
+    goto fail;
+  }
+
+  // Check count
+  // 0 will effectively turn off mmal decode
+  if (!counted_)
+  {
+    const int n = (int)base::subtle::NoBarrier_AtomicIncrement(&decoder_count, 1);
+    const int max_dec = (int)opt_->max_decoders();
+    counted_ = true;
+    if (n > max_dec) {
+      LOG(WARNING) << __func__ << ": Exceeded decoder limit: " << n << "/" << max_dec;
+      goto fail;
+    }
+  }
+
+  LOG(INFO) << "Decoder count:" << decoder_count << "/" << opt_->max_decoders();
+
+  // Stash for later reset
+  decoder_config_ = config;
+  low_delay_ = opt_->low_delay(low_delay);
+
+  if (config.extra_data().size() != 0)
+  {
+    extra_data_ = DecoderBuffer::CopyFrom(&config.extra_data()[0], config.extra_data().size());
+    wants_extra_data_ = true;
+  }
+
+  decoder_ = new MmalVideoDecoderComponent(vc_init_);
+  if (decoder_->create(*opt_, config, low_delay_) != 0)
+    goto fail;
+  if (decoder_->enable() != 0)
+    goto fail;
+
+  resizer_ = new MmalVideoResizerComponent(vc_init_,
+    opt_->frame_copy_mode(false).is_gpu() ? gpu_factories_ : nullptr);
+
+  if (resizer_->create(*opt_) != 0)
+    goto fail;
+
+  if (resizer_->configure(*opt_, config, output_cb) != 0)
+    goto fail;
+
+  resizer_->set_red_pixel(opt_->red_pixel());
+  if (resizer_->enable() != 0)
+    goto fail;
+
+  if (resizer_->connect_to_output(decoder_) != 0)
+    goto fail;
+
+  state_ = MmalDecoderState::kInitialised;
+
+  // Success!
+  std::move(bound_init_cb).Run(OkStatus());
+  LOG(INFO) << __func__ << ": OK";
+  return;
+
+
+fail:
+  LOG(INFO) << __func__ << ": FAILED";
+  uninitialise(std::min(state_, MmalDecoderState::kFail));
+  if (counted_) {
+    counted_ = false;
+    base::subtle::NoBarrier_AtomicIncrement(&decoder_count, -1);
+  }
+  std::move(bound_init_cb).Run(fail_status);
+}
+
+// Requests a |buffer| to be decoded. The status of the decoder and decoded
+// frame are returned via the provided callback. Some decoders may allow
+// decoding multiple buffers in parallel. Callers should call
+// GetMaxDecodeRequests() to get number of buffers that may be decoded in
+// parallel.
+//
+// Implementations guarantee that the |decode_cb| will not be called from
+// within this method, and that it will be called even if Decode() is never
+// called again.
+//
+// After decoding is finished the decoder calls |output_cb| specified in
+// Initialize() for each decoded frame. |output_cb| may be called before or
+// after |decode_cb|, including before Decode() returns.
+//
+// If |buffer| is an EOS buffer then the decoder must be flushed, i.e.
+// |output_cb| must be called for each frame pending in the queue and
+// |decode_cb| must be called after that. Callers will not call Decode()
+// again until after the flush completes.
+void MmalVideoDecoder::Decode(scoped_refptr<DecoderBuffer> buffer,
+                    DecodeCB decode_cb)
+{
+  DCHECK(buffer.get());
+  DCHECK(!decode_cb.is_null());
+
+  const bool eos_req = buffer->end_of_stream();
+
+  // If we are in any state except running (reset, never sent data, eos)
+  // then EOS won't propagate and we should ack here & now
+  if (eos_req && state_ != MmalDecoderState::kRunning) {
+    LOG(INFO) << "<<< >>> EOS";
+    BindToCurrentLoop(std::move(decode_cb)).Run(OkStatus());
+    return;
+  }
+
+  if (state_ == MmalDecoderState::kResetEOS) {
+    // * Really we should be able to do half this work
+    //   and drop into ResetRun but the enables don't currently work
+    //   correctly for that
+
+    decoder_ = new MmalVideoDecoderComponent(vc_init_);
+    if (decoder_->create(*opt_, decoder_config_, low_delay_) != 0)
+      goto fail;
+    if (decoder_->enable() != 0)
+      goto fail;
+
+    if (resizer_->connect_to_output(decoder_) != 0)
+      goto fail;
+
+    resizer_->reset2();
+
+    wants_extra_data_ = bool(extra_data_);
+
+    state_ = MmalDecoderState::kInitialised;
+  }
+  else if (state_ == MmalDecoderState::kResetRun) {
+    resizer_->reset2();
+    decoder_->reset2();
+    wants_extra_data_ = (extra_data_ != NULL);
+    state_ = MmalDecoderState::kInitialised;
+  }
+
+  if (state_ < MmalDecoderState::kInitialised)
+  {
+    LOG(ERROR) << "### Decode in bad state: " << state_;
+    goto fail;
+  }
+
+  if (wants_extra_data_) {
+    if (!extra_data_) {
+      LOG(ERROR) << "### extra_data_ NULL";
+      goto fail;
+    }
+
+    wants_extra_data_ = false;
+    if (decoder_->submit(ESBufferHolder::CreateExtra(extra_data_)) < 0)
+      goto fail;
+  }
+
+  if (eos_req) {
+    LOG(INFO) << "<<< EOS";
+    // eos_cb must be called on the current thread
+    resizer_->set_eos_cb(BindToCurrentLoop(
+        base::BindOnce(&MmalVideoDecoder::eos_cb, GetWeakPtr(), std::move(decode_cb))));
+
+    if (decoder_->submit(ESBufferHolder::Create(buffer)) < 0)
+      goto fail;
+
+    state_ = MmalDecoderState::kEOS;
+  }
+  else
+  {
+    if (decoder_->submit(ESBufferHolder::Create(buffer, BindToCurrentLoop(std::move(decode_cb)))) < 0)
+      goto fail;
+
+    state_ = MmalDecoderState::kRunning;
+  }
+
+//  LOG(ERROR) << ">>> Decode";
+  return;
+
+fail:
+  LOG(WARNING) << ">>> Decode: FAIL";
+  BindToCurrentLoop(std::move(decode_cb)).Run(StatusCode::kDecoderFailedDecode);
+}
+
+// Resets decoder state. All pending Decode() requests will be finished or
+// aborted before |closure| is called.
+// Note: No VideoDecoder calls should be made before |closure| is executed.
+//
+// This fn shuts stuff down - restart is managed at the beginning of Decode
+
+void MmalVideoDecoder::Reset(base::OnceClosure closure) {
+  switch (state_) {
+    case MmalDecoderState::kRunning:
+      LOG(INFO) << "--- Reset (running)";
+      decoder_->reset1();
+      resizer_->reset1();
+      state_ = MmalDecoderState::kResetRun;
+      break;
+
+    case MmalDecoderState::kEOS:
+      LOG(INFO) << "--- Reset (EOS)";
+      decoder_->kill();
+      decoder_.reset();
+      resizer_->reset1();
+      state_ = MmalDecoderState::kResetEOS;
+      break;
+
+    default:
+      LOG(INFO) << "--- Reset (null)";
+      break;
+  }
+
+  // Ensure the closure is scheduled after any callbacks triggered by
+  // the reset sequence
+  base::SequencedTaskRunnerHandle::Get()->PostTask(FROM_HERE, std::move(closure));
+  LOG(INFO) << ">>> Reset";
+  return;
+}
+
+bool MmalVideoDecoder::CanReadWithoutStalling() const
+{
+  return resizer_ == nullptr || !resizer_->is_output_stalling();
+}
+
+int MmalVideoDecoder::GetMaxDecodeRequests() const
+{
+  // We can run with overlap or not - pick 2 in case it helps whatever is feeding us
+  return 2;
+}
+
+// There is the theoretical possibility of race here if this is called
+// whilst a reinitialise is running.  However the calling code in
+// video_renderer_impl already has a lock that should prevent that.
+void MmalVideoDecoder::TryResizeFrame(uint32_t width, uint32_t height)
+{
+  base::AutoLock lock(lock_);
+
+  gfx::Size size_req(width, height);
+
+//  LOG(INFO) << __func__ << ": " << decoder_config_.visible_rect().ToString() << " -> " << size_req.ToString() << ", mode=" << int(opt_->resize_mode());
+
+  switch (opt_->resize_mode()) {
+    case ResizeMode::Smaller:
+      if (int(width * height) >= decoder_config_.visible_rect().width() * decoder_config_.visible_rect().height())
+        return;
+      FALLTHROUGH;
+    case ResizeMode::Always:
+      if (!IsResizeSizeSupported(size_req))
+        size_req = decoder_config_.coded_size();
+      break;
+
+    default:  // Never
+      // If never then size was set to native at init & cannot change
+      return;
+  }
+
+  resizer_->resize(size_req);
+}
+
+VideoDecoderType MmalVideoDecoder::GetDecoderType() const
+{
+  return VideoDecoderType::kMmal;
+}
+
+
+}  // namespace media
+
+
+
diff --git a/src/media/filters/mmal_video_decoder.h b/src/media/filters/mmal_video_decoder.h
new file mode 100644
index 000000000000..8709703261a9
--- /dev/null
+++ b/src/media/filters/mmal_video_decoder.h
@@ -0,0 +1,121 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+#define MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+
+#include <list>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread_checker.h"
+#include "media/base/video_decoder.h"
+#include "media/base/video_decoder_config.h"
+#include "media/base/video_frame_pool.h"
+#include "base/command_line.h"
+#include "base/strings/string_number_conversions.h"
+
+
+
+struct AVCodecContext;
+struct AVFrame;
+
+namespace base {
+class SingleThreadTaskRunner;
+}
+
+namespace media {
+
+class DecoderBuffer;
+class MmalVideoDecoderComponent;
+class MmalVideoResizerComponent;
+class MmalVcInit;
+class GpuVideoAcceleratorFactories;
+
+class MEDIA_EXPORT MmalVideoDecoder : public VideoDecoder {
+public:
+  class Options;
+
+private:
+  enum MmalDecoderState {
+      kFatal = -2,
+      kFail = -1,
+      kNew = 0,
+      kUninitialised,
+      kReseting,
+      kResetEOS,     // Reset from EOS
+      kResetRun,     // Reset from running
+      kInitialised,  // Init but no decode yet
+      kRunning,      // Have successful decode
+      kEOS           // EOS rxed
+  };
+
+  base::Lock lock_;
+
+  GpuVideoAcceleratorFactories* const gpu_factories_;
+
+  MmalDecoderState state_;
+
+  // Have we counted this decoder (for decoder count limits) yet?
+  bool counted_;
+
+  scoped_refptr<DecoderBuffer> extra_data_;
+  bool wants_extra_data_;
+
+  scoped_refptr<MmalVideoDecoderComponent> decoder_;
+  // Resizer may persist after VideoDecoder dies if it maintains frames
+  // with shared VC memory
+  scoped_refptr<MmalVideoResizerComponent> resizer_;
+
+  VideoDecoderConfig decoder_config_;
+  bool low_delay_;
+
+  const std::unique_ptr<Options> opt_;
+  scoped_refptr<MmalVcInit> vc_init_;
+
+  void uninitialise(const MmalDecoderState new_state = kUninitialised);
+  void eos_cb(const DecodeCB decode_cb, Status status);
+  void format_req_cb(VideoPixelFormat pixel_format);
+
+ public:
+  static bool IsCodecSupported(VideoCodec codec);
+  static bool IsSizeSupported(const gfx::Size& size);
+
+  MmalVideoDecoder(GpuVideoAcceleratorFactories* gpu_factories);
+  ~MmalVideoDecoder() override;
+
+  // VideoDecoder implementation.
+  void Initialize(const VideoDecoderConfig& config,
+                          bool low_delay,
+                          CdmContext* cdm_context,
+                          InitCB init_cb,
+                          const OutputCB& output_cb,
+                          const WaitingCB& waiting_cb) override;
+
+  void Decode(scoped_refptr<DecoderBuffer> buffer,
+                      DecodeCB decode_cb) override;
+
+  void Reset(base::OnceClosure closure) override;
+
+  bool CanReadWithoutStalling() const override;
+  int GetMaxDecodeRequests() const override;
+  void TryResizeFrame(uint32_t width, uint32_t height) override;
+
+  VideoDecoderType GetDecoderType() const override;
+
+  inline base::WeakPtr<MmalVideoDecoder> GetWeakPtr() {
+    return weak_factory_.GetWeakPtr();
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MmalVideoDecoder);
+  base::WeakPtrFactory<MmalVideoDecoder> weak_factory_;
+};
+
+}  // namespace media
+
+#endif  // MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+
+
diff --git a/src/media/gpu/BUILD.gn b/src/media/gpu/BUILD.gn
index 4fba7f3731e6..3e4dd9c2e8c1 100644
--- a/src/media/gpu/BUILD.gn
+++ b/src/media/gpu/BUILD.gn
@@ -19,6 +19,7 @@ buildflag_header("buildflags") {
     "USE_VAAPI=$use_vaapi",
     "USE_VAAPI_IMAGE_CODECS=$use_vaapi_image_codecs",
     "USE_V4L2_CODEC=$use_v4l2_codec",
+    "USE_V4L2_CODEC_RPI=$use_v4l2_codec_rpi",
     "USE_LIBV4L2=$use_v4lplugin",
   ]
 }
diff --git a/src/media/gpu/args.gni b/src/media/gpu/args.gni
index 33c49cd2938c..e32ddd41194f 100644
--- a/src/media/gpu/args.gni
+++ b/src/media/gpu/args.gni
@@ -17,6 +17,10 @@ declare_args() {
   # platforms which have v4l2 hardware encoder
   use_v4l2_codec_aml = false
 
+  # Indicates if this is V4L2 on RPi.  Only compiles stateful V4L2 code
+  # and removes all legacy codecs
+  use_v4l2_codec_rpi = false
+
   # Indicates if VA-API-based hardware acceleration is to be used. This
   # is typically the case on x86-based ChromeOS devices.
   # VA-API should also be compiled by default on x11-using linux devices
diff --git a/src/media/gpu/gpu_video_decode_accelerator_factory.cc b/src/media/gpu/gpu_video_decode_accelerator_factory.cc
index 0e55ef47ec66..2cf3aee117f1 100644
--- a/src/media/gpu/gpu_video_decode_accelerator_factory.cc
+++ b/src/media/gpu/gpu_video_decode_accelerator_factory.cc
@@ -29,7 +29,9 @@
 #include "ui/gl/gl_implementation.h"
 #elif BUILDFLAG(USE_V4L2_CODEC)
 #include "media/gpu/v4l2/v4l2_device.h"
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
 #include "media/gpu/v4l2/v4l2_slice_video_decode_accelerator.h"
+#endif
 #include "media/gpu/v4l2/v4l2_video_decode_accelerator.h"
 #include "ui/gl/gl_surface_egl.h"
 #endif
@@ -64,10 +66,12 @@ gpu::VideoDecodeAcceleratorCapabilities GetDecoderCapabilitiesInternal(
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       V4L2VideoDecodeAccelerator::GetSupportedProfiles(),
       &capabilities.supported_profiles);
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       V4L2SliceVideoDecodeAccelerator::GetSupportedProfiles(),
       &capabilities.supported_profiles);
 #endif
+#endif
 #elif defined(OS_MAC)
   capabilities.supported_profiles =
       VTVideoDecodeAccelerator::GetSupportedProfiles(workarounds);
@@ -146,8 +150,10 @@ GpuVideoDecodeAcceleratorFactory::CreateVDA(
     &GpuVideoDecodeAcceleratorFactory::CreateVaapiVDA,
 #elif BUILDFLAG(USE_V4L2_CODEC)
     &GpuVideoDecodeAcceleratorFactory::CreateV4L2VDA,
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
     &GpuVideoDecodeAcceleratorFactory::CreateV4L2SliceVDA,
 #endif
+#endif
 
 #if defined(OS_MAC)
     &GpuVideoDecodeAcceleratorFactory::CreateVTVDA,
@@ -207,6 +213,7 @@ GpuVideoDecodeAcceleratorFactory::CreateV4L2VDA(
   return decoder;
 }
 
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
 std::unique_ptr<VideoDecodeAccelerator>
 GpuVideoDecodeAcceleratorFactory::CreateV4L2SliceVDA(
     const gpu::GpuDriverBugWorkarounds& /*workarounds*/,
@@ -222,6 +229,7 @@ GpuVideoDecodeAcceleratorFactory::CreateV4L2SliceVDA(
   return decoder;
 }
 #endif
+#endif
 
 #if defined(OS_MAC)
 std::unique_ptr<VideoDecodeAccelerator>
diff --git a/src/media/gpu/v4l2/BUILD.gn b/src/media/gpu/v4l2/BUILD.gn
index 755f8bc4caec..6ee58b7f71e4 100644
--- a/src/media/gpu/v4l2/BUILD.gn
+++ b/src/media/gpu/v4l2/BUILD.gn
@@ -28,23 +28,14 @@ source_set("v4l2") {
     "buffer_affinity_tracker.h",
     "generic_v4l2_device.cc",
     "generic_v4l2_device.h",
-    "v4l2_decode_surface.cc",
-    "v4l2_decode_surface.h",
-    "v4l2_decode_surface_handler.h",
     "v4l2_device.cc",
     "v4l2_device.h",
     "v4l2_device_poller.cc",
     "v4l2_device_poller.h",
     "v4l2_framerate_control.cc",
     "v4l2_framerate_control.h",
-    "v4l2_h264_accelerator.cc",
-    "v4l2_h264_accelerator.h",
-    "v4l2_h264_accelerator_legacy.cc",
-    "v4l2_h264_accelerator_legacy.h",
     "v4l2_image_processor_backend.cc",
     "v4l2_image_processor_backend.h",
-    "v4l2_slice_video_decode_accelerator.cc",
-    "v4l2_slice_video_decode_accelerator.h",
     "v4l2_stateful_workaround.cc",
     "v4l2_stateful_workaround.h",
     "v4l2_utils.cc",
@@ -59,26 +50,40 @@ source_set("v4l2") {
     "v4l2_video_decoder_backend.h",
     "v4l2_video_decoder_backend_stateful.cc",
     "v4l2_video_decoder_backend_stateful.h",
-    "v4l2_video_decoder_backend_stateless.cc",
-    "v4l2_video_decoder_backend_stateless.h",
     "v4l2_video_encode_accelerator.cc",
     "v4l2_video_encode_accelerator.h",
-    "v4l2_vp8_accelerator.cc",
-    "v4l2_vp8_accelerator.h",
-    "v4l2_vp8_accelerator_legacy.cc",
-    "v4l2_vp8_accelerator_legacy.h",
-    "v4l2_vp9_accelerator_chromium.cc",
-    "v4l2_vp9_accelerator_chromium.h",
-    "v4l2_vp9_accelerator_legacy.cc",
-    "v4l2_vp9_accelerator_legacy.h",
   ]
 
+  if (!use_v4l2_codec_rpi) {
+    sources += [
+      "v4l2_decode_surface.cc",
+      "v4l2_decode_surface.h",
+      "v4l2_decode_surface_handler.h",
+      "v4l2_h264_accelerator.cc",
+      "v4l2_h264_accelerator.h",
+      "v4l2_h264_accelerator_legacy.cc",
+      "v4l2_h264_accelerator_legacy.h",
+      "v4l2_slice_video_decode_accelerator.cc",
+      "v4l2_slice_video_decode_accelerator.h",
+      "v4l2_video_decoder_backend_stateless.cc",
+      "v4l2_video_decoder_backend_stateless.h",
+      "v4l2_vp8_accelerator.cc",
+      "v4l2_vp8_accelerator.h",
+      "v4l2_vp8_accelerator_legacy.cc",
+      "v4l2_vp8_accelerator_legacy.h",
+      "v4l2_vp9_accelerator_chromium.cc",
+      "v4l2_vp9_accelerator_chromium.h",
+      "v4l2_vp9_accelerator_legacy.cc",
+      "v4l2_vp9_accelerator_legacy.h",
+    ]
+  }
+
   libs = [
     "EGL",
     "GLESv2",
   ]
 
-  if (use_v4l2_codec_aml) {
+  if (use_v4l2_codec_aml && !use_v4l2_codec_rpi) {
     sources += [
       "aml_v4l2_device.cc",
       "aml_v4l2_device.h",
diff --git a/src/media/gpu/v4l2/generic_v4l2_device.cc b/src/media/gpu/v4l2/generic_v4l2_device.cc
index 1b8d5f4bf595..69be37883269 100644
--- a/src/media/gpu/v4l2/generic_v4l2_device.cc
+++ b/src/media/gpu/v4l2/generic_v4l2_device.cc
@@ -479,7 +479,11 @@ bool GenericV4L2Device::PostSandboxInitialization() {
 }
 
 void GenericV4L2Device::EnumerateDevicesForType(Type type) {
+#if BUILDFLAG(USE_V4L2_CODEC_RPI)
+  static const std::string kDecoderDevicePattern = "/dev/video1";
+#else
   static const std::string kDecoderDevicePattern = "/dev/video-dec";
+#endif
   static const std::string kEncoderDevicePattern = "/dev/video-enc";
   static const std::string kImageProcessorDevicePattern = "/dev/image-proc";
   static const std::string kJpegDecoderDevicePattern = "/dev/jpeg-dec";
diff --git a/src/media/gpu/v4l2/v4l2_device.cc b/src/media/gpu/v4l2/v4l2_device.cc
index ba587e592472..f2178e03937a 100644
--- a/src/media/gpu/v4l2/v4l2_device.cc
+++ b/src/media/gpu/v4l2/v4l2_device.cc
@@ -25,6 +25,7 @@
 #include "media/base/bind_to_current_loop.h"
 #include "media/base/color_plane_layout.h"
 #include "media/base/video_types.h"
+#include "media/gpu/buildflags.h"
 #include "media/gpu/chromeos/fourcc.h"
 #include "media/gpu/chromeos/platform_video_frame_utils.h"
 #include "media/gpu/macros.h"
@@ -43,8 +44,10 @@ namespace media {
 
 namespace {
 
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
 // Maximum number of requests that can be created.
 constexpr size_t kMaxNumRequests = 32;
+#endif
 
 gfx::Rect V4L2RectToGfxRect(const v4l2_rect& rect) {
   return gfx::Rect(rect.left, rect.top, rect.width, rect.height);
@@ -536,8 +539,10 @@ bool V4L2WritableBufferRef::DoQueue(V4L2RequestRef* request_ref,
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(buffer_data_);
 
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
   if (request_ref && buffer_data_->queue_->SupportsRequests())
     request_ref->ApplyQueueBuffer(&(buffer_data_->v4l2_buffer_));
+#endif
 
   bool queued = buffer_data_->QueueBuffer(std::move(video_frame));
 
@@ -798,7 +803,9 @@ void V4L2WritableBufferRef::SetConfigStore(uint32_t config_store) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(buffer_data_);
 
+#if defined(OS_CHROMEOS)
   buffer_data_->v4l2_buffer_.config_store = config_store;
+#endif
 }
 
 V4L2ReadableBuffer::V4L2ReadableBuffer(const struct v4l2_buffer& v4l2_buffer,
@@ -930,6 +937,7 @@ V4L2Queue::V4L2Queue(scoped_refptr<V4L2Device> dev,
       weak_this_factory_(this) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
   // Check if this queue support requests.
   struct v4l2_requestbuffers reqbufs;
   memset(&reqbufs, 0, sizeof(reqbufs));
@@ -945,6 +953,7 @@ V4L2Queue::V4L2Queue(scoped_refptr<V4L2Device> dev,
     supports_requests_ = true;
     DVLOGF(4) << "Queue supports request API.";
   }
+#endif
 }
 
 V4L2Queue::~V4L2Queue() {
@@ -1470,23 +1479,34 @@ uint32_t V4L2Device::VideoCodecProfileToV4L2PixFmt(VideoCodecProfile profile,
                                                    bool slice_based) {
   if (profile >= H264PROFILE_MIN && profile <= H264PROFILE_MAX) {
     if (slice_based)
+#ifdef V4L2_PIX_FMT_H264_SLICE
       return V4L2_PIX_FMT_H264_SLICE;
+#else
+      /* EMPTY */;
+#endif
     else
       return V4L2_PIX_FMT_H264;
   } else if (profile >= VP8PROFILE_MIN && profile <= VP8PROFILE_MAX) {
     if (slice_based)
+#ifdef V4L2_PIX_FMT_VP8_FRAME
       return V4L2_PIX_FMT_VP8_FRAME;
+#else
+      /* EMPTY */;
+#endif
     else
       return V4L2_PIX_FMT_VP8;
   } else if (profile >= VP9PROFILE_MIN && profile <= VP9PROFILE_MAX) {
     if (slice_based)
+#ifdef V4L2_PIX_FMT_VP9_FRAME
       return V4L2_PIX_FMT_VP9_FRAME;
+#else
+      /* EMPTY */;
+#endif
     else
       return V4L2_PIX_FMT_VP9;
-  } else {
-    DVLOGF(1) << "Unsupported profile: " << GetProfileName(profile);
-    return 0;
   }
+  LOG(ERROR) << "Unknown profile: " << GetProfileName(profile);
+  return 0;
 }
 
 namespace {
@@ -1581,7 +1601,9 @@ std::vector<VideoCodecProfile> V4L2Device::V4L2PixFmtToVideoCodecProfiles(
   std::vector<VideoCodecProfile> profiles;
   switch (pix_fmt) {
     case V4L2_PIX_FMT_H264:
+#ifdef V4L2_PIX_FMT_H264_SLICE
     case V4L2_PIX_FMT_H264_SLICE:
+#endif
       if (!get_supported_profiles(kCodecH264, &profiles)) {
         DLOG(WARNING) << "Driver doesn't support QUERY H264 profiles, "
                       << "use default values, Base, Main, High";
@@ -1593,11 +1615,15 @@ std::vector<VideoCodecProfile> V4L2Device::V4L2PixFmtToVideoCodecProfiles(
       }
       break;
     case V4L2_PIX_FMT_VP8:
+#ifdef V4L2_PIX_FMT_VP8_FRAME
     case V4L2_PIX_FMT_VP8_FRAME:
+#endif
       profiles = {VP8PROFILE_ANY};
       break;
     case V4L2_PIX_FMT_VP9:
+#ifdef V4L2_PIX_FMT_VP9_FRAME
     case V4L2_PIX_FMT_VP9_FRAME:
+#endif
       if (!get_supported_profiles(kCodecVP9, &profiles)) {
         DLOG(WARNING) << "Driver doesn't support QUERY VP9 profiles, "
                       << "use default values, Profile0";
@@ -2056,6 +2082,7 @@ absl::optional<struct v4l2_event> V4L2Device::DequeueEvent() {
   return event;
 }
 
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
 V4L2RequestsQueue* V4L2Device::GetRequestsQueue() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(client_sequence_checker_);
 
@@ -2076,6 +2103,7 @@ V4L2RequestsQueue* V4L2Device::GetRequestsQueue() {
 
   return requests_queue_.get();
 }
+#endif
 
 bool V4L2Device::IsCtrlExposed(uint32_t ctrl_id) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(client_sequence_checker_);
@@ -2101,8 +2129,10 @@ bool V4L2Device::SetExtCtrls(uint32_t ctrl_class,
   ext_ctrls.count = ctrls.size();
   ext_ctrls.controls = &ctrls[0].ctrl;
 
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
   if (request_ref)
     request_ref->ApplyCtrls(&ext_ctrls);
+#endif
 
   const int result = Ioctl(VIDIOC_S_EXT_CTRLS, &ext_ctrls);
   if (result < 0) {
@@ -2163,6 +2193,8 @@ bool V4L2Device::SetGOPLength(uint32_t gop_length) {
   return true;
 }
 
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
+
 class V4L2Request {
  public:
   // Apply the passed controls to the request.
@@ -2439,4 +2471,6 @@ void V4L2RequestsQueue::ReturnRequest(V4L2Request* request) {
     free_requests_.push(request);
 }
 
+#endif
+
 }  //  namespace media
diff --git a/src/media/gpu/v4l2/v4l2_device.h b/src/media/gpu/v4l2/v4l2_device.h
index 50ddba9fa075..606325f7140d 100644
--- a/src/media/gpu/v4l2/v4l2_device.h
+++ b/src/media/gpu/v4l2/v4l2_device.h
@@ -25,6 +25,7 @@
 #include "media/base/video_decoder_config.h"
 #include "media/base/video_frame.h"
 #include "media/base/video_frame_layout.h"
+#include "media/gpu/buildflags.h"
 #include "media/gpu/chromeos/fourcc.h"
 #include "media/gpu/media_gpu_export.h"
 #include "media/gpu/v4l2/buffer_affinity_tracker.h"
@@ -54,6 +55,26 @@
 #define V4L2_PIX_FMT_MM21 v4l2_fourcc('M', 'M', '2', '1')
 #endif
 
+// Missing defines in the 5.4 linux/v4l2-controls.h
+#ifndef V4L2_CID_MPEG_VIDEO_VP8_PROFILE
+#define V4L2_CID_MPEG_VIDEO_VP8_PROFILE                 (V4L2_CID_MPEG_BASE+511)
+enum v4l2_mpeg_video_vp8_profile {
+  V4L2_MPEG_VIDEO_VP8_PROFILE_0 = 0,
+  V4L2_MPEG_VIDEO_VP8_PROFILE_1 = 1,
+  V4L2_MPEG_VIDEO_VP8_PROFILE_2 = 2,
+  V4L2_MPEG_VIDEO_VP8_PROFILE_3 = 3,
+};
+#endif
+#ifndef V4L2_CID_MPEG_VIDEO_VP9_PROFILE
+#define V4L2_CID_MPEG_VIDEO_VP9_PROFILE                 (V4L2_CID_MPEG_BASE+512)
+enum v4l2_mpeg_video_vp9_profile {
+  V4L2_MPEG_VIDEO_VP9_PROFILE_0 = 0,
+  V4L2_MPEG_VIDEO_VP9_PROFILE_1 = 1,
+  V4L2_MPEG_VIDEO_VP9_PROFILE_2 = 2,
+  V4L2_MPEG_VIDEO_VP9_PROFILE_3 = 3,
+};
+#endif
+
 namespace gfx {
 struct NativePixmapPlane;
 }  // namespace gfx
@@ -483,6 +504,7 @@ class MEDIA_GPU_EXPORT V4L2Queue
   DISALLOW_COPY_AND_ASSIGN(V4L2Queue);
 };
 
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
 class V4L2Request;
 
 // Base class for all request related classes.
@@ -591,6 +613,7 @@ class MEDIA_GPU_EXPORT V4L2RequestsQueue {
   SEQUENCE_CHECKER(sequence_checker_);
   DISALLOW_COPY_AND_ASSIGN(V4L2RequestsQueue);
 };
+#endif
 
 class MEDIA_GPU_EXPORT V4L2Device
     : public base::RefCountedThreadSafe<V4L2Device> {
@@ -760,9 +783,11 @@ class MEDIA_GPU_EXPORT V4L2Device
   // Attempt to dequeue a V4L2 event and return it.
   absl::optional<struct v4l2_event> DequeueEvent();
 
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
   // Returns requests queue to get free requests. A null pointer is returned if
   // the queue creation failed or if requests are not supported.
   V4L2RequestsQueue* GetRequestsQueue();
+#endif
 
   // Check whether the V4L2 control with specified |ctrl_id| is supported.
   bool IsCtrlExposed(uint32_t ctrl_id);
@@ -811,8 +836,10 @@ class MEDIA_GPU_EXPORT V4L2Device
   // Indicates whether the request queue creation has been tried once.
   bool requests_queue_creation_called_ = false;
 
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
   // The request queue stores all requests allocated to be used.
   std::unique_ptr<V4L2RequestsQueue> requests_queue_;
+#endif
 
   SEQUENCE_CHECKER(client_sequence_checker_);
 };
diff --git a/src/media/gpu/v4l2/v4l2_video_decode_accelerator.cc b/src/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
index 6ebf5f38b851..5fc885ce74e1 100644
--- a/src/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
+++ b/src/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
@@ -43,6 +43,16 @@
 #include "ui/gl/gl_context.h"
 #include "ui/gl/scoped_binders.h"
 
+
+#if 0
+#undef VLOGF
+#define VLOGF(x) LOG(INFO) << __func__ << ": "
+#undef DVLOGF
+#define DVLOGF(x) LOG(INFO) << __func__ << ": "
+#undef PLOG
+#define PLOG LOG
+#endif
+
 #define NOTIFY_ERROR(x)                      \
   do {                                       \
     VLOGF(1) << "Setting error state:" << x; \
@@ -1175,6 +1185,26 @@ bool V4L2VideoDecodeAccelerator::FlushInputFrame() {
   return (decoder_state_ != kError);
 }
 
+void V4L2VideoDecodeAccelerator::CheckResolutionChangePending() {
+  struct v4l2_format format;
+  gfx::Size visible_size;
+  bool again;
+  GetFormatInfo(&format, &visible_size, &again);
+  gfx::Size new_coded(format.fmt.pix_mp.width, format.fmt.pix_mp.height);
+  if (resolution_change_pending_) {
+    if (coded_size_ == new_coded) {
+      LOG(INFO) << __func__ << ": New resolution " << new_coded.ToString() << " == Old resolution: Cancel change";
+      resolution_change_pending_ = false;
+    }
+  } else {
+    if (coded_size_ != new_coded) {
+      LOG(INFO) << __func__ << ": New resolution " << new_coded.ToString() <<
+        "!= Old resolution: " << coded_size_.ToString() << " Start change";
+      resolution_change_pending_ = true;
+    }
+  }
+}
+
 void V4L2VideoDecodeAccelerator::ServiceDeviceTask(bool event_pending) {
   DVLOGF(4);
   DCHECK(decoder_thread_.task_runner()->BelongsToCurrentThread());
@@ -1198,11 +1228,11 @@ void V4L2VideoDecodeAccelerator::ServiceDeviceTask(bool event_pending) {
     return;
   }
 
-  bool resolution_change_pending = false;
+  resolution_change_pending_ = false;
   if (event_pending)
-    resolution_change_pending = DequeueResolutionChangeEvent();
+    resolution_change_pending_ = DequeueResolutionChangeEvent();
 
-  if (!resolution_change_pending && coded_size_.IsEmpty()) {
+  if (!resolution_change_pending_ && coded_size_.IsEmpty()) {
     // Some platforms do not send an initial resolution change event.
     // To work around this, we need to keep checking if the initial resolution
     // is known already by explicitly querying the format after each decode,
@@ -1215,11 +1245,16 @@ void V4L2VideoDecodeAccelerator::ServiceDeviceTask(bool event_pending) {
     gfx::Size visible_size;
     bool again;
     if (GetFormatInfo(&format, &visible_size, &again) && !again) {
-      resolution_change_pending = true;
+      resolution_change_pending_ = true;
       DequeueResolutionChangeEvent();
     }
   }
 
+  if (resolution_change_pending_) {
+    LOG(INFO) << "Resolution change pending";
+    CheckResolutionChangePending();
+  }
+
   Dequeue();
   Enqueue();
 
@@ -1261,7 +1296,7 @@ void V4L2VideoDecodeAccelerator::ServiceDeviceTask(bool event_pending) {
             << buffers_at_client_.size() << "]";
 
   ScheduleDecodeBufferTaskIfNeeded();
-  if (resolution_change_pending)
+  if (resolution_change_pending_)
     StartResolutionChange();
 }
 
@@ -1544,8 +1579,11 @@ bool V4L2VideoDecodeAccelerator::EnqueueOutputRecord(
   }
 
   if (!ret) {
-    LOG(ERROR) << "Error in Dequeue output buffer";
-    NOTIFY_ERROR(PLATFORM_FAILURE);
+    CheckResolutionChangePending();
+    if (!resolution_change_pending_) {
+      LOG(ERROR) << "Error in Enqueue output buffer";
+      NOTIFY_ERROR(PLATFORM_FAILURE);
+    }
     return false;
   }
 
@@ -1704,7 +1742,7 @@ bool V4L2VideoDecodeAccelerator::IsDecoderCmdSupported() {
   memset(&cmd, 0, sizeof(cmd));
   cmd.cmd = V4L2_DEC_CMD_STOP;
   if (device_->Ioctl(VIDIOC_TRY_DECODER_CMD, &cmd) != 0) {
-    VLOGF(2) "V4L2_DEC_CMD_STOP is not supported.";
+    VLOGF(2) << "V4L2_DEC_CMD_STOP is not supported.";
     return false;
   }
 
diff --git a/src/media/gpu/v4l2/v4l2_video_decode_accelerator.h b/src/media/gpu/v4l2/v4l2_video_decode_accelerator.h
index 6dacbdc5bdc9..376734c94693 100644
--- a/src/media/gpu/v4l2/v4l2_video_decode_accelerator.h
+++ b/src/media/gpu/v4l2/v4l2_video_decode_accelerator.h
@@ -271,6 +271,9 @@ class MEDIA_GPU_EXPORT V4L2VideoDecodeAccelerator
                       int32_t picture_buffer_id,
                       EGLImageKHR egl_image);
 
+
+  void CheckResolutionChangePending();
+
   // Service I/O on the V4L2 devices.  This task should only be scheduled from
   // DevicePollTask().  If |event_pending| is true, one or more events
   // on file descriptor are pending.
@@ -573,6 +576,9 @@ class MEDIA_GPU_EXPORT V4L2VideoDecodeAccelerator
   // The number of pictures that are sent to PictureReady and will be cleared.
   int picture_clearing_count_;
 
+  // We've spotted that we need a res change
+  bool resolution_change_pending_;
+
   // Output picture coded size.
   gfx::Size coded_size_;
 
diff --git a/src/media/gpu/v4l2/v4l2_video_decoder.cc b/src/media/gpu/v4l2/v4l2_video_decoder.cc
index b9a93a02a223..d5ac69a66f16 100644
--- a/src/media/gpu/v4l2/v4l2_video_decoder.cc
+++ b/src/media/gpu/v4l2/v4l2_video_decoder.cc
@@ -14,12 +14,15 @@
 #include "media/base/limits.h"
 #include "media/base/video_types.h"
 #include "media/base/video_util.h"
+#include "media/gpu/buildflags.h"
 #include "media/gpu/chromeos/dmabuf_video_frame_pool.h"
 #include "media/gpu/chromeos/fourcc.h"
 #include "media/gpu/gpu_video_decode_accelerator_helpers.h"
 #include "media/gpu/macros.h"
 #include "media/gpu/v4l2/v4l2_video_decoder_backend_stateful.h"
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
 #include "media/gpu/v4l2/v4l2_video_decoder_backend_stateless.h"
+#endif
 
 namespace media {
 
@@ -35,8 +38,17 @@ constexpr size_t kNumInputBuffers = 8;
 
 // Input format V4L2 fourccs this class supports.
 constexpr uint32_t kSupportedInputFourccs[] = {
-    V4L2_PIX_FMT_H264_SLICE, V4L2_PIX_FMT_VP8_FRAME, V4L2_PIX_FMT_VP9_FRAME,
-    V4L2_PIX_FMT_H264,       V4L2_PIX_FMT_VP8,       V4L2_PIX_FMT_VP9,
+#ifdef V4L2_PIX_FMT_H264_SLICE
+    V4L2_PIX_FMT_H264_SLICE,
+#endif
+#ifdef V4L2_PIX_FMT_VP8_FRAME
+    V4L2_PIX_FMT_VP8_FRAME,
+#endif
+#ifdef V4L2_PIX_FMT_VP9_FRAME
+    V4L2_PIX_FMT_VP9_FRAME,
+#endif
+    V4L2_PIX_FMT_H264,       V4L2_PIX_FMT_VP8,
+    V4L2_PIX_FMT_VP9,
 };
 
 // Number of output buffers to use for each VD stage above what's required by
@@ -249,12 +261,17 @@ StatusCode V4L2VideoDecoder::InitializeBackend() {
     backend_ = std::make_unique<V4L2StatefulVideoDecoderBackend>(
         this, device_, profile_, decoder_task_runner_);
   } else {
+#if !BUILDFLAG(USE_V4L2_CODEC_RPI)
     DCHECK_EQ(preferred_api_and_format.first, kStateless);
     VLOGF(1) << "Using a stateless API for profile: "
              << GetProfileName(profile_)
              << " and fourcc: " << FourccToString(input_format_fourcc);
     backend_ = std::make_unique<V4L2StatelessVideoDecoderBackend>(
         this, device_, profile_, decoder_task_runner_);
+#else
+    VLOGF(1) << "No backend capable of taking this profile.";
+    return StatusCode::kV4l2FailedResourceAllocation;
+#endif
   }
 
   if (!backend_->Initialize()) {
diff --git a/src/media/media_options.gni b/src/media/media_options.gni
index 303b2e323d5a..33075d28599f 100644
--- a/src/media/media_options.gni
+++ b/src/media/media_options.gni
@@ -178,7 +178,7 @@ if (is_chromecast) {
   ]
   _default_mojo_media_host = "gpu"
 } else if (is_chromeos_ash || is_mac || is_win ||
-           ((is_linux || is_chromeos_lacros) && use_vaapi)) {
+           ((is_linux || is_chromeos_lacros) && (use_vaapi || use_v4l2_codec))) {
   _default_mojo_media_services = [ "video_decoder" ]
   _default_mojo_media_host = "gpu"
 }
diff --git a/src/media/renderers/default_decoder_factory.cc b/src/media/renderers/default_decoder_factory.cc
index 5e242d3623a6..a582d9b51997 100644
--- a/src/media/renderers/default_decoder_factory.cc
+++ b/src/media/renderers/default_decoder_factory.cc
@@ -49,6 +49,10 @@
 #include "media/filters/gav1_video_decoder.h"
 #endif
 
+#if BUILDFLAG(ENABLE_MMAL_VIDEO_DECODER)
+#include "media/filters/mmal_video_decoder.h"
+#endif
+
 namespace media {
 
 DefaultDecoderFactory::DefaultDecoderFactory(
@@ -141,6 +145,8 @@ void DefaultDecoderFactory::CreateVideoDecoders(
     const gfx::ColorSpace& target_color_space,
     std::vector<std::unique_ptr<VideoDecoder>>* video_decoders) {
   base::AutoLock auto_lock(shutdown_lock_);
+  bool has_external_decoders = false;
+
   if (is_shutdown_)
     return;
 
@@ -153,6 +159,8 @@ void DefaultDecoderFactory::CreateVideoDecoders(
   // accelerated.
   if (external_decoder_factory_ && gpu_factories &&
       gpu_factories->IsGpuVideoAcceleratorEnabled()) {
+    const size_t decoder_count = video_decoders->size();
+
     // |gpu_factories_| requires that its entry points be called on its
     // |GetTaskRunner()|. Since |pipeline_| will own decoders created from the
     // factories, require that their message loops are identical.
@@ -161,6 +169,9 @@ void DefaultDecoderFactory::CreateVideoDecoders(
     external_decoder_factory_->CreateVideoDecoders(
         task_runner, gpu_factories, media_log,
         std::move(request_overlay_info_cb), target_color_space, video_decoders);
+
+    if (video_decoders->size() > decoder_count)
+      has_external_decoders = true;
   }
 
 #if defined(OS_FUCHSIA)
@@ -184,6 +195,11 @@ void DefaultDecoderFactory::CreateVideoDecoders(
   }
 #endif
 
+#if BUILDFLAG(ENABLE_MMAL_VIDEO_DECODER)
+  if (!has_external_decoders)
+    video_decoders->push_back(std::make_unique<MmalVideoDecoder>(gpu_factories));
+#endif
+
 #if BUILDFLAG(ENABLE_LIBVPX)
   video_decoders->push_back(std::make_unique<OffloadingVpxVideoDecoder>());
 #endif
diff --git a/src/media/renderers/video_renderer_impl.cc b/src/media/renderers/video_renderer_impl.cc
index 83497d5bdd27..75fea76450cf 100644
--- a/src/media/renderers/video_renderer_impl.cc
+++ b/src/media/renderers/video_renderer_impl.cc
@@ -289,6 +289,12 @@ base::TimeDelta VideoRendererImpl::GetPreferredRenderInterval() {
   return algorithm_->average_frame_duration();
 }
 
+void VideoRendererImpl::TryResizeFrame(uint32_t width, uint32_t height)
+{
+  base::AutoLock auto_lock(lock_);
+  video_decoder_stream_->TryResizeFrame(width, height);
+}
+
 void VideoRendererImpl::OnVideoDecoderStreamInitialized(bool success) {
   DCHECK(task_runner_->BelongsToCurrentThread());
   base::AutoLock auto_lock(lock_);
diff --git a/src/media/renderers/video_renderer_impl.h b/src/media/renderers/video_renderer_impl.h
index 00c4d08743f7..a86b5276d079 100644
--- a/src/media/renderers/video_renderer_impl.h
+++ b/src/media/renderers/video_renderer_impl.h
@@ -91,6 +91,7 @@ class MEDIA_EXPORT VideoRendererImpl
                                    RenderingMode rendering_mode) override;
   void OnFrameDropped() override;
   base::TimeDelta GetPreferredRenderInterval() override;
+  void TryResizeFrame(uint32_t width, uint32_t height) override;
 
  private:
   // Callback for |video_decoder_stream_| initialization.
diff --git a/src/media/renderers/video_resource_updater.cc b/src/media/renderers/video_resource_updater.cc
index f8af767fb275..e72e321bcce9 100644
--- a/src/media/renderers/video_resource_updater.cc
+++ b/src/media/renderers/video_resource_updater.cc
@@ -41,9 +41,11 @@
 #include "gpu/command_buffer/client/shared_image_interface.h"
 #include "gpu/command_buffer/common/shared_image_trace_utils.h"
 #include "gpu/command_buffer/common/shared_image_usage.h"
+#include "media/base/bind_to_current_loop.h"
 #include "media/base/video_frame.h"
 #include "media/renderers/paint_canvas_video_renderer.h"
 #include "media/video/half_float_maker.h"
+#include "mojo/public/cpp/system/platform_handle.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "third_party/khronos/GLES2/gl2ext.h"
 #include "third_party/khronos/GLES3/gl3.h"
@@ -101,6 +103,12 @@ VideoFrameResourceType ExternalResourceTypeForHardwarePlanes(
                               : gfx::BufferFormat::RGBA_1010102;
       return VideoFrameResourceType::RGB;
     case PIXEL_FORMAT_I420:
+      if (num_textures == 1 && target == GL_TEXTURE_EXTERNAL_OES)
+      {
+        buffer_formats[0] = gfx::BufferFormat::YVU_420;
+        return VideoFrameResourceType::STREAM_TEXTURE;
+      }
+
       DCHECK_EQ(num_textures, 3);
       buffer_formats[0] = gfx::BufferFormat::R_8;
       buffer_formats[1] = gfx::BufferFormat::R_8;
@@ -143,6 +151,9 @@ VideoFrameResourceType ExternalResourceTypeForHardwarePlanes(
       NOTREACHED();
       FALLTHROUGH;
     case PIXEL_FORMAT_YV12:
+      if (num_textures == 1 && target == GL_TEXTURE_EXTERNAL_OES)
+        return VideoFrameResourceType::STREAM_TEXTURE;
+      break;
     case PIXEL_FORMAT_I422:
     case PIXEL_FORMAT_I444:
     case PIXEL_FORMAT_I420A:
@@ -264,6 +275,7 @@ class VideoResourceUpdater::PlaneResource {
 
   // Casts |this| to SoftwarePlaneResource for software compositing.
   SoftwarePlaneResource* AsSoftware();
+  SoftwarePlaneVideoFrameResource* AsVideoFrame();
 
   // Casts |this| to HardwarePlaneResource for GPU compositing.
   HardwarePlaneResource* AsHardware();
@@ -278,12 +290,17 @@ class VideoResourceUpdater::PlaneResource {
   // Sets the unique identifiers for this resource, may only be called when
   // there is a single reference to the resource (i.e. |ref_count_| == 1).
   void SetUniqueId(int unique_frame_id, size_t plane_index) {
-    DCHECK_EQ(ref_count_, 1);
+// Is called in child constructor when ref_count == 0
+//    DCHECK_EQ(ref_count_, 1);
     plane_index_ = plane_index;
     unique_frame_id_ = unique_frame_id;
     has_unique_frame_id_and_plane_index_ = true;
   }
 
+  virtual bool kill_me() const {  // Recycle wanted ASAP - VideoFrames want to be kiled when refs hit zero
+    return false;
+  }
+
   // Accessors for resource identifiers provided at construction time.
   uint32_t plane_resource_id() const { return plane_resource_id_; }
   const gfx::Size& resource_size() const { return resource_size_; }
@@ -294,6 +311,8 @@ class VideoResourceUpdater::PlaneResource {
   void remove_ref() { --ref_count_; }
   void clear_refs() { ref_count_ = 0; }
   bool has_refs() const { return ref_count_ != 0; }
+  virtual bool overlay_candidate() const { return false; }
+  virtual uint32_t stride() const { return 0; }
 
  private:
   const uint32_t plane_resource_id_;
@@ -317,16 +336,43 @@ class VideoResourceUpdater::PlaneResource {
 
 class VideoResourceUpdater::SoftwarePlaneResource
     : public VideoResourceUpdater::PlaneResource {
+ protected:
+  viz::SharedBitmapReporter* const shared_bitmap_reporter_;
+  const viz::SharedBitmapId shared_bitmap_id_;
+
  public:
   SoftwarePlaneResource(uint32_t plane_resource_id,
+                const gfx::Size& resource_size,
+                const viz::SharedBitmapId& shared_bitmap,
+                viz::SharedBitmapReporter* const shared_bitmap_reporter)
+      : PlaneResource(plane_resource_id, resource_size, viz::ResourceFormat::RGBA_8888, true),
+        shared_bitmap_reporter_(shared_bitmap_reporter),
+        shared_bitmap_id_(shared_bitmap)
+  {
+  }
+
+  ~SoftwarePlaneResource() override {
+  }
+
+  const viz::SharedBitmapId& shared_bitmap_id() const {
+    return shared_bitmap_id_;
+  }
+
+  virtual void* pixels() = 0;
+
+  // Returns a memory dump GUID consistent across processes.
+  virtual base::UnguessableToken GetSharedMemoryGuid() const = 0;
+};
+
+class VideoResourceUpdater::SoftwarePlaneBitmapResource
+    : public VideoResourceUpdater::SoftwarePlaneResource {
+ public:
+  SoftwarePlaneBitmapResource(uint32_t plane_resource_id,
                         const gfx::Size& size,
                         viz::SharedBitmapReporter* shared_bitmap_reporter)
-      : PlaneResource(plane_resource_id,
-                      size,
-                      viz::ResourceFormat::RGBA_8888,
-                      /*is_software=*/true),
-        shared_bitmap_reporter_(shared_bitmap_reporter),
-        shared_bitmap_id_(viz::SharedBitmap::GenerateId()) {
+      : SoftwarePlaneResource(plane_resource_id, size,
+                              viz::SharedBitmap::GenerateId(), shared_bitmap_reporter)
+  {
     DCHECK(shared_bitmap_reporter_);
 
     // Allocate SharedMemory and notify display compositor of the allocation.
@@ -337,28 +383,91 @@ class VideoResourceUpdater::SoftwarePlaneResource
     shared_bitmap_reporter_->DidAllocateSharedBitmap(std::move(shm.region),
                                                      shared_bitmap_id_);
   }
-  ~SoftwarePlaneResource() override {
+
+  ~SoftwarePlaneBitmapResource() override {
     shared_bitmap_reporter_->DidDeleteSharedBitmap(shared_bitmap_id_);
   }
 
   const viz::SharedBitmapId& shared_bitmap_id() const {
     return shared_bitmap_id_;
   }
-  void* pixels() { return shared_mapping_.memory(); }
+  void* pixels() override { return shared_mapping_.memory(); }
 
   // Returns a memory dump GUID consistent across processes.
-  base::UnguessableToken GetSharedMemoryGuid() const {
+  base::UnguessableToken GetSharedMemoryGuid() const override {
     return shared_mapping_.guid();
   }
 
  private:
-  viz::SharedBitmapReporter* const shared_bitmap_reporter_;
-  const viz::SharedBitmapId shared_bitmap_id_;
   base::WritableSharedMemoryMapping shared_mapping_;
 
-  DISALLOW_COPY_AND_ASSIGN(SoftwarePlaneResource);
+  DISALLOW_COPY_AND_ASSIGN(SoftwarePlaneBitmapResource);
+};
+
+class VideoResourceUpdater::SoftwarePlaneVideoFrameResource
+    : public VideoResourceUpdater::SoftwarePlaneResource {
+
+  scoped_refptr<VideoFrame> video_frame_;
+
+  static viz::SharedBitmapId make_nz_id(const viz::SharedBitmapId& id) {
+    if (!id.IsZero())
+      return id;
+    return viz::SharedBitmap::GenerateId();
+  }
+
+ public:
+  SoftwarePlaneVideoFrameResource(uint32_t plane_resource_id,
+                        scoped_refptr<VideoFrame> video_frame,
+                        VideoResourceUpdater * const video_resource_updater)
+      : SoftwarePlaneResource(plane_resource_id, video_frame->coded_size(),
+                              make_nz_id(video_frame->GetBitmapId()),
+                              video_resource_updater->shared_bitmap_reporter_),
+        video_frame_(video_frame)
+  {
+    DCHECK(shared_bitmap_reporter_);
+
+    SetUniqueId(video_frame_->unique_id(), 0);
+
+    if (!video_frame->GetBitmapId().IsZero()) {
+      return;
+    }
+
+    // There are native shared memory video frames but those have unsafe
+    // regions and we need an ro region here
+    shared_bitmap_reporter_->DidAllocateSharedBitmap(video_frame_->ro_shm_region()->Duplicate(),
+                                                     shared_bitmap_id_);
+
+    // The updater has a weak pointer factory so use that for generating
+    // the kill closure.
+    // Must however only use weak ptrs on src thread so attach appropriately
+    video_frame_->SetBitmapIdAndKillCB(shared_bitmap_id_,
+                                       BindToCurrentLoop(base::BindOnce(
+                                           &VideoResourceUpdater::DidDeleteSharedBitmap,
+                                           video_resource_updater->weak_ptr_factory_.GetWeakPtr(),
+                                           shared_bitmap_id_)));
+  }
+
+  ~SoftwarePlaneVideoFrameResource() override {}
+
+  void* pixels() override { return video_frame_->data(0); }
+
+  // Returns a memory dump GUID consistent across processes.
+  base::UnguessableToken GetSharedMemoryGuid() const override {
+    return video_frame_->shm_region()->GetGUID();
+  }
+
+  bool kill_me() const override {
+    return !has_refs();
+  }
+
+  bool overlay_candidate() const override { return true; }
+
+  uint32_t stride() const override { return video_frame_->stride(0); }
+
+  DISALLOW_COPY_AND_ASSIGN(SoftwarePlaneVideoFrameResource);
 };
 
+
 class VideoResourceUpdater::HardwarePlaneResource
     : public VideoResourceUpdater::PlaneResource {
  public:
@@ -430,7 +539,7 @@ class VideoResourceUpdater::HardwarePlaneResource
   const gpu::Mailbox& mailbox() const { return mailbox_; }
 
   GLenum texture_target() const { return texture_target_; }
-  bool overlay_candidate() const { return overlay_candidate_; }
+  bool overlay_candidate() const override { return overlay_candidate_; }
 
  private:
   gpu::SharedImageInterface* SharedImageInterface() {
@@ -772,7 +881,7 @@ VideoResourceUpdater::PlaneResource* VideoResourceUpdater::AllocateResource(
   if (software_compositor()) {
     DCHECK_EQ(format, viz::ResourceFormat::RGBA_8888);
 
-    all_resources_.push_back(std::make_unique<SoftwarePlaneResource>(
+    all_resources_.push_back(std::make_unique<SoftwarePlaneBitmapResource>(
         plane_resource_id, plane_size, shared_bitmap_reporter_));
   } else {
     all_resources_.push_back(std::make_unique<HardwarePlaneResource>(
@@ -943,6 +1052,12 @@ VideoFrameExternalResources VideoResourceUpdater::CreateForHardwarePlanes(
   return external_resources;
 }
 
+static bool is_mmal_frame(const scoped_refptr<VideoFrame>& video_frame)
+{
+  return video_frame->format() == PIXEL_FORMAT_MMAL_BUFFER &&
+      video_frame->ro_shm_region() != nullptr;
+}
+
 VideoFrameExternalResources VideoResourceUpdater::CreateForSoftwarePlanes(
     scoped_refptr<VideoFrame> video_frame) {
   TRACE_EVENT0("cc", "VideoResourceUpdater::CreateForSoftwarePlanes");
@@ -1028,6 +1143,7 @@ VideoFrameExternalResources VideoResourceUpdater::CreateForSoftwarePlanes(
           return false;
 
         return resource->resource_format() != output_resource_format ||
+               resource->kill_me() ||
                !base::Contains(outplane_plane_sizes, resource->resource_size());
       };
   base::EraseIf(all_resources_, can_delete_resource_fn);
@@ -1035,11 +1151,37 @@ VideoFrameExternalResources VideoResourceUpdater::CreateForSoftwarePlanes(
   // Recycle or allocate resources for each video plane.
   std::vector<PlaneResource*> plane_resources;
   plane_resources.reserve(output_plane_count);
-  for (size_t i = 0; i < output_plane_count; ++i) {
-    plane_resources.push_back(RecycleOrAllocateResource(
-        outplane_plane_sizes[i], output_resource_format, output_color_space,
-        video_frame->unique_id(), i));
-    plane_resources.back()->add_ref();
+  if (software_compositor() &&
+      is_mmal_frame(video_frame))
+  {
+//    LOG(INFO) << "Looking for id " << video_frame->unique_id();
+
+    // Check we don't already have unique_id.... Reuse if we do
+    PlaneResource* vf_resource = nullptr;
+    for (auto& resource : all_resources_) {
+      if (resource->Matches(video_frame->unique_id(), 0)) {
+        vf_resource = resource.get();
+        break;
+      }
+    }
+    // Build a new one if we don't
+    if (vf_resource == nullptr) {
+      all_resources_.push_back(std::make_unique<SoftwarePlaneVideoFrameResource>(
+         next_plane_resource_id_++, video_frame, this));
+      vf_resource = all_resources_.back().get();
+    }
+
+    plane_resources.push_back(vf_resource);
+    vf_resource->add_ref();
+  }
+  else
+  {
+    for (size_t i = 0; i < output_plane_count; ++i) {
+      plane_resources.push_back(RecycleOrAllocateResource(
+          outplane_plane_sizes[i], output_resource_format, output_color_space,
+          video_frame->unique_id(), i));
+      plane_resources.back()->add_ref();
+    }
   }
 
   VideoFrameExternalResources external_resources;
@@ -1082,19 +1224,30 @@ VideoFrameExternalResources VideoResourceUpdater::CreateForSoftwarePlanes(
                                media::kNoTransformation, nullptr);
       } else {
         HardwarePlaneResource* hardware_resource = plane_resource->AsHardware();
-        size_t bytes_per_row = viz::ResourceSizes::CheckedWidthInBytes<size_t>(
-            video_frame->coded_size().width(), output_resource_format);
-        size_t needed_size = bytes_per_row * video_frame->coded_size().height();
-        if (upload_pixels_size_ < needed_size) {
-          // Free the existing data first so that the memory can be reused,
-          // if possible. Note that the new array is purposely not initialized.
-          upload_pixels_.reset();
-          upload_pixels_.reset(new uint8_t[needed_size]);
-          upload_pixels_size_ = needed_size;
+        uint8_t * pixel_data;
+
+        // No point in converting if already ARGB or XRGB
+        if (video_frame->format() != PIXEL_FORMAT_ARGB &&
+            video_frame->format() != PIXEL_FORMAT_XRGB) {
+          size_t bytes_per_row = viz::ResourceSizes::CheckedWidthInBytes<size_t>(
+              video_frame->coded_size().width(), output_resource_format);
+          size_t needed_size = bytes_per_row * video_frame->coded_size().height();
+          if (upload_pixels_size_ < needed_size) {
+            // Free the existing data first so that the memory can be reused,
+            // if possible. Note that the new array is purposely not initialized.
+            upload_pixels_.reset();
+            upload_pixels_.reset(new uint8_t[needed_size]);
+            upload_pixels_size_ = needed_size;
+          }
+
+          pixel_data = upload_pixels_.get();
+          PaintCanvasVideoRenderer::ConvertVideoFrameToRGBPixels(
+              video_frame.get(), pixel_data, bytes_per_row);
+        }
+        else
+        {
+          pixel_data = video_frame->data(0);
         }
-
-        PaintCanvasVideoRenderer::ConvertVideoFrameToRGBPixels(
-            video_frame.get(), upload_pixels_.get(), bytes_per_row);
 
         // Copy pixels into texture.
         auto* gl = ContextGL();
@@ -1106,7 +1259,7 @@ VideoFrameExternalResources VideoResourceUpdater::CreateForSoftwarePlanes(
           gl->TexSubImage2D(
               hardware_resource->texture_target(), 0, 0, 0, plane_size.width(),
               plane_size.height(), GLDataFormat(output_resource_format),
-              GLDataType(output_resource_format), upload_pixels_.get());
+              GLDataType(output_resource_format), pixel_data);
         }
       }
       plane_resource->SetUniqueId(video_frame->unique_id(), 0);
@@ -1120,6 +1273,8 @@ VideoFrameExternalResources VideoResourceUpdater::CreateForSoftwarePlanes(
           software_resource->shared_bitmap_id(),
           software_resource->resource_size(),
           plane_resource->resource_format());
+      transferable_resource.is_overlay_candidate = software_resource->overlay_candidate();
+      transferable_resource.stride = software_resource->stride();
     } else {
       HardwarePlaneResource* hardware_resource = plane_resource->AsHardware();
       external_resources.type = VideoFrameResourceType::RGBA;
@@ -1342,6 +1497,11 @@ void VideoResourceUpdater::DestroyMailbox(gpu::Mailbox mailbox,
   video_frame->UpdateReleaseSyncToken(&client);
 }
 
+// Shim to reporter - useful for callback generation
+void VideoResourceUpdater::DidDeleteSharedBitmap(const viz::SharedBitmapId& id) const {
+  shared_bitmap_reporter_->DidDeleteSharedBitmap(id);
+}
+
 void VideoResourceUpdater::RecycleResource(uint32_t plane_resource_id,
                                            const gpu::SyncToken& sync_token,
                                            bool lost_resource) {
diff --git a/src/media/renderers/video_resource_updater.h b/src/media/renderers/video_resource_updater.h
index d2ad861f59a8..6fe979399c74 100644
--- a/src/media/renderers/video_resource_updater.h
+++ b/src/media/renderers/video_resource_updater.h
@@ -138,6 +138,8 @@ class MEDIA_EXPORT VideoResourceUpdater
   class PlaneResource;
   class HardwarePlaneResource;
   class SoftwarePlaneResource;
+  class SoftwarePlaneBitmapResource;
+  class SoftwarePlaneVideoFrameResource;
 
   // A resource that will be embedded in a DrawQuad in the next CompositorFrame.
   // Each video plane will correspond to one FrameResource.
@@ -204,6 +206,8 @@ class MEDIA_EXPORT VideoResourceUpdater
                       const gpu::SyncToken& sync_token,
                       bool lost_resource);
 
+  void DidDeleteSharedBitmap(const viz::SharedBitmapId& id) const;
+
   // base::trace_event::MemoryDumpProvider implementation.
   bool OnMemoryDump(const base::trace_event::MemoryDumpArgs& args,
                     base::trace_event::ProcessMemoryDump* pmd) override;
diff --git a/src/media/video/gpu_memory_buffer_video_frame_pool.cc b/src/media/video/gpu_memory_buffer_video_frame_pool.cc
index a5327db33cee..8cf23dbb4d26 100644
--- a/src/media/video/gpu_memory_buffer_video_frame_pool.cc
+++ b/src/media/video/gpu_memory_buffer_video_frame_pool.cc
@@ -653,6 +653,11 @@ void GpuMemoryBufferVideoFramePool::PoolImpl::CreateHardwareFrame(
 #endif
 
   bool passthrough = false;
+
+  // Copy isn't going to work if frame not mappable!
+  if (!video_frame->IsMappable())
+    passthrough = true;
+
 #if defined(OS_MAC)
   if (!IOSurfaceCanSetColorSpace(video_frame->ColorSpace()))
     passthrough = true;
diff --git a/src/pi-util/BUILD.txt b/src/pi-util/BUILD.txt
new file mode 100644
index 000000000000..798b99746406
--- /dev/null
+++ b/src/pi-util/BUILD.txt
@@ -0,0 +1,250 @@
+Build notes (cross compile from Ubuntu)
+=======================================
+
+Build from a patch
+------------------
+
+# Pick somewhere to put this
+cd ~
+mkdir chromium
+cd chromium
+# Get the build tools & put on path
+# You may want to add the path in .bashrc
+git clone https://chromium.googlesource.com/chromium/tools/depot_tools
+export PATH=$PATH:`pwd`/depot_tools
+# Get the main tree
+fetch chromium
+cd src
+# Checkout the version you want
+# * Fix version number
+git checkout 55.0.2883.99
+# Fix up any missing dependancies on the build m/c
+# * may well be unnecessary if you have built any other chrome
+./build/install-build-deps.sh
+./build/install-build-deps.sh --arm
+# Fetch & pull the other bits of the tree to sync.
+# As we are checking out a tag the --with_branch_heads is important
+gclient sync --with_branch_heads
+# Patch - should be completely clean if everything matchs
+# * Fix patch file to correct name / location
+cd ..
+patch -p1 < v55.0.2883.99.patch
+cd src
+# * Get a sysroot from somewhere and put it in build/linux/raspian_jessie_pi1-sysroot
+# * Example below is only if you have got an appropriate one lying around
+# * Otherwise follow sysroot instructions further down
+rsync -rl previous_location/raspian_jessie_pi1-sysroot build/linux/
+# Build output directories (out/armv6, out/armv7)
+# * This script currently assumes a sysroot of build/linux/raspian_jessie_pi1-sysroot
+#   so may need editing if you have put it elsewhere
+pi-util/gngen.py
+# Build chrome
+ninja -C out/armv6 chrome chrome_sandbox
+# Build armv7 ffmpeg
+ninja -C out/armv7 third_party/ffmpeg
+
+
+To run on a Pi
+--------------
+
+This requires a little installation.  The sandbox and ffmpeg shared libs
+need to be copied to the pi.  As neither is being tweaked much by me these
+steps should only be required if the underlying Chrome changes.  Otherwise
+you can just run out of the build directory (src/out/armv6)
+
+Assuming you can mount the build dir from the pi.
+
+# On the Pi NOT the build machine
+cd <path to build env>/src
+# Copy the ffmpeg libs
+pi-util/cplibs.sh
+# Copy the sandbox. BUILDTYPE tells the script where to get it from
+# This doesn't seem to be needed anymore with linux 4.9 and chrome 55
+BUILDTYPE=armv6 build/update-linux-sandbox.sh
+# Run chrome
+cd out/armv6
+./chrome
+
+
+Rebuilds
+--------
+
+In most cases a simple "ninja -C out/armv6 chrome" is all that is needed
+and the pi can run from out/armv6.
+
+To clean build "rm -rf out" and follow the build instructions from gngen.py
+
+
+Updating chromium from git
+--------------------------
+
+There is no script for this as the merges are prone to conflicts and it
+is much easier to sort them if you are doing stuff manually.
+
+If updating between major versions then mergeing tends to fail horribly
+so something along the lines of:
+
+# Remember where we are
+cat pi-util/pipaths.py
+OLDTAG=91...
+
+# Look for where we are going
+git tag -l "92.*"
+TAG=92...
+
+# * Make sure there are no updates required and no untracked files
+pi-util/gitscan.py status
+# Set rename limit to huge as files are moved around frequently and getting
+# git to track them is much easier than trying to do it ourselves
+git config diff.renameLimit 1000000
+
+# Tag source & make a patch file - patch file is useful when files are moved
+# as then git goes all unhelpful
+pi-util/settag.py -p rpi_1.39
+# As git stash will reset the branch switch to a temp branch 1st
+pi-util/gitscan.py checkout -b stash/91/base
+pi-util/gitscan.py --gitscan-no-src reset {BASE}
+pi-util/gitscan.py --gitscan-no-src stash -u
+pi-util/gitscan.py --gitscan-no-src checkout {BASE}
+
+# Need to do src separately as the stash will lose pi-utils
+git reset $OLDTAG
+git stash -u
+
+git checkout $TAG -b test/92/rpi_1
+
+# Clean out old objects
+rm -rf obj
+# Beware that git clean might kill our sub-repos so so don't do it unless we
+# are sure it won't
+# git clean -dxf
+
+### Do the "get environment" stages of a new build
+./build/install-build-deps.sh
+./build/install-build-deps.sh --arm
+# Fetch & pull the other bits of the tree to sync.
+# As we are checking out a tag the --with_branch_heads is important
+gclient sync -D --with_branch_heads
+
+# Start rebuild
+git stash pop
+
+# Fix pipaths & make new branches (now so we don't forget later)
+sed "s/src_commit=.*/src_commit=\"$TAG\"/" pi-util/pipaths.py | tee t
+mv t pi-util/pipaths.py && git add pi-util/pipaths.py
+chmod 0755 pi-util/*.py pi-util/*.sh
+pi-util/gitscan.py --gitscan-no-src checkout -b test/92/rpi_1
+
+# If running with filemode false then readd pi-util with filemode true
+git config core.filemode true
+git add pi-util
+git config core.filemode false
+
+
+### Fix conflicts (there will be some)
+
+# If building a separated ffmpeg .so (we are not not currrently) then
+# fix chrome major version for ffmpeg .so in pi-util/cplibs.sh and third_party/ffmpeg/BUILD.gn
+
+git commit
+### run through all other dirs we care about doing the same
+### Probably need to fix exec perms on pi-util scripts
+pi-util/syncroot.py <sysroot-ip>:
+pi-util/gngen.py
+### Fix up any new libpackage-dev that we need
+ninja ...
+### Fix up build disasters
+
+
+If updating within a major version mergeing seems to work reliably so my
+preferred method for achieving this goes:
+
+# Make sure everything is committed
+pi-util/gitscan.py status
+# Revert to base chromium checkout for old checkout
+pi-util/gitscan.py --gitscan-no-src checkout {BASE}
+# Merge new version into current base
+git fetch --all
+TAG=<new_tag>
+git merge $TAG
+# Fix conflicts - DEPS always seems to conflict
+git checkout $TAG -- DEPS
+# Update pi-util/pipaths.py to contain the new tag
+# Either commit now or later
+sed "s/src_commit=.*/src_commit=\"$TAG\"/" pi-util/pipaths.py | tee t
+mv t pi-util/pipaths.py && git add pi-util/pipaths.py
+git commit --no-edit
+# Get the rest of the tree
+gclient sync --with_branch_heads
+# Checkout our tree and merge the new base into it
+pi-util/gitscan.py --gitscan-no-src checkout test/92/rpi_1
+pi-util/gitscan.py --gitscan-no-src merge --no-edit {BASE}
+
+and we should be good to go.  At this point you can either clean build or
+not.  Chromes dependancy checks seem remarkably good so a simple build
+works nearly all the time.
+
+# Rebuild from clean
+rm -rf out
+# refetch root (optional)
+pi-util/rootgen.sh
+# Configure
+pi-util/gngen.py
+# Build release armv7 chrome (and any other targets you feel like)
+ninja -C out/armv7-rel chrome
+
+
+Sysroots (one time only)
+------------------------
+
+1st you will need to get the dev files for a bunch of libs on your pi (or
+if you can get the right files by magic on your cross-compile m/c then
+that is good too).  In src/pi-util there is a shell script
+pi-install-dev.sh which lists all the libs I think are needed along with a
+helpful apt-get install so all you should need to do is run it on an
+appropriate pi.
+
+Next the appropriate bits need to be copied to
+build/linux/<sysroot-name>-sysroot. We use raspian_stretch_pi1 as the
+sysroot name in these instructions and in the example script files so you
+might well find it easiest to use the same name too
+
+The script pi-util/syncroot.sh that will copy the needed bits of a root to
+the right place and then fix the full path symlinks to be relative.  It
+uses rsync to copy the files so the src can contain a machine name
+
+pi-util/syncroot.sh my-pi: raspian_stretch_pi1
+
+The "raspian_stretch_pi1" can be omitted and syncroot will choose the current
+default sysroot name.
+
+Beware that there are ~8 rsync statements so if the rsync is operating
+over ssh then you may need to type your password 8 times...  Note also
+that the script appends -sysroot to the given name so don't add that
+yourself!
+
+If the pi root is updated then this script can / should be rerun to update
+the sysroot.
+
+
+
+Other notes on the tree
+-----------------------
+
+The definitive list of expected repos is in pi-util/pipaths.py
+
+The script pi-util/gitscan.py will perform the same git op on all the
+repos that are in use in the current patch set.  It has substitutions
+of {PATH} and {BASE} for the path to the current repo and the chromium
+commit on which the current branch is based
+
+The current dev branch is test/57/mmal_2
+
+Status of optional neon by build file:
+skia/BUILD.gn:                     yes
+build/secondary/third_party/libjpeg_turbo/BUILD.gn: yes
+third_party/libwebp/BUILD.gn:      yes
+third_party/openmax_dl/dl/BUILD.gn unused
+third_party/libyuv/BUILD.gn:       yes
+third_party/libyuv/libyuv.gni:     yes
+third_party/pdfium/skia/BUILD.gn:  unused
diff --git a/src/pi-util/README.txt b/src/pi-util/README.txt
new file mode 100644
index 000000000000..b5523d3301e2
--- /dev/null
+++ b/src/pi-util/README.txt
@@ -0,0 +1,118 @@
+Release notes
+=============
+
+This version should run with gpu-mem=64 with the default switches. Having
+said that this will only allow for 1 stream.  If you are playing >1 stream
+(even transiently) then you will need more (say gpu_mem=128) and you will
+need to set the --mmal-decoders option to the desired max number. The code
+should give up cleanly if it cannot allocate a h/w video decoder and give
+the stream to old-style ffmpeg decode, but as it stands in many cases it
+thinks it has allocated a decoder cleanly only to find that it fails when
+it tries to use it.
+
+Needs a current (buster 2019-06-07+) firmware/userland
+
+There are a few command-line switches - in general you shouldn't use
+them!
+
+
+Decode and resizer options
+--------------------------
+
+--mmal-decode-opaque     Set the decoder to use opaque frames between
+decoder and resizer.  This should be faster than i420 but doesn't work
+with old firmware.  This is the default with newer firmware (>=
+2016-11-01). (see --mmal-decode-i420)
+
+--mmal-decode-i420       Set the decoder to use I420 frames between
+decoder and resizer.  This generates an unnecessary conversion but works
+with all firmware.  This is the default with older firmware (<
+2016-11-01). (see --mmal-decode-opaque)
+
+--mmal-low-delay         Force "low-delay" mode on the decoder pipe.  This
+reduces the number of buffered ES frames before the decoder.  It isn't
+exactly low-delay but is definitely lower than otherwise.  May have a
+slight performance penalty and increase the risk of stuttering.  This mode
+will be automatically set by Chrome for some streams.
+
+--mmal-resize-isp        Use ISP resize rather than resizer.  Is noticably
+faster but requires --mmal-frame-copy or --mmal-zero-copy and newer
+firmware.  This is the default with newer firmware  (>= 2016-11-01) and
+enough gpu memory to support --mmal-frame-copy.
+
+--mmal-resize-resizer    Use resizer rather than ISP. Slower than ISP
+resize but supports older firmware and --mmal-slice-copy which may be
+needed if GPU memory is very limited (as will be the case on a Pi1 with a
+default setup).
+
+--mmal-resize-mode=NEVER|ALWAYS|SMALLER
+Sets resize behaviour.
+  NEVER    Output is the native size of the video
+  ALWAYS   Output allways attempts to match the size of the displayed picture
+           This is normally the fastest mode for SHM-RGB copy
+  SMALLER  Resize to smaller of native & display. This saves memory and is
+           the fastest for EGL output
+
+
+Copy-modes
+----------
+
+--mmal-copy-mode=<copy mode>
+
+This sets the output frame type & mmal->chrome copy mode. Current values
+for <copy mode> are:
+
+slice                   slowest - uses only a small amount of memory
+                        in the resizer
+
+<alloc>-<format>-<copy>
+  <alloc>
+    SHM      Frame allocated from shared memory
+    GPU      Frame allocated from gpu memory
+  <format>
+    YUV      3-plane I420
+    YC       2-plane I420 e.g. NV12
+    RGB      1-plane 4-byte RGBX
+  <copy>
+    COPY     Data copied on the ARM.  This should be slower than DMA but
+             sometimes give more performance at the expense of slightly
+	     higher ARM CPU usage
+    DMA      Data copied by firmware DMA to ARM buffers.
+    ZC       Data put directly into GPU buffer.  Fastest - only works
+             with EGL (needs vcsm-cma).
+
+Currently valid combinations are:
+
+SHM-YUV-DMA
+SHM-YC-DMA
+SHM-RGB-DMA
+SHM-RGB-COPY  Default for non-gpu operation
+GPU-RGB-DMA
+GPU-RGB-ZC
+GPU-YUV-COPY
+GPU-YUV-ZC    Default for EGL operation
+
+
+Misc options
+------------
+
+--enable-logging=stderr This is a standard option for chrome but worth
+noting as the mmal code will print out its interpretation of the command
+line options passed to it along with how much GPU memory it has detected
+and the firmware date.
+
+--pi-patch-version       Print out the versions of Chromium and Pi
+patches.  Chrome will then terminate
+
+--mmal-decoders=<n>      Set the number of mmal decoders we wil try to
+create simultainiously. Default=1. If this number is exceeded then decoder
+init will fail and chrome will fallback to ffmpeg decode.  There is no
+panalty for setting this to a large number if you wish to have "unlimited"
+decoders.  However if it is set too big and there isn't the gpu mem to
+satisfy the requirements of the decode it may fail cleanly and revert to
+software (ffmpeg) decode or init may appear to succeed and decode then
+fails in an undefined manner.
+
+--mmal-frame-buffers=<n> Set the number of gpu "frame" buffers.
+Change with care.
+
diff --git a/src/pi-util/cpbuild.sh b/src/pi-util/cpbuild.sh
new file mode 100755
index 000000000000..f34d8a7a1c5c
--- /dev/null
+++ b/src/pi-util/cpbuild.sh
@@ -0,0 +1,31 @@
+set -e
+if [ "$2" == "" ]; then
+  echo "mkzip <zipname> <out/dir>"
+  exit 1
+fi
+
+BASEDIR=`pwd`
+TMPBASE=$BASEDIR/out/tmp
+TMPDIRNAME=$1
+ZIPFILE=$1.zip
+OUTDIR=$BASEDIR/$2
+
+cd $OUTDIR
+D=$TMPBASE/$TMPDIRNAME
+rm -rf $D
+mkdir -p $D
+
+echo "=== Copying"
+cp -r * $D
+cd $D
+
+echo "=== Clean unwanted"
+find . -name obj -exec rm -rf {} +
+rm -rf gen clang_*
+rm -rf *.TOC *_deps *.zip core-* bin test_* toolchain.ninja third_party tools
+cd $TMPBASE
+
+echo "=== Zipping"
+zip -r -q $ZIPFILE $TMPDIRNAME
+
+echo "=== Done: $TMPBASE/$ZIPFILE"
diff --git a/src/pi-util/cplibs.sh b/src/pi-util/cplibs.sh
new file mode 100755
index 000000000000..8cecc5c36bbf
--- /dev/null
+++ b/src/pi-util/cplibs.sh
@@ -0,0 +1,19 @@
+set -e
+
+FFNAME=libffmpeg_chrome.so.66
+LIBROOT=/usr/lib/arm-linux-gnueabihf
+
+if [ ! -d $LIBROOT ]; then
+  echo Can\'t find $LIBROOT
+  echo Are you sure you are running this on a Pi?
+  exit 1
+fi
+
+echo Copying $FFNAME from armv6/7 to $LIBROOT/...
+
+cp out/armv7/$FFNAME /tmp
+sudo cp /tmp/$FFNAME $LIBROOT/neon/vfp
+cp out/armv6/$FFNAME /tmp
+sudo cp /tmp/$FFNAME $LIBROOT
+
+
diff --git a/src/pi-util/defargs_arm64-bullseye.gn b/src/pi-util/defargs_arm64-bullseye.gn
new file mode 100644
index 000000000000..e0388a9075a2
--- /dev/null
+++ b/src/pi-util/defargs_arm64-bullseye.gn
@@ -0,0 +1,19 @@
+# Build arguments go here. Examples:
+#   is_component_build = true
+#   is_debug = false
+# See "gn args <out_dir> --list" for available build arguments.
+target_cpu = "arm64"
+target_os = "linux"
+
+# We don't actually need this - v4l2 will do better (auto-set by gngen)
+media_use_mmal = false
+
+# Enables screen sharing in hangouts
+enable_hangout_services_extension = true
+
+# We have issues with the lib for this & it is probably for unittest only
+use_gnome_keyring = false
+
+ffmpeg_branding = "Chrome"
+proprietary_codecs = true
+
diff --git a/src/pi-util/defargs_arm64.gn b/src/pi-util/defargs_arm64.gn
new file mode 100644
index 000000000000..13ea78c70c13
--- /dev/null
+++ b/src/pi-util/defargs_arm64.gn
@@ -0,0 +1,21 @@
+# Build arguments go here. Examples:
+#   is_component_build = true
+#   is_debug = false
+# See "gn args <out_dir> --list" for available build arguments.
+target_cpu = "arm64"
+target_os = "linux"
+
+# We don't actually need this - v4l2 will do better (auto-set by gngen)
+media_use_mmal = false
+
+# Enables screen sharing in hangouts
+enable_hangout_services_extension = true
+
+# We have issues with the lib for this & it is probably for unittest only
+use_gnome_keyring = false
+
+ffmpeg_branding = "Chrome"
+proprietary_codecs = true
+
+rtc_pipewire_version = "0.2"
+
diff --git a/src/pi-util/defargs_armv6.gn b/src/pi-util/defargs_armv6.gn
new file mode 100644
index 000000000000..0d4ff490af07
--- /dev/null
+++ b/src/pi-util/defargs_armv6.gn
@@ -0,0 +1,35 @@
+# See "gn args <out_dir> --list" for available build arguments.
+target_cpu = "arm"
+target_os = "linux"
+
+arm_float_abi = "hard"
+arm_use_neon = false
+arm_optionally_use_neon = false
+arm_version = 6
+arm_use_thumb = false
+arm_arch = "armv6z"
+
+media_use_mmal = true
+
+# Separate out so we can have both arm v6 & v7 versions
+#is_component_ffmpeg = true
+
+# tcmalloc doesn't like armv6 by default
+#use_allocator = "none"
+
+rtc_use_pipewire = false
+
+# Could use system libjpeg but go with chromiums version
+# use_system_libjpeg = true
+#use_libjpeg_turbo = true
+
+# We have issues with the lib for this & it is probably for unittest only
+use_gnome_keyring = false
+
+# We want H.264 in ffmpeg
+ffmpeg_branding = "Chrome"
+proprietary_codecs = true
+
+# This crashes the compiler!
+rtc_use_h264 = false
+
diff --git a/src/pi-util/defargs_armv7-bullseye.gn b/src/pi-util/defargs_armv7-bullseye.gn
new file mode 100644
index 000000000000..4fec2d799aeb
--- /dev/null
+++ b/src/pi-util/defargs_armv7-bullseye.gn
@@ -0,0 +1,29 @@
+# Build arguments go here. Examples:
+#   is_component_build = true
+#   is_debug = false
+# See "gn args <out_dir> --list" for available build arguments.
+target_cpu = "arm"
+target_os = "linux"
+
+arm_float_abi = "hard"
+arm_use_neon = true
+# We have lib issues if we enable thumb
+arm_use_thumb = false
+arm_optionally_use_neon = false
+arm_version = 7
+arm_arch = "armv7-a"
+
+media_use_mmal = true
+enable_widevine = true
+
+# Enables screen sharing in hangouts
+enable_hangout_services_extension = true
+
+# We have issues with the lib for this & it is probably for unittest only
+use_gnome_keyring = false
+
+#is_component_ffmpeg = true
+# tcmalloc doesn't like armv6 by default
+#use_allocator = "none"
+ffmpeg_branding = "Chrome"
+proprietary_codecs = true
diff --git a/src/pi-util/defargs_armv7.gn b/src/pi-util/defargs_armv7.gn
new file mode 100644
index 000000000000..01a4a1bac854
--- /dev/null
+++ b/src/pi-util/defargs_armv7.gn
@@ -0,0 +1,30 @@
+# Build arguments go here. Examples:
+#   is_component_build = true
+#   is_debug = false
+# See "gn args <out_dir> --list" for available build arguments.
+target_cpu = "arm"
+target_os = "linux"
+
+arm_float_abi = "hard"
+arm_use_neon = true
+# We have lib issues if we enable thumb
+arm_use_thumb = false
+arm_optionally_use_neon = false
+arm_version = 7
+arm_arch = "armv7-a"
+
+media_use_mmal = true
+enable_widevine = true
+
+# Enables screen sharing in hangouts
+enable_hangout_services_extension = true
+
+# We have issues with the lib for this & it is probably for unittest only
+use_gnome_keyring = false
+rtc_pipewire_version = "0.2"
+
+#is_component_ffmpeg = true
+# tcmalloc doesn't like armv6 by default
+#use_allocator = "none"
+ffmpeg_branding = "Chrome"
+proprietary_codecs = true
diff --git a/src/pi-util/dodiff.py b/src/pi-util/dodiff.py
new file mode 100755
index 000000000000..fb86685eb54f
--- /dev/null
+++ b/src/pi-util/dodiff.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python
+
+import os, sys, string, subprocess
+
+# Local
+import gitscan, pipaths
+
+def doscan(outfile = sys.stdout):
+    revdict = gitscan.revdict()
+
+    cpath = gitscan.basepath()
+
+    for p in pipaths.pipaths:
+        os.chdir(os.path.join(cpath, p))
+        diff = subprocess.check_output(["git", "diff", revdict[p]])
+
+        header = False
+        lines = diff.split("\n")
+        # Remove terminal blank line
+        if lines[-1] == "":
+            lines.pop()
+        for line in lines:
+            if line.startswith("diff --git "):
+                header = True
+            if header:
+                line = string.replace(line, " a/", " a/" + p + "/")
+                line = string.replace(line, " b/", " b/" + p + "/")
+            if line.startswith("+++ "):
+                header = False
+            print >> outfile, line
+
+
+if __name__ == '__main__':
+    doscan()
+
diff --git a/src/pi-util/gitscan.py b/src/pi-util/gitscan.py
new file mode 100755
index 000000000000..0da3aaa25d12
--- /dev/null
+++ b/src/pi-util/gitscan.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python
+
+import os, string, subprocess, sys
+
+# Local
+import pipaths
+
+def revdict():
+    revdict = {'src':pipaths.src_commit}
+    stuff = subprocess.check_output(["gclient", "revinfo"])
+    for line in stuff.split("\n"):
+        pathn = line.find(":")
+        commitn = line.rfind("@")
+        if pathn != -1 and commitn != -1 :
+             revdict[line[:pathn]] = line[commitn+1:]
+    return revdict
+
+def basepath():
+    cpath = os.getcwd()
+    if not cpath.endswith("/src"):
+        raise "CWD doesn't end with /src"
+
+    return cpath[:-4]
+
+def gitscan(args, nosrc = False, quiet=False):
+    rv = 0
+
+    oldcwd = os.getcwd()
+    rdict = revdict()
+    cpath = basepath()
+
+    for p in pipaths.pipaths:
+        if nosrc and p == "src":
+            continue
+
+        os.chdir(os.path.join(cpath, p))
+
+        gitargs = [string.replace(string.replace(a, "{PATH}", p), "{BASE}", rdict[p]) for a in args]
+        gitargs[0:0] = ["git"]
+
+        if not quiet:
+            print ">>>", p
+
+        rv = subprocess.call(gitargs)
+        if rv != 0:
+            if not quiet:
+                print "Git returned non-zero error code", rv, "\ncwd =", os.getcwd(), "\ncmd =", gitargs
+            break
+
+    os.chdir(oldcwd)
+    return rv
+
+
+if __name__ == '__main__':
+
+    if len(sys.argv) < 2:
+        print "Usage: gitscan [--gitscan-no-src] <git cmd>"
+        print "  substitutes {PATH} and {BASE}"
+        exit(0)
+
+    nosrc = False
+
+    if sys.argv[1] == "--gitscan-no-src":
+        nosrc = True
+        del sys.argv[1]
+
+    gitscan(sys.argv[1:], nosrc)
+
+
diff --git a/src/pi-util/gngen.py b/src/pi-util/gngen.py
new file mode 100755
index 000000000000..9c14d145beef
--- /dev/null
+++ b/src/pi-util/gngen.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python
+
+import os, ast, fileinput, subprocess, sys
+
+def docopy(name, vars, is_debug=False, is_ozone=False):
+    dir_suffix = ""
+    deb_str = "false"
+
+    if is_ozone:
+        ozone_str = "true"
+        dir_suffix = dir_suffix + "-ozone"
+    else:
+        ozone_str = "false"
+
+    if is_debug:
+        deb_str = "true"
+        dir_suffix = dir_suffix + "-deb"
+    else:
+        deb_str = "false"
+        dir_suffix = dir_suffix + "-rel"
+
+
+    dest_dir = os.path.join("out", name + dir_suffix)
+    src_file = os.path.join("pi-util", "defargs_" + name + ".gn")
+
+    # Ignore any errors making dir (in particular it already exists)
+    try:
+        os.makedirs(dest_dir)
+    except:
+        pass
+
+    dargs = open(os.path.join(dest_dir, "args.gn"), "wt")
+    dargs.write('# -- copied from: ' + src_file + '\n')
+
+    for line in fileinput.input(src_file):
+        dargs.write(line)
+
+    dargs.write('# -- created by ' + sys.argv[0] + '\n')
+    dargs.write('is_debug = ' + deb_str + '\n')
+    dargs.write('use_ozone = ' + ozone_str + '\n')
+    if is_ozone:
+        dargs.write('ozone_platform_x11 = true\n')
+        dargs.write('use_v4l2_codec = true\n')
+        dargs.write('use_v4l2_codec_rpi = true\n')
+
+    dargs.write('target_sysroot = "' + vars["target_sysroot"] + '"\n')
+    dargs.write('google_api_key = "' + vars["google_api_key"] + '"\n')
+    dargs.write('google_default_client_id = "' + vars["google_default_client_id"] + '"\n')
+    dargs.write('google_default_client_secret = "' + vars["google_default_client_secret"] + '"\n')
+
+    dargs.close()
+
+    subprocess.check_call(["gn", "gen", dest_dir])
+
+
+if __name__ == '__main__':
+    gyp_vars = {}
+    gypi = os.path.join(os.environ["HOME"], ".gyp", "include.gypi")
+    if os.path.isfile(gypi):
+        print "Importing from:", gypi
+        gyps = open(gypi).read(-1)
+        gyp_vars = ast.literal_eval(gyps)["variables"]
+
+    gyp_vars["target_sysroot"] = os.path.abspath("build/linux/pios_buster_arm-sysroot")
+
+    docopy("armv6", gyp_vars, is_ozone=True)
+    docopy("armv7", gyp_vars)
+    docopy("armv7", gyp_vars, is_debug=True)
+    docopy("armv7", gyp_vars, is_ozone=True)
+
+    gyp_vars["target_sysroot"] = os.path.abspath("build/linux/pios_buster_arm64-sysroot")
+
+    docopy("arm64", gyp_vars, is_ozone=True)
+
+    gyp_vars["target_sysroot"] = os.path.abspath("build/linux/pios_bullseye_arm-sysroot")
+
+    docopy("armv7-bullseye", gyp_vars, is_ozone=True)
+
+    gyp_vars["target_sysroot"] = os.path.abspath("build/linux/pios_bullseye_arm64-sysroot")
+
+    docopy("arm64-bullseye", gyp_vars, is_ozone=True)
+
diff --git a/src/pi-util/makeall.sh b/src/pi-util/makeall.sh
new file mode 100755
index 000000000000..5fed29d0d1aa
--- /dev/null
+++ b/src/pi-util/makeall.sh
@@ -0,0 +1,47 @@
+set -e
+
+GET_BUILD_DEPS=
+if [ "$1" == "--build-deps" ]; then
+  GET_BUILD_DEPS=1
+  shift
+fi
+
+if [ "$1" == "" ]; then
+  echo "Usage: $0 [--build-deps] <git tag>"
+  exit 1
+fi
+
+echo === Check all committed
+pi-util/gitscan.py diff --name-status --exit-code
+echo === Reset third party libraries
+pi-util/gitscan.py --gitscan-no-src checkout {BASE}
+TAG=$1
+echo === Fetch chrome
+pi-util/gitscan.py fetch -t --all
+echo === Checkout chrome $TAG
+git checkout $TAG
+if [ ! $GET_BUILD_DEPS ]; then
+  echo === Skip system build dependancies
+else
+  echo === Get system build dependancies
+  build/install-build-deps.sh --arm
+fi
+echo === Sync third party libraries
+gclient sync -D --with_branch_heads
+# Shouldn't need this but the x bit often gets accidentally lost
+# due to core.filemode options
+chmod +x pi-util/*.sh pi-util/*.py
+echo === Checkout third party libraries
+pi-util/gitscan.py --gitscan-no-src checkout $TAG --
+echo === Get pi sysroots
+rm -rf out
+pi-util/rootgen.sh
+echo === Setup gn
+pi-util/gngen.py
+echo === Start build
+ninja -C out/armv7-ozone-rel chrome
+ninja -C out/arm64-ozone-rel chrome
+ninja -C out/armv6-ozone-rel chrome
+
+
+
diff --git a/src/pi-util/mksyspatch.sh b/src/pi-util/mksyspatch.sh
new file mode 100755
index 000000000000..c848b5e00175
--- /dev/null
+++ b/src/pi-util/mksyspatch.sh
@@ -0,0 +1,21 @@
+#!/bin/bash -e
+
+SRC_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && cd .. && pwd )"
+TPATCH=/tmp/sysroot.patch
+PATCHFILE_PIOS=$SRC_DIR/pi-util/sysroot-pios.patch
+PATCHFILE_BUSTER=$SRC_DIR/pi-util/sysroot-buster.patch
+PATCHFILE_BULLSEYE=$SRC_DIR/pi-util/sysroot-bullseye.patch
+echo "Making: $PATCHFILE"
+
+cd $SRC_DIR
+diff -u build/linux/sysroot_scripts/sysroot-{creator,creator-pios}.sh > ${TPATCH} || true
+diff -u build/linux/sysroot_scripts/generate_{debian_archive_unstable,pios}_gpg.sh >> $TPATCH || true
+awk -f pi-util/patch2nd.awk $TPATCH > $PATCHFILE_PIOS
+diff -u build/linux/sysroot_scripts/sysroot-creator-{sid,pios-buster}.sh > $TPATCH || true
+awk -f pi-util/patch2nd.awk $TPATCH > $PATCHFILE_BUSTER
+diff -u build/linux/sysroot_scripts/sysroot-creator-{sid,pios-bullseye}.sh > $TPATCH || true
+awk -f pi-util/patch2nd.awk $TPATCH > $PATCHFILE_BULLSEYE
+
+echo "Done"
+
+
diff --git a/src/pi-util/patch2nd.awk b/src/pi-util/patch2nd.awk
new file mode 100644
index 000000000000..74014a2d074d
--- /dev/null
+++ b/src/pi-util/patch2nd.awk
@@ -0,0 +1,3 @@
+/^\-\-\-/  { next }
+/^\+\+\+/ { $1="---"; print; $1="+++"; }
+{ print }
diff --git a/src/pi-util/pi-install-dev.sh b/src/pi-util/pi-install-dev.sh
new file mode 100755
index 000000000000..4eefca4c04c3
--- /dev/null
+++ b/src/pi-util/pi-install-dev.sh
@@ -0,0 +1,53 @@
+# Install set to build appropriate root on a clean pi
+
+APT=aptitude
+#APT=apt-get
+
+sudo $APT install \
+comerr-dev \
+libasound2-dev \
+libatk1.0-dev \
+libatk-bridge2.0-dev \
+libcap-dev \
+libcups2-dev \
+libexif-dev \
+libffi-dev \
+libgbm-dev \
+libgconf2-dev \
+libgl1-mesa-dev \
+libgles-dev \
+libgtk-3-dev \
+libjpeg-dev \
+libkrb5-dev \
+libnspr4-dev \
+libnss3-dev \
+libpam0g-dev \
+libpango1.0-dev \
+libpci-dev \
+libpcre3-dev \
+libpipewire-0.2-dev \
+libssl-dev \
+libudev-dev \
+libx11-xcb-dev \
+libxcb1-dev \
+libxcb-dri3-dev \
+libxcb-shm0-dev \
+libxcb-image0-dev \
+libxss-dev \
+libxt-dev \
+libxtst-dev \
+mesa-common-dev \
+python-xcbgen \
+uuid-dev \
+xcb-proto
+
+echo Also need python-xcbgen on host
+
+# Pulse (hopefully) disabled
+# libpulse-dev \
+
+# Obviously replace paths appropriately below
+# Now run pi-util/syncroot.sh on the compile m/c to grab the appropriate
+# bits of the root and fix up the paths.
+# e.g. ON COMPILE M/C in src dir:
+# pi-util/syncroot.sh my-pi: raspian_jessie_pi1
diff --git a/src/pi-util/pipaths.py b/src/pi-util/pipaths.py
new file mode 100755
index 000000000000..354cabf01b7a
--- /dev/null
+++ b/src/pi-util/pipaths.py
@@ -0,0 +1,10 @@
+pipaths=[
+    "src",
+    "src/native_client",
+    "src/third_party/ffmpeg",
+    "src/third_party/libyuv",
+    "src/third_party/skia",
+    "src/third_party/webrtc"]
+
+# Our base tag or commit no
+src_commit="92.0.4515.98"
diff --git a/src/pi-util/pipewire_utils_h.patch b/src/pi-util/pipewire_utils_h.patch
new file mode 100644
index 000000000000..433aa8c7fe4c
--- /dev/null
+++ b/src/pi-util/pipewire_utils_h.patch
@@ -0,0 +1,11 @@
+--- a/build/linux/raspian_stretch_pi1-sysroot/usr/include/pipewire/utils.h
++++ b/build/linux/raspian_stretch_pi1-sysroot/usr/include/pipewire/utils.h
+@@ -52,7 +52,7 @@ static inline struct spa_pod *
+ pw_spa_pod_copy(const struct spa_pod *pod)
+ {
+ 	size_t size;
+-	struct spa_pod *c;
++	void *c;
+ 
+ 	if (pod == NULL)
+ 		return NULL;
diff --git a/src/pi-util/rebase_liblinks.py b/src/pi-util/rebase_liblinks.py
new file mode 100755
index 000000000000..6a9a33fce217
--- /dev/null
+++ b/src/pi-util/rebase_liblinks.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python
+
+import os, sys
+from stat import *
+
+def walktree(top, callback, n, prefix):
+    '''recursively descend the directory tree rooted at top,
+       calling the callback function for each regular file'''
+
+    for f in os.listdir(top):
+        pathname = os.path.join(top, f)
+        mode = os.lstat(pathname).st_mode
+        if S_ISDIR(mode):
+            # It's a directory, recurse into it
+            walktree(pathname, callback, n+1, prefix)
+        elif S_ISLNK(mode):
+            # It's a file, call the callback function
+            callback(pathname, os.readlink(pathname), n, prefix)
+
+def visitfile(file, linkname, n, prefix):
+    if (linkname.startswith(prefix + 'lib/')):
+        newlink = "../" * n + linkname[len(prefix):]
+        print 'relinking', file, "->", newlink
+        os.remove(file)
+        os.symlink(newlink, file)
+
+if __name__ == '__main__':
+    argc = len(sys.argv)
+    if argc == 2:
+        walktree(sys.argv[1], visitfile, 0, "/")
+    elif argc == 3:
+        walktree(sys.argv[1], visitfile, 0, sys.argv[2])
+    else:
+        print "rebase_liblinks.py <local root> [<old sysroot>]"
+
+
+
diff --git a/src/pi-util/rootgen.sh b/src/pi-util/rootgen.sh
new file mode 100755
index 000000000000..9ec231381bb6
--- /dev/null
+++ b/src/pi-util/rootgen.sh
@@ -0,0 +1,48 @@
+#!/bin/bash -e
+
+SRC_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && cd .. && pwd )"
+
+NOPATCH=
+if [ "$1" == "--nopatch" ]; then
+  NOPATCH=1
+  shift
+fi
+
+if [ "$1" != "" ]; then
+  echo "Usage: $0 [--nopatch]"
+  exit 1
+fi
+
+if [ ! $NOPATCH ]; then
+  cd $SRC_DIR
+  cp -v build/linux/sysroot_scripts/sysroot-{creator,creator-pios}.sh
+  cp -v build/linux/sysroot_scripts/sysroot-creator-{sid,pios-buster}.sh
+  cp -v build/linux/sysroot_scripts/sysroot-creator-{sid,pios-bullseye}.sh
+  cp -v build/linux/sysroot_scripts/generate_{debian_archive_unstable,pios}_gpg.sh
+  patch -p0 < pi-util/sysroot-pios.patch
+  patch -p0 < pi-util/sysroot-buster.patch
+  patch -p0 < pi-util/sysroot-bullseye.patch
+fi
+
+rm -rf $SRC_DIR/build/linux/sysroot_scripts/pios_archive.gpg $SRC_DIR/build/linux/pios_*-sysroot
+rm -rf $SRC_DIR/out/sysroot-build
+
+cd $SRC_DIR/build/linux/sysroot_scripts
+./generate_pios_gpg.sh
+./sysroot-creator-pios-buster.sh BuildSysrootARM
+./sysroot-creator-pios-buster.sh BuildSysrootARM64
+mkdir -pv ../pios_buster_{arm,arm64}-sysroot
+cd ../pios_buster_arm-sysroot
+bsdtar xf ../../../out/sysroot-build/buster/pios_buster_arm_sysroot.tar.xz
+cd ../pios_buster_arm64-sysroot
+bsdtar xf ../../../out/sysroot-build/buster/pios_buster_arm64_sysroot.tar.xz
+
+cd $SRC_DIR/build/linux/sysroot_scripts
+./sysroot-creator-pios-bullseye.sh BuildSysrootARM
+./sysroot-creator-pios-bullseye.sh BuildSysrootARM64
+mkdir -pv ../pios_bullseye_{arm,arm64}-sysroot
+cd ../pios_bullseye_arm-sysroot
+bsdtar xf ../../../out/sysroot-build/bullseye/pios_bullseye_arm_sysroot.tar.xz
+cd ../pios_bullseye_arm64-sysroot
+bsdtar xf ../../../out/sysroot-build/bullseye/pios_bullseye_arm64_sysroot.tar.xz
+
diff --git a/src/pi-util/settag.py b/src/pi-util/settag.py
new file mode 100755
index 000000000000..d908f6328e04
--- /dev/null
+++ b/src/pi-util/settag.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python
+
+import sys, os, subprocess
+
+# Local
+import pipaths
+import gitscan
+import dodiff
+import argparse
+
+def set_version(verstr):
+    pathname = "components/version_info/pi_patch_version_values.h"
+
+    with open(pathname, "wt") as f:
+        f.write("// Pi patch version - generated by pi-util/settag.py\n")
+        f.write('#define PI_PATCH_VERSION_STRING "' + verstr + '"\n')
+
+    subprocess.check_call(["git", "add", pathname])
+    subprocess.check_call(["git", "commit", "-m", "Update pi patch version to " + verstr])
+
+
+def set_tag(verstr):
+    newtag = "pi/" + pipaths.src_commit + "/" + verstr
+    print "Setting tag: " + newtag
+    if gitscan.gitscan(["tag", newtag], quiet=True) != 0:
+        print "Tagging failed"
+        sys.exit(1)
+
+def set_tag_and_version(verstr):
+    set_version(verstr)
+    set_tag(verstr)
+
+if __name__ == '__main__':
+    argp = argparse.ArgumentParser(
+        description="Sets version info in pi_patch_version_values & tags source tree with it")
+    argp.add_argument("-p", action='store_true', help="Generate patch file")
+    argp.add_argument("verstr", help="Pi patch version string")
+    args = argp.parse_args()
+
+    patchpath = os.path.join("..", "v" + pipaths.src_commit + "_" + args.verstr + ".patch")
+
+    if args.p and os.path.exists(patchpath):
+        print "Patchfile", patchpath, "already exists"
+        sys.exit(1)
+
+    print "-- Checking all committed"
+    if gitscan.gitscan(["diff", "--name-status", "--exit-code"], quiet=True) != 0:
+        print "Status check failed - commit everything and try again"
+        sys.exit(1)
+
+    print "-- Generating & committing pi_patch_version_values.h"
+    set_version(args.verstr)
+    print "-- Generating tags"
+    set_tag(args.verstr)
+
+    if args.p:
+        print "-- Generating patch file: ", patchpath
+        with open(patchpath, "wt") as f:
+            dodiff.doscan(f)
+
diff --git a/src/pi-util/syncroot.sh b/src/pi-util/syncroot.sh
new file mode 100755
index 000000000000..a5f7c3fc1394
--- /dev/null
+++ b/src/pi-util/syncroot.sh
@@ -0,0 +1,70 @@
+set -e
+
+NEEDSVC=1
+TYPE=arm
+API=arm-linux-gnueabihf
+SYSROOT_DEFAULT=pios_buster_arm
+
+if [ "$1" == "--arm64" ]; then
+  shift
+  TYPE=arm64
+  NEEDSVC=
+  API=aarch64-linux-gnu
+  SYSROOT_DEFAULT=pios_buster_arm64
+fi
+
+if [ "$1" == "" ]; then
+  echo Usage: $0 [--arm64] \<src_dir\> [\<rootname\>]
+  echo src_dir is a source for rsync so may contain m/c name.
+  echo rootname will be set to \"pios_buster_arm\" if missing
+  echo e.g.: pi-util/syncroot.sh my-pi:
+  exit 1
+fi
+
+SYSROOT_NAME=$2
+if [ "$SYSROOT_NAME" == "" ]; then
+  SYSROOT_NAME=$SYSROOT_DEFAULT
+fi
+
+DST_ROOT=`gclient root`
+DST=$DST_ROOT/src/build/linux/$SYSROOT_NAME-sysroot
+SRC=$1
+
+if [ ! -d $DST_ROOT/src/build/linux ]; then
+  echo We don\'t appear to be in a Chrome build tree
+  exit 1
+fi
+
+echo Copying root for $TYPE
+echo Sync src:  $SRC
+echo Sync dest: $DST
+
+mkdir -p $DST/lib
+mkdir -p $DST/opt/vc/include
+mkdir -p $DST/usr/lib/pkgconfig
+mkdir -p $DST/usr/bin
+mkdir -p $DST/usr/share
+
+rsync -rl $SRC/lib $DST
+if [ $NEEDSVC ]; then
+  #### MUST NOT include /opt/vc/include/*GL*
+  # Creates conflicts with GL includes inside Chrome
+  rsync -rl $SRC/opt/vc/lib $DST/opt/vc
+  rsync -rl $SRC/opt/vc/include/interface $DST/opt/vc/include
+fi
+rsync -rl --exclude cups/backend $SRC/usr/lib $DST/usr
+rsync -rl $SRC/usr/include $DST/usr
+rsync -rl $SRC/usr/share/pkgconfig $DST/usr/share
+rsync -rl $SRC/usr/share/xcb $DST/usr/share
+rsync -rl $SRC/usr/bin/cups-config $DST/usr/bin
+
+# Fix up pipewire issue
+if [ -e $DST/usr/include/pipewire/utils.h ]; then
+  sed 's/struct spa_pod \*c/void \* c/' < $DST/usr/include/pipewire/utils.h > u.h
+  mv u.h $DST/usr/include/pipewire/utils.h
+fi
+
+cd $DST/usr/lib/pkgconfig
+ln -sf ../$API/pkgconfig/* .
+cd ../../../../../..
+pi-util/rebase_liblinks.py $DST
diff --git a/src/pi-util/sysroot-bullseye.patch b/src/pi-util/sysroot-bullseye.patch
new file mode 100644
index 000000000000..b6b60f998617
--- /dev/null
+++ b/src/pi-util/sysroot-bullseye.patch
@@ -0,0 +1,160 @@
+--- build/linux/sysroot_scripts/sysroot-creator-pios-bullseye.sh 2021-06-21 10:28:27.370910473 +0100
++++ build/linux/sysroot_scripts/sysroot-creator-pios-bullseye.sh 2021-06-21 10:28:27.370910473 +0100
+@@ -5,8 +5,8 @@
+ 
+ SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+ 
+-DISTRO=debian
+-DIST=sid
++DISTRO=pios
++DIST=bullseye
+ 
+ # Keep the "experimental" repo before the "sid" repo.  There are some packages
+ # that are currently only available in experimental like libgtk-4-1, but if it
+@@ -18,22 +18,34 @@
+ # libgnome-keyring-dev which has since been deprecated and removed from sid.
+ # It will be needed until gnome keyring is removed (http://crbug.com/466975 and
+ # http://crbug.com/355223).
+-ARCHIVE_URL="https://snapshot.debian.org/archive/debian"
+-ARCHIVE_TIMESTAMP=20210309T203820Z
+-APT_SOURCES_LIST="${ARCHIVE_URL}/${ARCHIVE_TIMESTAMP}/ stretch main
+-${ARCHIVE_URL}/${ARCHIVE_TIMESTAMP}/ experimental main
+-${ARCHIVE_URL}/${ARCHIVE_TIMESTAMP}/ sid main"
++ARCHIVE_TIMESTAMP=latest
++
++if [ "$1" = "BuildSysrootARM" ]; then
++    ARCHIVE_URL="http://snapshot.raspbian.org/"
++    APT_SOURCES_LIST="${ARCHIVE_URL}/${ARCHIVE_TIMESTAMP}/raspbian/ $DIST main contrib non-free rpi
++http://archive.raspberrypi.org/debian/ $DIST main"
++    HAS_ARCH_ARM=1
++    HAS_ARCH_ARM64=0
++elif [ "$1" = "BuildSysrootARM64" ]; then
++    ARCHIVE_URL="http://deb.debian.org/debian/"
++    APT_SOURCES_LIST="${ARCHIVE_URL} $DIST main contrib non-free
++http://deb.debian.org/debian $DIST-updates main contrib non-free
++http://archive.raspberrypi.org/debian/ $DIST main"
++    HAS_ARCH_ARM=0
++    HAS_ARCH_ARM64=1
++else
++    echo "Please run with either BuildSysrootARM64 or BuildSysrootARM"
++    exit 1
++fi
+ 
+ # gpg keyring file generated using generate_debian_archive_unstable.sh
+-KEYRING_FILE="${SCRIPT_DIR}/debian_archive_unstable.gpg"
++KEYRING_FILE="${SCRIPT_DIR}/pios_archive.gpg"
+ 
+-HAS_ARCH_AMD64=1
+-HAS_ARCH_I386=1
+-HAS_ARCH_ARM=1
+-HAS_ARCH_ARM64=1
+-HAS_ARCH_ARMEL=1
+-HAS_ARCH_MIPS=1
+-HAS_ARCH_MIPS64EL=1
++HAS_ARCH_AMD64=0
++HAS_ARCH_I386=0
++HAS_ARCH_ARMEL=0
++HAS_ARCH_MIPS=0
++HAS_ARCH_MIPS64EL=0
+ 
+ # Sysroot packages: these are the packages needed to build chrome.
+ # NOTE: When DEBIAN_PACKAGES is modified, the packagelist files must be updated
+@@ -41,10 +53,6 @@
+ DEBIAN_PACKAGES="\
+   comerr-dev
+   krb5-multidev
+-  libappindicator-dev
+-  libappindicator1
+-  libappindicator3-1
+-  libappindicator3-dev
+   libasound2
+   libasound2-dev
+   libasyncns0
+@@ -113,7 +121,6 @@
+   libexpat1
+   libexpat1-dev
+   libffi-dev
+-  libffi6
+   libffi7
+   libflac-dev
+   libflac8
+@@ -126,7 +133,7 @@
+   libgbm-dev
+   libgbm1
+   libgcc-10-dev
+-  libgcc1
++  libgcc-s1
+   libgcrypt20
+   libgcrypt20-dev
+   libgdk-pixbuf-2.0-0
+@@ -146,8 +153,6 @@
+   libglx-dev
+   libglx0
+   libgmp10
+-  libgnome-keyring-dev
+-  libgnome-keyring0
+   libgnutls-dane0
+   libgnutls-openssl27
+   libgnutls28-dev
+@@ -177,8 +182,6 @@
+   libidl-2-0
+   libidn11
+   libidn2-0
+-  libindicator3-7
+-  libindicator7
+   libinput-dev
+   libinput10
+   libjbig0
+@@ -240,7 +243,6 @@
+   libpcre2-32-0
+   libpcre2-8-0
+   libpcre2-dev
+-  libpcre2-posix0
+   libpcre2-posix2
+   libpcre3
+   libpcre3-dev
+@@ -384,10 +386,7 @@
+   speech-dispatcher
+   uuid-dev
+   wayland-protocols
+-  x11proto-composite-dev
+-  x11proto-damage-dev
+   x11proto-dev
+-  x11proto-fixes-dev
+   x11proto-input-dev
+   x11proto-kb-dev
+   x11proto-randr-dev
+@@ -426,9 +425,9 @@
+   libdrm-freedreno1
+   libdrm-omap1
+   libdrm-tegra0
+-  libgtk-4-1
+-  libgtk-4-dev
+   libubsan1
++  libraspberrypi0
++  libraspberrypi-dev
+ "
+ 
+ DEBIAN_PACKAGES_ARM64="
+@@ -437,13 +436,13 @@
+   libdrm-freedreno1
+   libdrm-tegra0
+   libgmp10
+-  libgtk-4-1
+-  libgtk-4-dev
+   libitm1
+   liblsan0
+   libthai0
+   libtsan0
+   libubsan1
++  libraspberrypi0
++  libraspberrypi-dev
+ "
+ 
+ DEBIAN_PACKAGES_ARMEL="
+@@ -460,4 +459,4 @@
+ DEBIAN_PACKAGES_MIPS64EL="
+ "
+ 
+-. "${SCRIPT_DIR}/sysroot-creator.sh"
++. "${SCRIPT_DIR}/sysroot-creator-pios.sh"
diff --git a/src/pi-util/sysroot-buster.patch b/src/pi-util/sysroot-buster.patch
new file mode 100644
index 000000000000..ef19dae57e66
--- /dev/null
+++ b/src/pi-util/sysroot-buster.patch
@@ -0,0 +1,268 @@
+--- build/linux/sysroot_scripts/sysroot-creator-pios-buster.sh 2021-06-18 12:31:18.605837770 +0100
++++ build/linux/sysroot_scripts/sysroot-creator-pios-buster.sh 2021-06-18 12:31:18.605837770 +0100
+@@ -5,8 +5,8 @@
+ 
+ SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+ 
+-DISTRO=debian
+-DIST=sid
++DISTRO=pios
++DIST=buster
+ 
+ # Keep the "experimental" repo before the "sid" repo.  There are some packages
+ # that are currently only available in experimental like libgtk-4-1, but if it
+@@ -18,22 +18,35 @@
+ # libgnome-keyring-dev which has since been deprecated and removed from sid.
+ # It will be needed until gnome keyring is removed (http://crbug.com/466975 and
+ # http://crbug.com/355223).
+-ARCHIVE_URL="https://snapshot.debian.org/archive/debian"
+-ARCHIVE_TIMESTAMP=20210309T203820Z
+-APT_SOURCES_LIST="${ARCHIVE_URL}/${ARCHIVE_TIMESTAMP}/ stretch main
+-${ARCHIVE_URL}/${ARCHIVE_TIMESTAMP}/ experimental main
+-${ARCHIVE_URL}/${ARCHIVE_TIMESTAMP}/ sid main"
++ARCHIVE_TIMESTAMP=latest
++
++if [ "$1" = "BuildSysrootARM" ]; then
++    ARCHIVE_URL="http://snapshot.raspbian.org/"
++    APT_SOURCES_LIST="${ARCHIVE_URL}/${ARCHIVE_TIMESTAMP}/raspbian/ buster main contrib non-free rpi
++http://archive.raspberrypi.org/debian/ buster main"
++    HAS_ARCH_ARM=1
++    HAS_ARCH_ARM64=0
++elif [ "$1" = "BuildSysrootARM64" ]; then
++    ARCHIVE_URL="http://deb.debian.org/debian/"
++    APT_SOURCES_LIST="${ARCHIVE_URL} buster main contrib non-free
++http://deb.debian.org/debian-security/ buster/updates main contrib non-free
++http://deb.debian.org/debian buster-updates main contrib non-free
++http://archive.raspberrypi.org/debian/ buster main"
++    HAS_ARCH_ARM=0
++    HAS_ARCH_ARM64=1
++else
++    echo "Please run with either BuildSysrootARM64 or BuildSysrootARM"
++    exit 1
++fi
+ 
+ # gpg keyring file generated using generate_debian_archive_unstable.sh
+-KEYRING_FILE="${SCRIPT_DIR}/debian_archive_unstable.gpg"
++KEYRING_FILE="${SCRIPT_DIR}/pios_archive.gpg"
+ 
+-HAS_ARCH_AMD64=1
+-HAS_ARCH_I386=1
+-HAS_ARCH_ARM=1
+-HAS_ARCH_ARM64=1
+-HAS_ARCH_ARMEL=1
+-HAS_ARCH_MIPS=1
+-HAS_ARCH_MIPS64EL=1
++HAS_ARCH_AMD64=0
++HAS_ARCH_I386=0
++HAS_ARCH_ARMEL=0
++HAS_ARCH_MIPS=0
++HAS_ARCH_MIPS64EL=0
+ 
+ # Sysroot packages: these are the packages needed to build chrome.
+ # NOTE: When DEBIAN_PACKAGES is modified, the packagelist files must be updated
+@@ -81,9 +94,9 @@
+   libcups2-dev
+   libcupsimage2
+   libcupsimage2-dev
+-  libdatrie-dev
+   libcurl3-gnutls
+   libcurl4-gnutls-dev
++  libdatrie-dev
+   libdatrie1
+   libdb5.3
+   libdbus-1-3
+@@ -109,28 +122,27 @@
+   libepoxy0
+   libevdev-dev
+   libevdev2
+-  libevent-2.1-7
++  libevent-2.1-6
+   libexpat1
+   libexpat1-dev
+   libffi-dev
+   libffi6
+-  libffi7
+   libflac-dev
+   libflac8
+-  libfontconfig-dev
+   libfontconfig1
+-  libfreetype-dev
++  libfontconfig1-dev
+   libfreetype6
++  libfreetype6-dev
+   libfribidi-dev
+   libfribidi0
+   libgbm-dev
+   libgbm1
+-  libgcc-10-dev
+   libgcc1
++  libgcc-8-dev
+   libgcrypt20
+   libgcrypt20-dev
+-  libgdk-pixbuf-2.0-0
+-  libgdk-pixbuf-2.0-dev
++  libgdk-pixbuf2.0-0
++  libgdk-pixbuf2.0-dev
+   libgl-dev
+   libgl1
+   libgl1-mesa-dev
+@@ -146,8 +158,6 @@
+   libglx-dev
+   libglx0
+   libgmp10
+-  libgnome-keyring-dev
+-  libgnome-keyring0
+   libgnutls-dane0
+   libgnutls-openssl27
+   libgnutls28-dev
+@@ -170,10 +180,11 @@
+   libharfbuzz-gobject0
+   libharfbuzz-icu0
+   libharfbuzz0b
+-  libhogweed6
++  libhogweed4
+   libice6
++  libicu-dev
+   libicu-le-hb0
+-  libicu67
++  libicu63
+   libidl-2-0
+   libidn11
+   libidn2-0
+@@ -186,11 +197,11 @@
+   libjpeg62-turbo-dev
+   libjson-glib-1.0-0
+   libjsoncpp-dev
+-  libjsoncpp24
++  libjsoncpp1
+   libk5crypto3
+-  libkadm5clnt-mit12
+-  libkadm5srv-mit12
+-  libkdb5-10
++  libkadm5clnt-mit11
++  libkadm5srv-mit11
++  libkdb5-9
+   libkeyutils1
+   libkrb5-3
+   libkrb5-dev
+@@ -210,9 +221,8 @@
+   libncurses-dev
+   libncurses6
+   libncursesw6
+-  libnettle8
++  libnettle6
+   libnghttp2-14
+-  libnsl2
+   libnspr4
+   libnspr4-dev
+   libnss-db
+@@ -241,13 +251,12 @@
+   libpcre2-8-0
+   libpcre2-dev
+   libpcre2-posix0
+-  libpcre2-posix2
+   libpcre3
+   libpcre3-dev
+   libpcre32-3
+   libpcrecpp0v5
+-  libpipewire-0.3-0
+-  libpipewire-0.3-dev
++  libpipewire-0.2-1
++  libpipewire-0.2-dev
+   libpixman-1-0
+   libpixman-1-dev
+   libpng-dev
+@@ -257,7 +266,7 @@
+   libpulse-dev
+   libpulse-mainloop-glib0
+   libpulse0
+-  libre2-9
++  libre2-5
+   libre2-dev
+   librest-0.7-0
+   librtmp1
+@@ -272,20 +281,21 @@
+   libsndfile1
+   libsoup-gnome2.4-1
+   libsoup2.4-1
+-  libspa-0.2-dev
++  libspa-lib-0.1-dev
+   libspeechd-dev
+   libspeechd2
+   libsqlite3-0
+   libssh2-1
+   libssl-dev
+   libssl1.1
+-  libstdc++-10-dev
++  libstdc++-8-dev
+   libstdc++6
+   libsystemd0
+   libtasn1-6
+   libthai-dev
+   libthai0
+   libtiff5
++  libtinfo-dev
+   libtinfo6
+   libtirpc3
+   libudev-dev
+@@ -302,7 +312,7 @@
+   libvorbis0a
+   libvorbisenc2
+   libvpx-dev
+-  libvpx6
++  libvpx5
+   libvulkan-dev
+   libvulkan1
+   libwacom2
+@@ -408,7 +418,7 @@
+ "
+ 
+ DEBIAN_PACKAGES_X86="
+-  libasan6
++  libasan5
+   libcilkrts5
+   libdrm-intel1
+   libgtk-4-1
+@@ -420,30 +430,30 @@
+ "
+ 
+ DEBIAN_PACKAGES_ARM="
+-  libasan6
++  libasan5
+   libdrm-etnaviv1
+   libdrm-exynos1
+   libdrm-freedreno1
+   libdrm-omap1
+   libdrm-tegra0
+-  libgtk-4-1
+-  libgtk-4-dev
+   libubsan1
++  libraspberrypi0
++  libraspberrypi-dev
+ "
+ 
+ DEBIAN_PACKAGES_ARM64="
+-  libasan6
++  libasan5
+   libdrm-etnaviv1
+   libdrm-freedreno1
+   libdrm-tegra0
+   libgmp10
+-  libgtk-4-1
+-  libgtk-4-dev
+   libitm1
+   liblsan0
+   libthai0
+   libtsan0
+   libubsan1
++  libraspberrypi0
++  libraspberrypi-dev
+ "
+ 
+ DEBIAN_PACKAGES_ARMEL="
+@@ -460,4 +470,4 @@
+ DEBIAN_PACKAGES_MIPS64EL="
+ "
+ 
+-. "${SCRIPT_DIR}/sysroot-creator.sh"
++. "${SCRIPT_DIR}/sysroot-creator-pios.sh"
diff --git a/src/pi-util/sysroot-pios.patch b/src/pi-util/sysroot-pios.patch
new file mode 100644
index 000000000000..874e6008d9db
--- /dev/null
+++ b/src/pi-util/sysroot-pios.patch
@@ -0,0 +1,156 @@
+--- build/linux/sysroot_scripts/sysroot-creator-pios.sh 2021-06-22 10:42:30.972478650 +0100
++++ build/linux/sysroot_scripts/sysroot-creator-pios.sh 2021-06-22 10:42:30.972478650 +0100
+@@ -58,7 +58,7 @@
+ # Package Config
+ ######################################################################
+ 
+-readonly PACKAGES_EXT=xz
++readonly PACKAGES_EXTS="gz xz"
+ readonly RELEASE_FILE="Release"
+ readonly RELEASE_FILE_GPG="Release.gpg"
+ 
+@@ -125,7 +125,7 @@
+     local temp_file="${2}.partial.$$"
+     # curl --retry doesn't retry when the page gives a 4XX error, so we need to
+     # manually rerun.
+-    for i in {1..10}; do
++    for i in {1..2}; do
+       # --create-dirs is added in case there are slashes in the filename, as can
+       # happen with the "debian/security" release class.
+       local http_code=$(curl -L "$1" --create-dirs -o "${temp_file}" \
+@@ -138,7 +138,7 @@
+       sleep $i
+     done
+     if [ ! -f "${temp_file}" ]; then
+-      exit 1
++      return 1
+     fi
+     mv "${temp_file}" $2
+   else
+@@ -230,7 +230,16 @@
+   local src_file="$1"
+   local dst_file="$2"
+   local repo="$3"
+-  xzcat "${src_file}" | egrep '^(Package:|Filename:|SHA256:) ' |
++  local cat_tool
++  if [ "$PACKAGES_EXT" == "xz" ]; then
++    cat_tool="xzcat"
++  elif [ "$PACKAGES_EXT" == "gz" ]; then
++    cat_tool="zcat"
++  else
++    echo "ERROR: No tool to 'cat' archive type: $PACKAGES_EXT"
++    exit 1
++  fi
++  "$cat_tool" "${src_file}" | egrep '^(Package:|Filename:|SHA256:) ' |
+     sed "s|Filename: |Filename: ${repo}|" > "${dst_file}"
+ }
+ 
+@@ -243,13 +252,20 @@
+ 
+   TMP_PACKAGE_LIST="${BUILD_DIR}/Packages.${dist}_${repo_name}_${arch}"
+   local repo_basedir="${repo}/dists/${dist}"
+-  local package_list="${BUILD_DIR}/Packages.${dist}_${repo_name}_${arch}.${PACKAGES_EXT}"
+-  local package_file_arch="${repo_name}/binary-${arch}/Packages.${PACKAGES_EXT}"
+-  local package_list_arch="${repo_basedir}/${package_file_arch}"
+-
+-  DownloadOrCopyNonUniqueFilename "${package_list_arch}" "${package_list}"
+-  VerifyPackageListing "${package_file_arch}" "${package_list}" ${repo} ${dist}
+-  ExtractPackageXz "${package_list}" "${TMP_PACKAGE_LIST}" ${repo}
++  for PACKAGES_EXT in $PACKAGES_EXTS FAIL; do
++    local package_list="${BUILD_DIR}/Packages.${dist}_${repo_name}_${arch}.${PACKAGES_EXT}"
++    local package_file_arch="${repo_name}/binary-${arch}/Packages.${PACKAGES_EXT}"
++    local package_list_arch="${repo_basedir}/${package_file_arch}"
++
++    DownloadOrCopyNonUniqueFilename "${package_list_arch}" "${package_list}" || continue
++    VerifyPackageListing "${package_file_arch}" "${package_list}" ${repo} ${dist}
++    ExtractPackageXz "${package_list}" "${TMP_PACKAGE_LIST}" ${repo}
++    break
++  done
++  if [ "$PACKAGES_EXT" == "FAIL" ]; then
++    echo "ERROR: Command failed: $0 $@"
++    exit 1
++  fi
+ }
+ 
+ GeneratePackageListCommon() {
+@@ -399,6 +415,18 @@
+   mkdir -p ${INSTALL_ROOT}/usr/lib/pkgconfig
+   mv ${INSTALL_ROOT}/usr/lib/${arch}-${os}/pkgconfig/* \
+       ${INSTALL_ROOT}/usr/lib/pkgconfig
++
++  # Temporary workaround for invalid implicit conversion from void* in pipewire.
++  # This is already fixed upstream in [1], so this can be removed once it rolls
++  # into Debian.
++  # [1] https://github.com/PipeWire/pipewire/commit/371da358d1580dc06218d18a12a99611cac39e4e
++  # buster uses 0.2 bullseye 0.3 - the offending file doesn't exist in 0.3
++  local pipewire_utils_h="${INSTALL_ROOT}/usr/include/pipewire/utils.h"
++  if [ -e ${pipewire_utils_h} ]; then
++    sed -i 's/malloc/(struct spa_pod*)malloc/' "${pipewire_utils_h}"
++  fi
++
++  rm -rf "${INSTALL_ROOT}/opt/vc/include/"*GL*
+ }
+ 
+ 
+@@ -880,14 +908,14 @@
+   shift
+   shift
+   for pkg in $@ ; do
+-    local pkg_full=$(grep -A 1 " ${pkg}\$" "$input_file" | \
+-      egrep "pool/.*" | sed 's/.*Filename: //')
++    local pkg_full=$(grep -A 2 " ${pkg}\$" "$input_file" | \
++      egrep -m1 "pool/.*" | sed 's/.*Filename: //')
+     if [ -z "${pkg_full}" ]; then
+         echo "ERROR: missing package: $pkg"
+         exit 1
+     fi
+     local sha256sum=$(grep -A 4 " ${pkg}\$" "$input_file" | \
+-      grep ^SHA256: | sed 's/^SHA256: //')
++      grep -m1 ^SHA256: | sed 's/^SHA256: //')
+     if [ "${#sha256sum}" -ne "64" ]; then
+       echo "Bad sha256sum from Packages"
+       exit 1
+--- build/linux/sysroot_scripts/generate_pios_gpg.sh 2021-06-21 11:13:27.598524694 +0100
++++ build/linux/sysroot_scripts/generate_pios_gpg.sh 2021-06-21 11:13:27.598524694 +0100
+@@ -9,29 +9,17 @@
+ SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+ 
+ KEYS=(
+-    # Debian Stable Release Key (10/buster)
+-    "DCC9EFBF77E11517"
+-    # Debian Archive Automatic Signing Key (10/buster)
+-    "DC30D7C23CBBABEE"
+-    # Debian Security Archive Automatic Signing Key (10/buster)
+-    "4DFAB270CAA96DFA"
+-    # Debian Archive Automatic Signing Key (10/buster)
+-    "DC30D7C23CBBABEE"
+-    # Jessie Stable Release Key
+-    "CBF8D6FD518E17E1"
+-    # Debian Archive Automatic Signing Key (7.0/wheezy)
+-    "8B48AD6246925553"
+-    # Debian Archive Automatic Signing Key (8/jessie)
+-    "7638D0442B90D010"
+-    # Debian Security Archive Automatic Signing Key (8/jessie)
+-    "9D6D8F6BC857C906"
+-    # Debian Archive Automatic Signing Key (9/stretch)
+-    "E0B11894F66AEC98"
+-    # Debian Security Archive Automatic Signing Key (9/stretch)
+-    "EDA0D2388AE22BA9"
+-    # Debian Stable Release Key (9/stretch)
+-    "EF0F382A1A7B6500"
++    # Raspbian
++    "A0DA38D0D76E8B5D638872819165938D90FDDD2E"
++    # Raspberry Pi OS
++    "CF8A1AF502A2AA2D763BAE7E82B129927FA3303E"
++    # Debian
++    "16E90B3FDF65EDE3AA7F323C04EE7237B7D453EC"
++    "0146DC6D4A0B2914BDED34DB648ACFD622F3D138"
++    "6D33866EDD8FFA41C0143AEDDCC9EFBF77E11517"
++    "379483D8B60160B155B372DDAA8E81B4331F7F50"
++    "5237CEEEF212F3D51C74ABE0112695A0E562B32A"
+ )
+ 
+-gpg --recv-keys ${KEYS[@]}
+-gpg --output "${SCRIPT_DIR}/debian_archive_unstable.gpg" --export ${KEYS[@]}
++gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys ${KEYS[@]}
++gpg --output "${SCRIPT_DIR}/pios_archive.gpg" --export ${KEYS[@]}
diff --git a/src/sandbox/policy/linux/bpf_gpu_policy_linux.cc b/src/sandbox/policy/linux/bpf_gpu_policy_linux.cc
index b19668b88007..30c11a51c258 100644
--- a/src/sandbox/policy/linux/bpf_gpu_policy_linux.cc
+++ b/src/sandbox/policy/linux/bpf_gpu_policy_linux.cc
@@ -75,6 +75,27 @@ ResultExpr GpuProcessPolicy::EvaluateSyscall(int sysno) const {
     // (MAP_LOCKED | MAP_EXECUTABLE | MAP_32BIT)
     case __NR_mmap:
       return Allow();
+#endif
+#if defined(USE_X11) || 1
+    // Wanted for MESA to fire up happily
+    // *** Should almost certainly arrange for the offending setup
+    //     to happen before sandbox is applied but I can't work out
+    //     what is needed
+    // Alternatively --in-process-gpu fixes the issue
+#ifdef __NR_readlink
+    case __NR_readlink:  // 85
+#else
+    case __NR_readlinkat:
+#endif
+#ifdef __NR_stat64
+    case __NR_stat64:    // 195
+#endif
+    case __NR_openat:    // 322 --- This one is clearly bad!
+    // V4L2 requires open/close - not sure how this works in chromeos without the holes
+#ifdef __NR_open
+    case __NR_open:
+#endif
+    case __NR_close:
 #endif
     // We also hit this on the linux_chromeos bot but don't yet know what
     // weird flags were involved.
diff --git a/src/sandbox/policy/linux/bpf_renderer_policy_linux.cc b/src/sandbox/policy/linux/bpf_renderer_policy_linux.cc
index f789e92c37c1..f0313074c024 100644
--- a/src/sandbox/policy/linux/bpf_renderer_policy_linux.cc
+++ b/src/sandbox/policy/linux/bpf_renderer_policy_linux.cc
@@ -26,6 +26,9 @@ struct local_dma_buf_sync {
 #define LOCAL_DMA_BUF_IOCTL_SYNC \
   _IOW(LOCAL_DMA_BUF_BASE, 0, struct local_dma_buf_sync)
 
+using sandbox::SyscallSets;
+using sandbox::bpf_dsl::If;
+using sandbox::bpf_dsl::AnyOf;
 using sandbox::bpf_dsl::Allow;
 using sandbox::bpf_dsl::Arg;
 using sandbox::bpf_dsl::Error;
@@ -36,14 +39,18 @@ namespace policy {
 
 namespace {
 
+#define ISMAGIC(r, x) (((r) & (_IOC_TYPEMASK << _IOC_TYPESHIFT)) == ((x) << _IOC_TYPESHIFT))
+
 ResultExpr RestrictIoctl() {
   const Arg<unsigned long> request(1);
-  return Switch(request)
+  // Pi - allow all VCHIQ ioctls and the VMCS_SM ioctls and VCSM ioctls too
+  return If(AnyOf(ISMAGIC(request, 0xc4), ISMAGIC(request, 'I'), ISMAGIC(request, 'J')), Allow()).Else(
+    Switch(request)
       .SANDBOX_BPF_DSL_CASES((static_cast<unsigned long>(TCGETS), FIONREAD),
                              Allow())
       .SANDBOX_BPF_DSL_CASES(
           (static_cast<unsigned long>(LOCAL_DMA_BUF_IOCTL_SYNC)), Allow())
-      .Default(CrashSIGSYSIoctl());
+      .Default(sandbox::CrashSIGSYSIoctl()));
 }
 
 }  // namespace
diff --git a/src/sandbox/policy/linux/sandbox_linux.h b/src/sandbox/policy/linux/sandbox_linux.h
index 9054eb62d097..a16dbde4e400 100644
--- a/src/sandbox/policy/linux/sandbox_linux.h
+++ b/src/sandbox/policy/linux/sandbox_linux.h
@@ -62,6 +62,8 @@ class SANDBOX_POLICY_EXPORT SandboxLinux {
     DEPRECATED_METHOD_GET_STYLE_FOR_STRIKE,
     METHOD_MAKE_SHARED_MEMORY_SEGMENT,
     DEPRECATED_METHOD_MATCH_WITH_FALLBACK,
+    METHOD_OPEN_DEV_VCHIQ,
+    METHOD_OPEN_DEV_VCSM,
   };
 
   // These form a bitmask which describes the conditions of the Linux sandbox.
diff --git a/src/services/viz/public/cpp/compositing/transferable_resource_mojom_traits.cc b/src/services/viz/public/cpp/compositing/transferable_resource_mojom_traits.cc
index 53cbd1aaeb30..be82df0ebc13 100644
--- a/src/services/viz/public/cpp/compositing/transferable_resource_mojom_traits.cc
+++ b/src/services/viz/public/cpp/compositing/transferable_resource_mojom_traits.cc
@@ -36,6 +36,7 @@ bool StructTraits<viz::mojom::TransferableResourceDataView,
   out->is_backed_by_surface_texture = data.is_backed_by_surface_texture();
   out->wants_promotion_hint = data.wants_promotion_hint();
 #endif
+  out->stride = data.stride();
   return true;
 }
 
diff --git a/src/services/viz/public/cpp/compositing/transferable_resource_mojom_traits.h b/src/services/viz/public/cpp/compositing/transferable_resource_mojom_traits.h
index 0fb32425773c..44dcc7b6f06f 100644
--- a/src/services/viz/public/cpp/compositing/transferable_resource_mojom_traits.h
+++ b/src/services/viz/public/cpp/compositing/transferable_resource_mojom_traits.h
@@ -89,6 +89,9 @@ struct StructTraits<viz::mojom::TransferableResourceDataView,
       const viz::TransferableResource& resource) {
     return resource.ycbcr_info;
   }
+  static uint32_t stride(const viz::TransferableResource& resource) {
+    return resource.stride;
+  }
 
   static bool Read(viz::mojom::TransferableResourceDataView data,
                    viz::TransferableResource* out);
diff --git a/src/services/viz/public/mojom/compositing/compositor_frame_sink.mojom b/src/services/viz/public/mojom/compositing/compositor_frame_sink.mojom
index ca6fa9ca8ce6..81eaa2c7992b 100644
--- a/src/services/viz/public/mojom/compositing/compositor_frame_sink.mojom
+++ b/src/services/viz/public/mojom/compositing/compositor_frame_sink.mojom
@@ -121,4 +121,8 @@ interface CompositorFrameSinkClient {
   // Inform the client that a compositor frame transition directive was fully
   // processed.
   OnCompositorFrameTransitionDirectiveProcessed(uint32 sequence_id);
+
+  // Frame resized - if we can resize the video to this we should get away
+  // without later resizing
+  DidStretchFrame(uint32 width, uint32 height);
 };
diff --git a/src/services/viz/public/mojom/compositing/transferable_resource.mojom b/src/services/viz/public/mojom/compositing/transferable_resource.mojom
index 6d95a59074d7..82ae7a4bfe09 100644
--- a/src/services/viz/public/mojom/compositing/transferable_resource.mojom
+++ b/src/services/viz/public/mojom/compositing/transferable_resource.mojom
@@ -28,4 +28,5 @@ struct TransferableResource {
   gfx.mojom.ColorSpace color_space;
   gfx.mojom.HDRMetadata? hdr_metadata;
   gpu.mojom.VulkanYCbCrInfo ? ycbcr_info;
+  uint32 stride;
 };
diff --git a/src/third_party/blink/renderer/platform/graphics/begin_frame_provider.h b/src/third_party/blink/renderer/platform/graphics/begin_frame_provider.h
index 60a2f5d241b0..97ec12b52e34 100644
--- a/src/third_party/blink/renderer/platform/graphics/begin_frame_provider.h
+++ b/src/third_party/blink/renderer/platform/graphics/begin_frame_provider.h
@@ -62,6 +62,7 @@ class PLATFORM_EXPORT BeginFrameProvider
       uint32_t sequence_id) final {
     NOTIMPLEMENTED();
   }
+  void DidStretchFrame(uint32_t width, uint32_t height) override {}
 
   // viz::mojom::blink::EmbeddedFrameSinkClient implementation.
   void BindSurfaceEmbedder(
diff --git a/src/third_party/blink/renderer/platform/graphics/canvas_resource_dispatcher.h b/src/third_party/blink/renderer/platform/graphics/canvas_resource_dispatcher.h
index 212f6aae43ba..b61c47115a41 100644
--- a/src/third_party/blink/renderer/platform/graphics/canvas_resource_dispatcher.h
+++ b/src/third_party/blink/renderer/platform/graphics/canvas_resource_dispatcher.h
@@ -82,6 +82,7 @@ class PLATFORM_EXPORT CanvasResourceDispatcher
   void ReclaimResources(WTF::Vector<viz::ReturnedResource> resources) final;
   void OnCompositorFrameTransitionDirectiveProcessed(
       uint32_t sequence_id) final {}
+  void DidStretchFrame(uint32_t width, uint32_t height) override {}
 
   void DidAllocateSharedBitmap(base::ReadOnlySharedMemoryRegion region,
                                const gpu::Mailbox& id);
diff --git a/src/third_party/blink/renderer/platform/graphics/video_frame_submitter.cc b/src/third_party/blink/renderer/platform/graphics/video_frame_submitter.cc
index 4d98fc007255..9cdbc9eadd82 100644
--- a/src/third_party/blink/renderer/platform/graphics/video_frame_submitter.cc
+++ b/src/third_party/blink/renderer/platform/graphics/video_frame_submitter.cc
@@ -299,6 +299,11 @@ void VideoFrameSubmitter::DidDeleteSharedBitmap(const viz::SharedBitmapId& id) {
   compositor_frame_sink_->DidDeleteSharedBitmap(id);
 }
 
+void VideoFrameSubmitter::DidStretchFrame(uint32_t width, uint32_t height) {
+  if (video_frame_provider_)
+    video_frame_provider_->DidStretchFrame(width, height);
+}
+
 void VideoFrameSubmitter::OnReceivedContextProvider(
     bool use_gpu_compositing,
     scoped_refptr<viz::RasterContextProvider> context_provider) {
diff --git a/src/third_party/blink/renderer/platform/graphics/video_frame_submitter.h b/src/third_party/blink/renderer/platform/graphics/video_frame_submitter.h
index a31b403af73e..2c259b43977d 100644
--- a/src/third_party/blink/renderer/platform/graphics/video_frame_submitter.h
+++ b/src/third_party/blink/renderer/platform/graphics/video_frame_submitter.h
@@ -78,6 +78,7 @@ class PLATFORM_EXPORT VideoFrameSubmitter
   void ReclaimResources(WTF::Vector<viz::ReturnedResource> resources) override;
   void OnCompositorFrameTransitionDirectiveProcessed(
       uint32_t sequence_id) override {}
+  void DidStretchFrame(uint32_t width, uint32_t height) override;
 
   // viz::SharedBitmapReporter implementation.
   void DidAllocateSharedBitmap(base::ReadOnlySharedMemoryRegion,
diff --git a/src/third_party/blink/renderer/platform/widget/compositing/android_webview/synchronous_layer_tree_frame_sink.h b/src/third_party/blink/renderer/platform/widget/compositing/android_webview/synchronous_layer_tree_frame_sink.h
index 4129ecc82b3a..cfd650e1f0d5 100644
--- a/src/third_party/blink/renderer/platform/widget/compositing/android_webview/synchronous_layer_tree_frame_sink.h
+++ b/src/third_party/blink/renderer/platform/widget/compositing/android_webview/synchronous_layer_tree_frame_sink.h
@@ -118,6 +118,7 @@ class SynchronousLayerTreeFrameSink
   void OnBeginFramePausedChanged(bool paused) override;
   void OnCompositorFrameTransitionDirectiveProcessed(
       uint32_t sequence_id) override {}
+  void DidStretchFrame(uint32_t width, uint32_t height) override {}
 
   // viz::ExternalBeginFrameSourceClient overrides.
   void OnNeedsBeginFrames(bool needs_begin_frames) override;
diff --git a/src/third_party/libdrm/BUILD.gn b/src/third_party/libdrm/BUILD.gn
index 8c1054b6e8f4..b9c70bfe712a 100644
--- a/src/third_party/libdrm/BUILD.gn
+++ b/src/third_party/libdrm/BUILD.gn
@@ -52,6 +52,7 @@ static_library("libdrm") {
     # glibc-2.24.  This causes a build error when using the Debian
     # Stretch sysroot.
     "-Wno-deprecated-declarations",
+    "-DMAJOR_IN_SYSMACROS=1",
   ]
 
   public_configs = [ ":libdrm_config" ]
diff --git a/src/third_party/widevine/cdm/widevine.gni b/src/third_party/widevine/cdm/widevine.gni
index d676aee4f2a3..d7c472188501 100644
--- a/src/third_party/widevine/cdm/widevine.gni
+++ b/src/third_party/widevine/cdm/widevine.gni
@@ -26,7 +26,7 @@ if (is_chromeos_ash && !is_chromeos_device) {
 library_widevine_cdm_available =
     (is_chromeos_ash && (target_cpu == "x64" || target_cpu == "arm")) ||
     ((is_linux || is_chromeos_lacros) &&
-     (target_cpu == "x86" || target_cpu == "x64")) ||
+     (target_cpu == "x86" || target_cpu == "x64" || target_cpu == "arm")) ||
     (is_mac && (target_cpu == "x64" || target_cpu == "arm64")) ||
     (is_win && (target_cpu == "x86" || target_cpu == "x64"))
 
diff --git a/src/ui/android/delegated_frame_host_android.h b/src/ui/android/delegated_frame_host_android.h
index d2ae38cca358..bf132ef60a14 100644
--- a/src/ui/android/delegated_frame_host_android.h
+++ b/src/ui/android/delegated_frame_host_android.h
@@ -140,6 +140,8 @@ class UI_ANDROID_EXPORT DelegatedFrameHostAndroid
   // FrameEvictorClient implementation.
   void EvictDelegatedFrame() override;
 
+  void DidStretchFrame(uint32_t width, uint32_t height) override {}
+
   // viz::HostFrameSinkClient implementation.
   void OnFirstSurfaceActivation(const viz::SurfaceInfo& surface_info) override;
   void OnFrameTokenChanged(uint32_t frame_token,
diff --git a/src/ui/base/ui_base_features.cc b/src/ui/base/ui_base_features.cc
index 55c38066699b..d4acec511e4c 100644
--- a/src/ui/base/ui_base_features.cc
+++ b/src/ui/base/ui_base_features.cc
@@ -301,7 +301,7 @@ const base::Feature kResamplingScrollEventsExperimentalPrediction{
 #if defined(USE_X11) || defined(USE_OZONE)
 const base::Feature kUseOzonePlatform {
   "UseOzonePlatform",
-#if defined(USE_X11)
+#if defined(USE_X11) && 0 /* RPI - use ozone by default */
       base::FEATURE_DISABLED_BY_DEFAULT
 };
 #else
diff --git a/src/ui/base/x/x11_gl_egl_utility.cc b/src/ui/base/x/x11_gl_egl_utility.cc
index 624c6f9483bd..a4e7f1d0092e 100644
--- a/src/ui/base/x/x11_gl_egl_utility.cc
+++ b/src/ui/base/x/x11_gl_egl_utility.cc
@@ -53,6 +53,11 @@ void ChoosePlatformCustomAlphaAndBufferSize(EGLint* alpha_size,
                                                          nullptr, nullptr);
     *buffer_size = depth;
     *alpha_size = *buffer_size == 32 ? 8 : 0;
+    if (depth != 24) {
+      LOG(INFO) << "Depth=" << (int)depth << ", kludging to 24 to prevent mismatch with surface";
+      *buffer_size = 24;
+      *alpha_size = 0;
+    }
   }
 }
 
diff --git a/src/ui/base/x/x11_software_bitmap_presenter.h b/src/ui/base/x/x11_software_bitmap_presenter.h
index ac1b951003a5..366e364ff81f 100644
--- a/src/ui/base/x/x11_software_bitmap_presenter.h
+++ b/src/ui/base/x/x11_software_bitmap_presenter.h
@@ -39,6 +39,9 @@ class COMPONENT_EXPORT(UI_BASE_X) X11SoftwareBitmapPresenter {
   void EndPaint(const gfx::Rect& damage_rect);
   void OnSwapBuffers(SwapBuffersCallback swap_ack_callback);
   int MaxFramesPending() const;
+  gfx::AcceleratedWidget GetAcceleratedWidget() const {
+    return gfx::AcceleratedWidget(widget_);
+  }
 
  private:
   // Draw |data| over |widget|'s parent-relative background, and write the
diff --git a/src/ui/gfx/BUILD.gn b/src/ui/gfx/BUILD.gn
index ffd44dc7946c..657411a16ea3 100644
--- a/src/ui/gfx/BUILD.gn
+++ b/src/ui/gfx/BUILD.gn
@@ -2,7 +2,9 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/buildflag_header.gni")
 import("//build/config/ozone.gni")
+import("//build/config/linux/rpi/args.gni")
 import("//build/config/ui.gni")
 import("//device/vr/buildflags/buildflags.gni")
 import("//testing/libfuzzer/fuzzer_test.gni")
@@ -13,6 +15,13 @@ if (is_android) {
   import("//build/config/android/rules.gni")
 }
 
+buildflag_header("buildflags") {
+  header = "buildflags.h"
+  flags = [
+    "ENABLE_NATIVE_PIXMAP_VCSM=$enable_native_pixmap_vcsm",
+  ]
+}
+
 # Several targets want to include this header file, and some of them are
 # child dependencies of "gfx". Therefore, we separate it out here so multiple
 # targets can all have a dependency for header checking purposes without
@@ -586,6 +595,7 @@ source_set("memory_buffer_sources") {
   public_deps = [ ":buffer_types" ]
 
   deps = [
+    ":buildflags",
     ":gfx_switches",
     ":native_widget_types",
     "//base",
@@ -605,6 +615,15 @@ source_set("memory_buffer_sources") {
     ]
 
     deps += [ "//build/config/linux/libdrm" ]
+
+    if (enable_native_pixmap_vcsm) {
+      sources += [
+        "linux/native_pixmap_vcsm.cc",
+        "linux/native_pixmap_vcsm.h"
+      ]
+
+      public_configs = [ "//build/config/linux/rpi:use_mmal" ]
+    }
   }
 
   if (is_linux || is_chromeos || is_android) {
diff --git a/src/ui/gfx/linux/native_pixmap_vcsm.cc b/src/ui/gfx/linux/native_pixmap_vcsm.cc
new file mode 100644
index 000000000000..707a924f0a0c
--- /dev/null
+++ b/src/ui/gfx/linux/native_pixmap_vcsm.cc
@@ -0,0 +1,322 @@
+#include "ui/gfx/linux/native_pixmap_vcsm.h"
+
+#include "base/logging.h"
+#include "base/posix/eintr_wrapper.h"
+#include "ui/gfx/buffer_format_util.h"
+
+extern "C" {
+#include <fcntl.h>
+#include <interface/vcsm/user-vcsm.h>
+}
+
+namespace gfx {
+
+class NativePixmapVCSM : public NativePixmap
+{
+  static std::vector<NativePixmapPlane>
+  BuildPlanes(const gfx::Size& size, gfx::BufferFormat format, base::ScopedFD fd)
+  {
+    std::vector<NativePixmapPlane> npp;
+
+    // Make sure that our geometry matches what the rest of the world is
+    // expecting - so use common util functions for info
+    // Build planes to keep a copy
+    const size_t plane_count = NumberOfPlanesForLinearBufferFormat(format);
+    size_t offset = 0;
+
+    for (size_t i = 0; i != plane_count; ++i) {
+      size_t pitch = RowSizeForBufferFormat(size.width(), format, i);
+      size_t next_offset = i + 1 >= plane_count ?
+        BufferSizeForBufferFormat(size, format) :
+        BufferOffsetForBufferFormat(size, format, i + 1);
+
+      npp.emplace_back(
+          pitch, offset, next_offset - offset, i == 0 ? std::move(fd) : base::ScopedFD());
+
+      offset = next_offset;
+    }
+    return npp;
+  }
+
+public:
+  NativePixmapVCSM(const gfx::Size& size,
+                     gfx::BufferFormat format,
+                     uint64_t modifier,
+                     base::ScopedFD fd) :
+    size_(size),
+    format_(format),
+    modifier_(modifier),
+    planes_(BuildPlanes(size, format, std::move(fd)))
+  {
+  }
+
+  // Assume that this is an import of a handle we exported
+  NativePixmapVCSM(const gfx::Size& size,
+                     gfx::BufferFormat format,
+                     uint64_t modifier,
+                     gfx::NativePixmapHandle&& handle) :
+    size_(size),
+    format_(format),
+    modifier_(modifier),
+    planes_(BuildPlanes(size, format, std::move(handle.planes.front().fd)))
+  {
+  }
+
+  // NativePixmap:
+  bool AreDmaBufFdsValid() const override
+  {
+    if (planes_.empty())
+      return false;
+
+    // Must have a good fd on plane 0
+    if (!planes_.front().fd.is_valid())
+      return false;
+    return true;
+  }
+
+  int GetDmaBufFd(size_t plane) const override {
+    return planes_.front().fd.get();
+  }
+
+  uint32_t GetDmaBufPitch(size_t plane) const override {
+    DCHECK_LT(plane, planes_.size());
+    return planes_[plane].stride;
+  }
+
+  size_t GetDmaBufOffset(size_t plane) const override {
+    DCHECK_LT(plane, planes_.size());
+    return planes_[plane].offset;
+  }
+
+  size_t GetDmaBufPlaneSize(size_t plane) const override {
+    DCHECK_LT(plane, planes_.size());
+    return planes_[plane].size;
+  }
+
+  // Return the number of non-interleaved "color" planes.
+  size_t GetNumberOfPlanes() const override {
+    return planes_.size();
+  }
+
+  gfx::BufferFormat GetBufferFormat() const override {
+    return format_;
+  }
+
+  uint64_t GetBufferFormatModifier() const override {
+    // ***** What no plane?
+    return modifier_;
+  }
+
+  gfx::Size GetBufferSize() const override {
+    return size_;
+  }
+
+  uint32_t GetUniqueId() const override {
+    LOG(INFO) << __func__;
+    return 0;
+  }
+
+  bool ScheduleOverlayPlane(gfx::AcceleratedWidget widget,
+                            int plane_z_order,
+                            gfx::OverlayTransform plane_transform,
+                            const gfx::Rect& display_bounds,
+                            const gfx::RectF& crop_rect,
+                            bool enable_blend,
+                            std::vector<gfx::GpuFence> acquire_fences,
+                            std::vector<gfx::GpuFence> release_fences) override {
+    return false;
+  }
+
+  gfx::NativePixmapHandle ExportHandle() override
+  {
+    gfx::NativePixmapHandle ph;
+    // The rest of the pixmap handle code is expecting a valid fd on every plane
+    // so we have to generate dups for all planes.  This is much simpler than
+    // trying to make the rest of the code cope with fewer fds
+    ph.modifier = modifier_;
+    for (const auto& plane : planes_) {
+      ph.planes.emplace_back(plane.stride,
+                             plane.offset,
+                             plane.size,
+                             base::ScopedFD(HANDLE_EINTR(dup(planes_.front().fd.get()))));
+    }
+
+    return ph;
+  }
+
+  std::string ToString() const
+  {
+    std::ostringstream s;
+    s << "format:" << gfx::BufferFormatToString(format_) <<
+        ", size:" << size_.ToString() << ", modifier:" << modifier_ <<
+        ", planes: ";
+
+    if (planes_.empty()) {
+      s << "EMPTY";
+    }
+    else
+    {
+      int n = 0;
+      for (const auto& plane : planes_) {
+        if (n++ != 0)
+          s << "; ";
+        s << "[" << n << "] stride:" << plane.stride << ", offset:" << plane.offset << ", size:" << plane.size << ", fd:" << plane.fd.get();
+      }
+    }
+
+    return s.str();
+  }
+
+
+ protected:
+  ~NativePixmapVCSM() override {}
+
+ private:
+  const gfx::Size size_;
+  const gfx::BufferFormat format_;
+  const uint64_t modifier_;
+  const std::vector<gfx::NativePixmapPlane> planes_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativePixmapVCSM);
+};
+
+
+// It appears that the GPU process has some sort of sandboxing as we can't
+// open /dev/vcsm* in CreatePixmap, but the sandboxing isn't set up at static
+// init time - so open the file then and init when needed
+//
+// There are two reasons for not initing at static init
+//  1) This file seems to be included in many processes and we don't need/want
+//     a vcsm context in all of them
+//  2) We also seem to be included in the decode process and we must avoid
+//     locking vcsm into the wrong mode
+//
+// We just have to live with the spurious file open in processes that don't
+// want it
+
+// With this OPT set we make no attempt to clean up on unload - this really
+// shouldn't matter in the slightest as process death should clean everything
+// automatically.
+// When compiled here we get errors if we have on-exit destructors
+#define OPT_LEAK 1
+
+#if OPT_LEAK
+class VcsmCmaInit {
+  bool init_done_ok_ = false;
+  bool init_attempted_ = false;
+  int fd_;
+public:
+  VcsmCmaInit() :
+    fd_(IGNORE_EINTR(open("/dev/vcsm-cma", O_RDWR)))
+  {
+  }
+
+  ~VcsmCmaInit() = default;
+
+  bool InitOnce()
+  {
+    if (!init_attempted_)
+    {
+      init_attempted_ = true;
+      if (fd_ != -1) {
+        init_done_ok_ = (vcsm_init_ex(1, fd_) == 0);
+        if (!init_done_ok_) {
+          LOG(WARNING) << "Failed to init VCSM for CMA";
+        }
+        close(fd_);
+        fd_ = -1;
+      }
+    }
+    return init_done_ok_;
+  }
+
+  operator bool() const
+  {
+    return init_done_ok_;
+  }
+};
+#else
+class VcsmCmaInit {
+  bool init_done_ok_ = false;
+  bool init_attempted_ = false;
+  base::ScopedFD fd_;
+public:
+  VcsmCmaInit() :
+    fd_(IGNORE_EINTR(open("/dev/vcsm-cma", O_RDWR)))
+  {
+  }
+
+  ~VcsmCmaInit()
+  {
+    if (init_done_ok_)
+      vcsm_exit();
+  }
+
+  bool InitOnce()
+  {
+    if (!init_attempted_)
+    {
+      init_attempted_ = true;
+      if (fd_.is_valid()) {
+        init_done_ok_ = (vcsm_init_ex(1, fd_.get()) == 0);
+        if (!init_done_ok_) {
+          LOG(WARNING) << "Failed to init VCSM for CMA";
+        }
+        fd_.reset();
+      }
+    }
+    return init_done_ok_;
+  }
+
+  operator bool() const
+  {
+    return init_done_ok_;
+  }
+};
+#endif
+
+static VcsmCmaInit vcsm_cma_init;
+
+scoped_refptr<gfx::NativePixmap>
+CreateVCSMPixmap(const gfx::Size& size, const gfx::BufferFormat format)
+{
+  if (!vcsm_cma_init.InitOnce()) {
+    return scoped_refptr<gfx::NativePixmap>();
+  }
+
+  const uint64_t modifier = NativePixmapHandle::kNoModifier;
+  const uint32_t total_size = BufferSizeForBufferFormat(size, format);
+
+  if (total_size == 0)
+    return scoped_refptr<gfx::NativePixmapVCSM>();
+
+  const unsigned int vcsm_handle = vcsm_malloc(total_size, "ChromeBuf");
+  if (vcsm_handle == 0) {
+    LOG(WARNING) << "VCSM alloc failed";
+    return scoped_refptr<gfx::NativePixmapVCSM>();
+  }
+
+  base::ScopedFD fd(vcsm_export_dmabuf(vcsm_handle));
+
+  // We don't need this anymore!
+  // Arguably this is a somewhat silly way of allocating a dmabuf as I don't
+  // care about the vcsm handle here, but all the methods seem mostly daft.
+  vcsm_free(vcsm_handle);
+
+  if (!fd.is_valid()) {
+    LOG(WARNING) << "VCSM export failed";
+    return scoped_refptr<gfx::NativePixmapVCSM>();
+  }
+
+  return base::MakeRefCounted<NativePixmapVCSM>(size, format, modifier, std::move(fd));
+}
+
+scoped_refptr<gfx::NativePixmap>
+CreateVCSMPixmapFromHandle(const gfx::Size& size, const gfx::BufferFormat format, gfx::NativePixmapHandle&& handle)
+{
+  const uint64_t modifier = NativePixmapHandle::kNoModifier;
+  return base::MakeRefCounted<NativePixmapVCSM>(size, format, modifier, std::move(handle));
+}
+
+}  // namespace gfx
+
diff --git a/src/ui/gfx/linux/native_pixmap_vcsm.h b/src/ui/gfx/linux/native_pixmap_vcsm.h
new file mode 100644
index 000000000000..bb10403eb8c4
--- /dev/null
+++ b/src/ui/gfx/linux/native_pixmap_vcsm.h
@@ -0,0 +1,31 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GFX_LINUX_NATIVE_PIXMAP_VCSM_H_
+#define UI_GFX_LINUX_NATIVE_PIXMAP_VCSM_H_
+
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/files/scoped_file.h"
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "media/media_buildflags.h"
+#include "ui/gfx/client_native_pixmap.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/native_pixmap.h"
+
+namespace gfx {
+
+GFX_EXPORT scoped_refptr<gfx::NativePixmap>
+CreateVCSMPixmap(const gfx::Size& size, const gfx::BufferFormat format);
+
+GFX_EXPORT scoped_refptr<gfx::NativePixmap>
+CreateVCSMPixmapFromHandle(const gfx::Size& size, const gfx::BufferFormat format, gfx::NativePixmapHandle&& handle);
+
+}  // namespace gfx
+
+#endif  // UI_GFX_LINUX_NATIVE_PIXMAP_VCSM_H_
+
diff --git a/src/ui/gl/init/gl_factory.cc b/src/ui/gl/init/gl_factory.cc
index c7c0733a59a1..c11c71692867 100644
--- a/src/ui/gl/init/gl_factory.cc
+++ b/src/ui/gl/init/gl_factory.cc
@@ -77,6 +77,15 @@ GLImplementationParts GetRequestedGLImplementation(
     return GLImplementationParts(kGLImplementationNone);
   }
 
+  // RPI: We always want EGL as our preferred render
+  // Easiest to simply add here - angle + GLES +/- EGL crashes
+  // so add here after the angle add.
+  //
+  // BEWARE: falling back from EGL to anything else with --in-process-gpu
+  // set produces a segfault when we exit so ideally we would only do this
+  // on Pi4/(F)KMS?
+  allowed_impls.insert(allowed_impls.begin(), kGLImplementationEGLGLES2);
+
   // The default implementation is always the first one in list.
   GLImplementationParts impl = GLImplementationParts(allowed_impls[0]);
   UMA_HISTOGRAM_ENUMERATION("GPU.PreferredGLImplementation", impl.gl);
diff --git a/src/native_client/src/include/concurrency_ops.h b/src/native_client/src/include/concurrency_ops.h
index 82e313c3a..5c04eef5e 100644
--- a/src/native_client/src/include/concurrency_ops.h
+++ b/src/native_client/src/include/concurrency_ops.h
@@ -32,14 +32,13 @@ static INLINE void NaClWriteMemoryBarrier(void) {
 #elif NACL_ARCH(NACL_BUILD_ARCH) == NACL_arm
 
 static INLINE void NaClWriteMemoryBarrier(void) {
+#if __ARM_ARCH >= 7
   /* Note that this depends on ARMv7. */
   __asm__ __volatile__("dsb");
-
-  /*
-   * We could support ARMv6 by instead using:
-   * __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 5"
-   *                      : : "r" (0) : "memory");
-   */
+#else
+ __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 5"
+                      : : "r" (0) : "memory");
+#endif
 }
 
 #elif NACL_ARCH(NACL_BUILD_ARCH) == NACL_mips
diff --git a/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h b/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
index d6b1ade890..731bc8d33f 100644
--- a/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
+++ b/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
@@ -41,7 +41,7 @@
 #define ARCH_X86_64 0
 #define HAVE_ARMV5TE 1
 #define HAVE_ARMV6 1
-#define HAVE_ARMV6T2 1
+#define HAVE_ARMV6T2 0
 #define HAVE_ARMV8 0
 #define HAVE_NEON 0
 #define HAVE_VFP 1
@@ -87,7 +87,7 @@
 #define HAVE_MMI 0
 #define HAVE_ARMV5TE_EXTERNAL 1
 #define HAVE_ARMV6_EXTERNAL 1
-#define HAVE_ARMV6T2_EXTERNAL 1
+#define HAVE_ARMV6T2_EXTERNAL 0
 #define HAVE_ARMV8_EXTERNAL 0
 #define HAVE_NEON_EXTERNAL 0
 #define HAVE_VFP_EXTERNAL 1
@@ -133,7 +133,7 @@
 #define HAVE_MMI_EXTERNAL 0
 #define HAVE_ARMV5TE_INLINE 1
 #define HAVE_ARMV6_INLINE 1
-#define HAVE_ARMV6T2_INLINE 1
+#define HAVE_ARMV6T2_INLINE 0
 #define HAVE_ARMV8_INLINE 0
 #define HAVE_NEON_INLINE 0
 #define HAVE_VFP_INLINE 1
@@ -595,7 +595,7 @@
 #define CONFIG_NEON_CLOBBER_TEST 0
 #define CONFIG_OSSFUZZ 0
 #define CONFIG_PIC 1
-#define CONFIG_THUMB 1
+#define CONFIG_THUMB 0
 #define CONFIG_VALGRIND_BACKTRACE 0
 #define CONFIG_XMM_CLOBBER_TEST 0
 #define CONFIG_BSFS 1
diff --git a/src/third_party/libyuv/BUILD.gn b/src/third_party/libyuv/BUILD.gn
index e1c7c1da..326bc019 100644
--- a/src/third_party/libyuv/BUILD.gn
+++ b/src/third_party/libyuv/BUILD.gn
@@ -209,6 +209,11 @@ if (libyuv_use_neon) {
 
     if (current_cpu != "arm64") {
       configs -= [ "//build/config/compiler:compiler_arm_fpu" ]
+      if (arm_version < 7) {
+        configs += [
+          "//build/config/compiler:force_march_armv7",
+        ]
+      }
       cflags = [ "-mfpu=neon" ]
     }
   }
diff --git a/src/third_party/libyuv/source/cpu_id.cc b/src/third_party/libyuv/source/cpu_id.cc
index fe89452b..aad0ea6d 100644
--- a/src/third_party/libyuv/source/cpu_id.cc
+++ b/src/third_party/libyuv/source/cpu_id.cc
@@ -133,6 +133,18 @@ int GetXCR0() {
 #pragma optimize("g", on)
 #endif
 
+#ifdef __ARMEL__
+// This is (a) simpler and (b) works in sandbox vs the /proc/cpuinfo method
+#include <sys/auxv.h>
+
+int ArmCpuCaps(const char* cpuinfo_name) {
+  const unsigned long auxval = getauxval(AT_HWCAP);
+
+  // Documentation suggests that getauxval(AT_HWCAP) should return a pointer
+  // to a bit array, but evidence suggests it returns a simple bit field
+  return ((auxval & HWCAP_ARM_NEON) != 0 ? kCpuHasNEON : 0);
+}
+#else
 // based on libvpx arm_cpudetect.c
 // For Arm, but public to allow testing on any CPU
 LIBYUV_API SAFEBUFFERS int ArmCpuCaps(const char* cpuinfo_name) {
@@ -161,6 +173,7 @@ LIBYUV_API SAFEBUFFERS int ArmCpuCaps(const char* cpuinfo_name) {
   fclose(f);
   return 0;
 }
+#endif
 
 // TODO(fbarchard): Consider read_msa_ir().
 LIBYUV_API SAFEBUFFERS int MipsCpuCaps(const char* cpuinfo_name) {
diff --git a/src/third_party/skia/include/core/SkSpan.h b/src/third_party/skia/include/core/SkSpan.h
index b09ec867a0..2317e16924 100644
--- a/src/third_party/skia/include/core/SkSpan.h
+++ b/src/third_party/skia/include/core/SkSpan.h
@@ -76,9 +76,9 @@ template <typename T, typename S> inline constexpr SkSpan<T> SkMakeSpan(T* p, S
     return SkSpan<T>{p, SkTo<size_t>(s)};
 }
 
-template <size_t N, typename T> inline constexpr SkSpan<T> SkMakeSpan(T (&a)[N]) {
-    return SkSpan<T>{a, N};
-}
+//template <size_t N, typename T> inline constexpr SkSpan<T> SkMakeSpan(T (&a)[N]) {
+//    return SkSpan<T>{a, N};
+//}
 
 template <typename Container>
 inline auto SkMakeSpan(Container& c)
diff --git a/src/third_party/skia/src/core/SkBitmapProcState.cpp b/src/third_party/skia/src/core/SkBitmapProcState.cpp
index 6f3d73d6c0..ad47d32b5b 100755
--- a/src/third_party/skia/src/core/SkBitmapProcState.cpp
+++ b/src/third_party/skia/src/core/SkBitmapProcState.cpp
@@ -19,6 +19,7 @@
 #include "src/core/SkResourceCache.h"
 #include "src/core/SkUtils.h"
 
+#if !defined(SK_ARM_HAS_NEON) || defined(__ARM_64BIT_STATE)
 // One-stop-shop shader for,
 //   - nearest-neighbor sampling (_nofilter_),
 //   - clamp tiling in X and Y both (Clamp_),
@@ -74,6 +75,201 @@ static void Clamp_S32_opaque_D32_nofilter_DX_shaderproc(const void* sIn, int x,
         }
     }
 }
+#endif
+
+// We define two variants of this: one for 32-bit ARM NEON, and one generic C:
+
+#if defined(SK_ARM_HAS_NEON) && !defined(__ARM_64BIT_STATE)
+static inline void Clamp_S32_opaque_D32_nofilter_DX_shaderproc_core_neon(SkPMColor* __restrict__ &dst, const SkPMColor* __restrict__ src, int core, SkFractionalInt fx, const SkFractionalInt dx)
+{
+    const SkPMColor*p = src + (int32_t)(fx >> 32);
+    uint32_t accum = (uint32_t) fx;
+    const SkPMColor *p2;
+    __asm__ volatile (
+            "cmp     %[core], #0           \n\t"
+            "it      ne                    \n\t"
+            "tstne   %[dst], #0xc          \n\t"
+            "beq     2f                    \n\t"
+            "1:                            \n\t"
+            "vldr    s0, [%[p]]            \n\t"
+            "adds    %[accum], %[dx]       \n\t"
+            "ite     cc                    \n\t"
+            "addcc   %[p], %[inc1]         \n\t"
+            "addcs   %[p], %[inc2]         \n\t"
+            "vstm    %[dst]!, {s0}         \n\t"
+            "subs    %[core], #1           \n\t"
+            "it      ne                    \n\t"
+            "tstne   %[dst], #0xc          \n\t"
+            "bne     1b                    \n\t"
+            "2:                            \n\t"
+            "adds    %[accum], %[dx]       \n\t"
+            "ite     cc                    \n\t"
+            "addcc   %[p2], %[p], %[inc1]  \n\t"
+            "addcs   %[p2], %[p], %[inc2]  \n\t"
+            "subs    %[core], #4           \n\t"
+            "bcc     4f                    \n\t"
+            "3:                            \n\t"
+            "vldr    s0, [%[p]]            \n\t"
+            "adds    %[accum], %[dx]       \n\t"
+            "ite     cc                    \n\t"
+            "addcc   %[p], %[p2], %[inc1]  \n\t"
+            "addcs   %[p], %[p2], %[inc2]  \n\t"
+            "vldr    s1, [%[p2]]           \n\t"
+            "adds    %[accum], %[dx]       \n\t"
+            "ite     cc                    \n\t"
+            "addcc   %[p2], %[p], %[inc1]  \n\t"
+            "addcs   %[p2], %[p], %[inc2]  \n\t"
+            "vldr    s2, [%[p]]            \n\t"
+            "adds    %[accum], %[dx]       \n\t"
+            "ite     cc                    \n\t"
+            "addcc   %[p], %[p2], %[inc1]  \n\t"
+            "addcs   %[p], %[p2], %[inc2]  \n\t"
+            "vldr    s3, [%[p2]]           \n\t"
+            "adds    %[accum], %[dx]       \n\t"
+            "ite     cc                    \n\t"
+            "addcc   %[p2], %[p], %[inc1]  \n\t"
+            "addcs   %[p2], %[p], %[inc2]  \n\t"
+            "vst1.32 {q0}, [%[dst] :128]!  \n\t"
+            "subs    %[core], #4           \n\t"
+            "bcs     3b                    \n\t"
+            "4:                            \n\t"
+            "adds    %[core], #4           \n\t"
+            "beq     6f                    \n\t"
+            "5:                            \n\t"
+            "vldr    s0, [%[p]]            \n\t"
+            "mov     %[p], %[p2]           \n\t"
+            "adds    %[accum], %[dx]       \n\t"
+            "ite     cc                    \n\t"
+            "addcc   %[p2], %[p], %[inc1]  \n\t"
+            "addcs   %[p2], %[p], %[inc2]  \n\t"
+            "vstm    %[dst]!, {s0}         \n\t"
+            "subs    %[core], #1           \n\t"
+            "bne     5b                    \n\t"
+            "6:                            \n\t"
+    : // Outputs
+            [accum]"+r"(accum),
+             [core]"+r"(core),
+              [dst]"+r"(dst),
+                [p]"+r"(p),
+               [p2]"=&r"(p2)
+    : // Inputs
+              [dx]"r"((int32_t) dx),
+            [inc1]"r"((int32_t)(dx >> 32) * 4),
+            [inc2]"r"(((int32_t)(dx >> 32) + 1) * 4)
+    : // Clobbers
+            "cc", "memory"
+    );
+}
+#endif
+
+#if 0
+static inline void Clamp_S32_opaque_D32_nofilter_DX_shaderproc_core(SkPMColor* __restrict__ &dst, const SkPMColor* __restrict__ src, int core, SkFractionalInt fx, const SkFractionalInt dx)
+{
+    const SkPMColor*p = src + (int32_t)(fx >> 32);
+    uint32_t accum = (uint32_t) fx;
+    for (; core > 0; --core) {
+        *dst++ = *p;
+        uint32_t prev_accum = accum;
+        accum += (int32_t) dx;
+        if (accum < prev_accum) /* i.e. carry set */
+            p += (int32_t)(dx >> 32) + 1;
+        else
+            p += (int32_t)(dx >> 32);
+    }
+}
+#endif
+
+#define Clamp_S32_opaque_D32_nofilter_DX_shaderproc_template(SUFFIX)                               \
+static void Clamp_S32_opaque_D32_nofilter_DX_shaderproc(const void* sIn, int x, int y,             \
+                                                        SkPMColor* SK_RESTRICT dst,  int count) {  \
+    const SkBitmapProcState& s = *static_cast<const SkBitmapProcState*>(sIn);                      \
+    SkASSERT((s.fInvType & ~(SkMatrix::kTranslate_Mask |                                           \
+                             SkMatrix::kScale_Mask)) == 0);                                        \
+    SkASSERT(s.fAlphaScale == 256);                                                                \
+                                                                                                   \
+    const unsigned maxX = s.fPixmap.width() - 1;                                                   \
+    SkFractionalInt fx;                                                                            \
+    int dstY;                                                                                      \
+    {                                                                                              \
+        const SkBitmapProcStateAutoMapper mapper(s, x, y);                                         \
+        const unsigned maxY = s.fPixmap.height() - 1;                                              \
+        dstY = SkTPin(mapper.intY(), 0, (int)maxY);                                                    \
+        fx = mapper.fractionalIntX();                                                              \
+    }                                                                                              \
+                                                                                                   \
+    const SkPMColor* SK_RESTRICT src = s.fPixmap.addr32(0, dstY);                                  \
+    const SkFractionalInt dx = s.fInvSxFractionalInt;                                              \
+                                                                                                   \
+    int core;                                                                                      \
+                                                                                                   \
+    /* The unscaled case is easily common enough to be worth special-casing.                       \
+     * The system memcpy() is typically already heavily optimized, so just use that.               \
+     */                                                                                            \
+    if (dx == 0x100000000ll) {                                                                     \
+        int32_t fx_integer = fx >> 32;                                                             \
+        if (fx_integer < 0) {                                                                      \
+            int left = std::min(-fx_integer, count);                                                \
+            fx_integer += left;                                                                    \
+            count -= left;                                                                         \
+            for (; left > 0; --left)                                                               \
+                *dst++ = src[0];                                                                   \
+        }                                                                                          \
+        if (fx_integer < (int)maxX) {                                                              \
+            core = std::min((int)maxX + 1 - fx_integer, count);                                     \
+            memcpy(dst, src + fx_integer, core * sizeof (uint32_t));                               \
+            dst += core;                                                                           \
+            count -= core;                                                                         \
+        }                                                                                          \
+        for (; count > 0; --count) {                                                               \
+            *dst++ = src[maxX];                                                                    \
+        }                                                                                          \
+    }                                                                                              \
+                                                                                                   \
+    /* Handle other non-reflected scale factors. */                                                \
+    else if (dx >= 0) {                                                                            \
+        for (; fx < 0 && count > 0; --count) {                                                     \
+            *dst++ = src[0];                                                                       \
+            fx += dx;                                                                              \
+        }                                                                                          \
+        if ((int32_t)(fx >> 32) > (int)maxX)                                                       \
+            core = 0;                                                                              \
+        else if ((int32_t)((fx + (count - 1) * dx) >> 32) <= (int)maxX)                            \
+            core = count;                                                                          \
+        else                                                                                       \
+            core = (int32_t)(((((SkFractionalInt) maxX) << 32) + 0xffffffff - fx) / dx) + 1;       \
+        Clamp_S32_opaque_D32_nofilter_DX_shaderproc_core##SUFFIX(dst, src, core, fx, dx);          \
+        count -= core;                                                                             \
+        for (; count > 0; --count) {                                                               \
+            *dst++ = src[maxX];                                                                    \
+        }                                                                                          \
+    }                                                                                              \
+                                                                                                   \
+    /* It's not clear if reflection is used, but it's a relatively                                 \
+     * simple variation on the non-reflected case. */                                              \
+    else                                                                                           \
+    {                                                                                              \
+        for (; (int32_t)(fx >> 32) > (int)maxX && count > 0; --count) {                            \
+            *dst++ = src[maxX];                                                                    \
+            fx += dx;                                                                              \
+        }                                                                                          \
+        if (fx < 0)                                                                                \
+            core = 0;                                                                              \
+        else if (fx + (count - 1) * dx >= 0)                                                       \
+            core = count;                                                                          \
+        else                                                                                       \
+            core = (int32_t)(fx / -dx) + 1;                                                        \
+        Clamp_S32_opaque_D32_nofilter_DX_shaderproc_core##SUFFIX(dst, src, core, fx, dx);          \
+        count -= core;                                                                             \
+        for (; count > 0; --count) {                                                               \
+            *dst++ = src[0];                                                                       \
+        }                                                                                          \
+    }                                                                                              \
+}
+
+#if defined(SK_ARM_HAS_NEON) && !defined(__ARM_64BIT_STATE)
+Clamp_S32_opaque_D32_nofilter_DX_shaderproc_template(_neon)
+#endif
+
 
 static void S32_alpha_D32_nofilter_DX(const SkBitmapProcState& s,
                                       const uint32_t* xy, int count, SkPMColor* colors) {
@@ -272,7 +468,11 @@ bool SkBitmapProcState::chooseProcs() {
     SkASSERT(fMatrixProc);
 
     if (fInvMatrix.isScaleTranslate()) {
+#if defined(SK_ARM_HAS_NEON) && !defined(__ARM_64BIT_STATE)
+        fSampleProc32 = fBilerp ? (fAlphaScale == 256 ? SkOpts::S32_opaque_D32_filter_DX : SkOpts::S32_alpha_D32_filter_DX)   : S32_alpha_D32_nofilter_DX  ;
+#else
         fSampleProc32 = fBilerp ? SkOpts::S32_alpha_D32_filter_DX   : S32_alpha_D32_nofilter_DX  ;
+#endif
     } else {
         fSampleProc32 = fBilerp ? SkOpts::S32_alpha_D32_filter_DXDY : S32_alpha_D32_nofilter_DXDY;
     }
diff --git a/src/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp b/src/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp
index 6bf39bf60a..bbdc0be36a 100755
--- a/src/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp
+++ b/src/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp
@@ -247,6 +247,535 @@ static unsigned clamp(SkFixed fx, int max) {
     return SkTPin(fx >> 16, 0, max);
 }
 
+// Clamp/Clamp and Repeat/Repeat have NEON or portable implementations.
+#if defined(SK_ARM_HAS_NEON)
+    #include <arm_neon.h>
+
+    // TODO: this is a fine drop-in for decal_nofilter_scale() generally.
+    static void decal_nofilter_scale_neon(uint32_t dst[], SkFixed fx, SkFixed dx, int count) {
+        if (count >= 8) {
+            // SkFixed is 16.16 fixed point
+            SkFixed dx8 = dx * 8;
+            int32x4_t vdx8 = vdupq_n_s32(dx8);
+
+            // setup lbase and hbase
+            int32x4_t lbase, hbase;
+            lbase = vdupq_n_s32(fx);
+            lbase = vsetq_lane_s32(fx + dx, lbase, 1);
+            lbase = vsetq_lane_s32(fx + dx + dx, lbase, 2);
+            lbase = vsetq_lane_s32(fx + dx + dx + dx, lbase, 3);
+            hbase = lbase + vdupq_n_s32(4 * dx);
+
+            do {
+                // store the upper 16 bits
+                vst1q_u32(dst, vreinterpretq_u32_s16(
+                    vuzpq_s16(vreinterpretq_s16_s32(lbase), vreinterpretq_s16_s32(hbase)).val[1]
+                ));
+
+                // on to the next group of 8
+                lbase += vdx8;
+                hbase += vdx8;
+                dst += 4; // we did 8 elements but the result is twice smaller
+                count -= 8;
+                fx += dx8;
+            } while (count >= 8);
+        }
+
+        uint16_t* xx = (uint16_t*)dst;
+        for (int i = count; i > 0; --i) {
+            *xx++ = SkToU16(fx >> 16); fx += dx;
+        }
+    }
+
+    static void decal_filter_scale_neon(uint32_t dst[], SkFixed fx, SkFixed dx, int count) {
+#ifndef __ARM_64BIT_STATE
+        SkASSERT(((fx + (count-1) * dx) >> (16 + 14)) == 0);
+        fx = (fx << 2) + 1;
+        dx <<= 2;
+        while (((uintptr_t) dst & 0xf) && --count >= 0) {
+            *dst++ = (fx & 0xffffc001) + (fx >> 18);
+            fx += dx;
+        }
+        if ((count -= 4) >= 0) {
+            uint32_t tmp;
+            __asm__ (
+                    "adr         %[tmp], 1f                  \n\t"
+                    "vmvn.i32    q10, #0x3fff                \n\t"
+                    "vld1.32     {q11}, [%[tmp]]             \n\t"
+                    "vdup.32     q8, %[fx]                   \n\t"
+                    "vdup.32     q9, %[dx]                   \n\t"
+                    "vsra.u32    q10, #31                    \n\t"
+                    "vmla.u32    q8, q9, q11                 \n\t"
+                    "vshl.u32    q9, #2                      \n\t"
+                    "b           2f                          \n\t"
+                    "1:                                      \n\t"
+                    ".long       0                           \n\t"
+                    ".long       1                           \n\t"
+                    ".long       2                           \n\t"
+                    ".long       3                           \n\t"
+                    "2:                                      \n\t"
+                    "vand        q11, q8, q10                \n\t"
+                    "vshr.u32    q12, q8, #18                \n\t"
+                    "vadd.i32    q11, q12                    \n\t"
+                    "vadd.i32    q8, q9                      \n\t"
+                    "subs        %[count], #4                \n\t"
+                    "vst1.32     {q11}, [%[dst]:128]!        \n\t"
+                    "bpl         2b                          \n\t"
+                    "vmov.32     %[fx], d16[0]               \n\t"
+            : // Outputs
+                    [count]"+l"(count),
+                      [dst]"+r"(dst),
+                       [fx]"+r"(fx),
+                      [tmp]"=&r"(tmp)
+            : // Inputs
+                    [dx]"r"(dx)
+            : // Clobbers
+                    "cc", "memory"
+            );
+        }
+        if ((count += 4-1) >= 0) {
+            do {
+                *dst++ = (fx & 0xffffc001) + (fx >> 18);
+                fx += dx;
+            } while (--count >= 0);
+        }
+#else // !defined(__ARM_64BIT_STATE)
+        if (count >= 8) {
+            SkFixed dx8 = dx * 8;
+            int32x4_t vdx8 = vdupq_n_s32(dx8);
+
+            int32x4_t wide_fx, wide_fx2;
+            wide_fx = vdupq_n_s32(fx);
+            wide_fx = vsetq_lane_s32(fx + dx, wide_fx, 1);
+            wide_fx = vsetq_lane_s32(fx + dx + dx, wide_fx, 2);
+            wide_fx = vsetq_lane_s32(fx + dx + dx + dx, wide_fx, 3);
+
+            wide_fx2 = vaddq_s32(wide_fx, vdupq_n_s32(4 * dx));
+
+            while (count >= 8) {
+                int32x4_t wide_out;
+                int32x4_t wide_out2;
+
+                wide_out = vshlq_n_s32(vshrq_n_s32(wide_fx, 12), 14);
+                wide_out = wide_out | (vshrq_n_s32(wide_fx,16) + vdupq_n_s32(1));
+
+                wide_out2 = vshlq_n_s32(vshrq_n_s32(wide_fx2, 12), 14);
+                wide_out2 = wide_out2 | (vshrq_n_s32(wide_fx2,16) + vdupq_n_s32(1));
+
+                vst1q_u32(dst, vreinterpretq_u32_s32(wide_out));
+                vst1q_u32(dst+4, vreinterpretq_u32_s32(wide_out2));
+
+                dst += 8;
+                fx += dx8;
+                wide_fx += vdx8;
+                wide_fx2 += vdx8;
+                count -= 8;
+            }
+        }
+
+        if (count & 1)
+        {
+            SkASSERT((fx >> (16 + 14)) == 0);
+            *dst++ = (fx >> 12 << 14) | ((fx >> 16) + 1);
+            fx += dx;
+        }
+        while ((count -= 2) >= 0)
+        {
+            SkASSERT((fx >> (16 + 14)) == 0);
+            *dst++ = (fx >> 12 << 14) | ((fx >> 16) + 1);
+            fx += dx;
+
+            *dst++ = (fx >> 12 << 14) | ((fx >> 16) + 1);
+            fx += dx;
+        }
+#endif
+    }
+
+    static inline int16x8_t clamp8(int32x4_t low, int32x4_t high, unsigned max) {
+        int16x8_t res;
+
+        // get the hi 16s of all those 32s
+        res = vuzpq_s16(vreinterpretq_s16_s32(low), vreinterpretq_s16_s32(high)).val[1];
+
+        // clamp
+        res = vmaxq_s16(res, vdupq_n_s16(0));
+        res = vminq_s16(res, vdupq_n_s16(max));
+
+        return res;
+    }
+
+    static inline int32x4_t clamp4(int32x4_t f, unsigned max) {
+        int32x4_t res;
+
+        // get the hi 16s of all those 32s
+        res = vshrq_n_s32(f, 16);
+
+        // clamp
+        res = vmaxq_s32(res, vdupq_n_s32(0));
+        res = vminq_s32(res, vdupq_n_s32(max));
+
+        return res;
+    }
+
+    static inline int32x4_t extract_low_bits_clamp4(int32x4_t fx, unsigned) {
+        int32x4_t ret;
+
+        ret = vshrq_n_s32(fx, 12);
+
+        /* We don't need the mask below because the caller will
+         * overwrite the non-masked bits
+         */
+        //ret = vandq_s32(ret, vdupq_n_s32(0xF));
+
+        return ret;
+    }
+
+    static inline int16x8_t repeat8(int32x4_t low, int32x4_t high, unsigned max) {
+        uint16x8_t res;
+        uint32x4_t tmpl, tmph;
+
+        // get the lower 16 bits
+        res = vuzpq_u16(vreinterpretq_u16_s32(low), vreinterpretq_u16_s32(high)).val[0];
+
+        // bare multiplication, not SkFixedMul
+        tmpl = vmull_u16(vget_low_u16(res), vdup_n_u16(max+1));
+        tmph = vmull_u16(vget_high_u16(res), vdup_n_u16(max+1));
+
+        // extraction of the 16 upper bits
+        res = vuzpq_u16(vreinterpretq_u16_u32(tmpl), vreinterpretq_u16_u32(tmph)).val[1];
+
+        return vreinterpretq_s16_u16(res);
+    }
+
+    static inline int32x4_t repeat4(int32x4_t f, unsigned max) {
+        uint16x4_t res;
+        uint32x4_t tmp;
+
+        // get the lower 16 bits
+        res = vmovn_u32(vreinterpretq_u32_s32(f));
+
+        // bare multiplication, not SkFixedMul
+        tmp = vmull_u16(res, vdup_n_u16(max+1));
+
+        // extraction of the 16 upper bits
+        tmp = vshrq_n_u32(tmp, 16);
+
+        return vreinterpretq_s32_u32(tmp);
+    }
+
+    static inline int32x4_t extract_low_bits_repeat_mirror4(int32x4_t fx, unsigned max) {
+        uint16x4_t res;
+        uint32x4_t tmp;
+        int32x4_t ret;
+
+        // get the lower 16 bits
+        res = vmovn_u32(vreinterpretq_u32_s32(fx));
+
+        // bare multiplication, not SkFixedMul
+        tmp = vmull_u16(res, vdup_n_u16(max + 1));
+
+        // shift and mask
+        ret = vshrq_n_s32(vreinterpretq_s32_u32(tmp), 12);
+
+        /* We don't need the mask below because the caller will
+         * overwrite the non-masked bits
+         */
+        //ret = vandq_s32(ret, vdupq_n_s32(0xF));
+
+        return ret;
+    }
+
+    template <unsigned   (*tile)(SkFixed, int),
+              int16x8_t (*tile8)(int32x4_t, int32x4_t, unsigned),
+             bool tryDecal>
+    static void nofilter_scale_neon(const SkBitmapProcState& s,
+                                    uint32_t xy[], int count, int x, int y) {
+        SkASSERT((s.fInvType & ~(SkMatrix::kTranslate_Mask |
+                                 SkMatrix::kScale_Mask)) == 0);
+
+        // we store y, x, x, x, x, x
+        const unsigned maxX = s.fPixmap.width() - 1;
+        SkFractionalInt fx;
+        {
+            const SkBitmapProcStateAutoMapper mapper(s, x, y);
+            const unsigned maxY = s.fPixmap.height() - 1;
+            *xy++ = tile(mapper.fixedY(), maxY);
+            fx = mapper.fractionalIntX();
+        }
+
+        if (0 == maxX) {
+            // all of the following X values must be 0
+            memset(xy, 0, count * sizeof(uint16_t));
+            return;
+        }
+
+        const SkFractionalInt dx = s.fInvSxFractionalInt;
+
+        // test if we don't need to apply the tile proc
+        const SkFixed fixedFx = SkFractionalIntToFixed(fx);
+        const SkFixed fixedDx = SkFractionalIntToFixed(dx);
+        if (tryDecal && can_truncate_to_fixed_for_decal(fixedFx, fixedDx, count, maxX)) {
+            decal_nofilter_scale_neon(xy, fixedFx, fixedDx, count);
+            return;
+        }
+
+        if (count >= 8) {
+            SkFractionalInt dx2 = dx+dx;
+            SkFractionalInt dx4 = dx2+dx2;
+            SkFractionalInt dx8 = dx4+dx4;
+
+            // now build fx/fx+dx/fx+2dx/fx+3dx
+            SkFractionalInt fx1, fx2, fx3;
+            int32x4_t lbase, hbase;
+            int16_t *dst16 = (int16_t *)xy;
+
+            fx1 = fx+dx;
+            fx2 = fx1+dx;
+            fx3 = fx2+dx;
+
+            lbase = vdupq_n_s32(SkFractionalIntToFixed(fx));
+            lbase = vsetq_lane_s32(SkFractionalIntToFixed(fx1), lbase, 1);
+            lbase = vsetq_lane_s32(SkFractionalIntToFixed(fx2), lbase, 2);
+            lbase = vsetq_lane_s32(SkFractionalIntToFixed(fx3), lbase, 3);
+            hbase = vaddq_s32(lbase, vdupq_n_s32(SkFractionalIntToFixed(dx4)));
+
+            // store & bump
+            while (count >= 8) {
+
+                int16x8_t fx8;
+
+                fx8 = tile8(lbase, hbase, maxX);
+
+                vst1q_s16(dst16, fx8);
+
+                // but preserving base & on to the next
+                lbase = vaddq_s32 (lbase, vdupq_n_s32(SkFractionalIntToFixed(dx8)));
+                hbase = vaddq_s32 (hbase, vdupq_n_s32(SkFractionalIntToFixed(dx8)));
+                dst16 += 8;
+                count -= 8;
+                fx += dx8;
+            }
+            xy = (uint32_t *) dst16;
+        }
+
+        uint16_t* xx = (uint16_t*)xy;
+        for (int i = count; i > 0; --i) {
+            *xx++ = tile(SkFractionalIntToFixed(fx), maxX);
+            fx += dx;
+        }
+    }
+
+    template <unsigned              (*tile )(SkFixed, int),
+              int32x4_t             (*tile4)(int32x4_t, unsigned),
+              unsigned  (*extract_low_bits )(SkFixed, int),
+              int32x4_t (*extract_low_bits4)(int32x4_t, unsigned),
+              bool tryDecal>
+    static void filter_scale_neon(const SkBitmapProcState& s,
+                                  unsigned int * xy, int count, int x, int y) {
+        SkASSERT((s.fInvType & ~(SkMatrix::kTranslate_Mask |
+                                 SkMatrix::kScale_Mask)) == 0);
+        SkASSERT(s.fInvKy == 0);
+
+        auto pack = [&](SkFixed f, unsigned max, SkFixed one) {
+            unsigned i = tile(f, max);
+            i = (i << 4) | extract_low_bits(f, max);
+            return (i << 14) | (tile((f + one), max));
+        };
+
+        auto pack4 = [&](int32x4_t f, unsigned max, SkFixed one) {
+            int32x4_t ret, res;
+
+            res = tile4(f, max);
+
+            ret = extract_low_bits4(f, max);
+            ret = vsliq_n_s32(ret, res, 4);
+
+            res = tile4(f + vdupq_n_s32(one), max);
+            ret = vorrq_s32(vshlq_n_s32(ret, 14), res);
+
+            return ret;
+        };
+
+        const unsigned maxX = s.fPixmap.width() - 1;
+        const SkFixed one = s.fFilterOneX;
+        const SkFractionalInt dx = s.fInvSxFractionalInt;
+        SkFractionalInt fx;
+
+        {
+            const SkBitmapProcStateAutoMapper mapper(s, x, y);
+            const SkFixed fy = mapper.fixedY();
+            const unsigned maxY = s.fPixmap.height() - 1;
+            // compute our two Y values up front
+            *xy++ = pack(fy, maxY, s.fFilterOneY);
+            // now initialize fx
+            fx = mapper.fractionalIntX();
+        }
+
+        // test if we don't need to apply the tile proc
+        const SkFixed fixedFx = SkFractionalIntToFixed(fx);
+        const SkFixed fixedDx = SkFractionalIntToFixed(dx);
+        if (tryDecal && can_truncate_to_fixed_for_decal(fixedFx, fixedDx, count, maxX)) {
+            decal_filter_scale_neon(xy, fixedFx, fixedDx, count);
+            return;
+        }
+
+#ifndef __ARM_64BIT_STATE
+        if (tile == clamp && one == SK_Fixed1) {
+            SkASSERT(maxX < (1<<14)-1);
+            if (dx >= 0) {
+                --count;
+                while (count >= 0 && fx < 0) {
+                    *xy++ = 0;
+                    fx += dx;
+                    --count;
+                }
+                while (count >= 0 && ((uintptr_t) xy & 0xf) && fx < ((SkFractionalInt) maxX << 32)) {
+                    *xy++ = ((uint32_t)(fx >> 14) & 0xffffc000) + (uint32_t)(fx >> 32) + 1;
+                    fx += dx;
+                    --count;
+                }
+                if ((count -= 8-1) >= 0 && fx + 7*dx < ((SkFractionalInt) maxX << 32)) {
+                    SkFractionalInt rem = (((SkFractionalInt) maxX << 32) - 7*dx - fx - 1) / 8;
+                    int32_t rem_hi = rem >> 32;
+                    uint32_t rem_lo = (uint32_t) rem;
+                    int32_t fx_hi = fx >> 32;
+                    uint32_t fx_lo = (uint32_t) fx;
+                    __asm__ (
+                            "vmov        d16, %[fx_lo], %[fx_hi]     \n\t"
+                            "vmov        d24, %[dx_lo], %[dx_hi]     \n\t"
+                            "vadd.i64    d17, d16, d24               \n\t"
+                            "vmov        d25, %[dx_lo], %[dx_hi]     \n\t"
+                            "vmvn.i32    q13, #0x3fff                \n\t"
+                            "vadd.i64    d18, d17, d24               \n\t"
+                            "vmov.i32    q14, #1                     \n\t"
+                            "vadd.i64    d19, d18, d24               \n\t"
+                            "vshl.i64    q12, #2                     \n\t"
+                            "b           2f                          \n\t"
+                            "1:                                      \n\t"
+                            "vadd.i64    q8, q10, q12                \n\t"
+                            "vadd.i64    q9, q11, q12                \n\t"
+                            "2:                                      \n\t"
+                            "vadd.i64    q10, q8, q12                \n\t"
+                            "vadd.i64    q11, q9, q12                \n\t"
+                            "vshrn.i64   d16, q8, #14                \n\t"
+                            "vshrn.i64   d17, q9, #14                \n\t"
+                            "vand        q8, q13                     \n\t"
+                            "vorr        q8, q14                     \n\t"
+                            "vshrn.i64   d18, q10, #14               \n\t"
+                            "vshrn.i64   d19, q11, #14               \n\t"
+                            "vand        q9, q13                     \n\t"
+                            "subs        %[rem_lo], %[dx_lo]         \n\t"
+                            "vorr        q9, q14                     \n\t"
+                            "sbcs        %[rem_hi], %[dx_hi]         \n\t"
+                            "vsra.u32    q8, #18                     \n\t"
+                            "subs        %[count], #8                \n\t"
+                            "vsra.u32    q9, #18                     \n\t"
+                            "it          pl                          \n\t"
+                            "teqpl       %[rem_hi], #0               \n\t"
+                            "vst1.32     {q8-q9}, [%[dst]:128]!      \n\t"
+                            "bpl         1b                          \n\t"
+                            "vadd.i64    d16, d20, d24               \n\t"
+                            "vmov        %[fx_lo], %[fx_hi], d16     \n\t"
+                    : // Outputs
+                             [count]"+l"(count),
+                               [dst]"+r"(xy),
+                            [rem_hi]"+l"(rem_hi),
+                            [rem_lo]"+l"(rem_lo),
+                             [fx_hi]"+r"(fx_hi),
+                             [fx_lo]"+r"(fx_lo)
+                    : // Inputs
+                            [dx_hi]"l"((int32_t) (dx >> 32)),
+                            [dx_lo]"l"((uint32_t) dx)
+                    : // Clobbers
+                            "cc", "memory"
+                    );
+                    fx = ((SkFractionalInt) fx_hi << 32) | fx_lo;
+                }
+                count += 8-1;
+                while (count >= 0 && fx < ((SkFractionalInt) maxX << 32)) {
+                    *xy++ = ((uint32_t)(fx >> 14) & 0xffffc000) + (uint32_t)(fx >> 32) + 1;
+                    fx += dx;
+                    --count;
+                }
+                while (count >= 0) {
+                    *xy++ = (maxX << 18) + maxX;
+                    --count;
+                }
+            } else {
+                // Reflection case. Don't bother to optimize this as much -
+                // not even sure if it's used!
+                while (count >= 1 && fx >= ((SkFractionalInt) maxX << 32)) {
+                    *xy++ = (maxX << 18) + maxX;
+                    fx += dx;
+                    --count;
+                }
+                while (count >= 1 && fx >= 0) {
+                    *xy++ = ((uint32_t)(fx >> 14) & 0xffffc000) + (uint32_t)(fx >> 32) + 1;
+                    fx += dx;
+                    --count;
+                }
+                while (count >= 1) {
+                    *xy++ = 0;
+                    --count;
+                }
+            }
+        }
+        else
+        {
+        // Drop back to old code for repeat or other values of 'one'
+#endif
+        if (count >= 4) {
+            int32x4_t wide_fx;
+
+            wide_fx = vdupq_n_s32(SkFractionalIntToFixed(fx));
+            wide_fx = vsetq_lane_s32(SkFractionalIntToFixed(fx+dx), wide_fx, 1);
+            wide_fx = vsetq_lane_s32(SkFractionalIntToFixed(fx+dx+dx), wide_fx, 2);
+            wide_fx = vsetq_lane_s32(SkFractionalIntToFixed(fx+dx+dx+dx), wide_fx, 3);
+
+            while (count >= 4) {
+                int32x4_t res;
+
+                res = pack4(wide_fx, maxX, one);
+
+                vst1q_u32(xy, vreinterpretq_u32_s32(res));
+
+                wide_fx += vdupq_n_s32(SkFractionalIntToFixed(dx+dx+dx+dx));
+                fx += dx+dx+dx+dx;
+                xy += 4;
+                count -= 4;
+            }
+        }
+
+        while (--count >= 0) {
+            *xy++ = pack(SkFractionalIntToFixed(fx), maxX, one);
+            fx += dx;
+        }
+#ifndef __ARM_64BIT_STATE
+        }
+#endif
+    }
+
+    static const SkBitmapProcState::MatrixProc ClampX_ClampY_Procs[] = {
+        nofilter_scale_neon<clamp, clamp8, true>,
+        filter_scale_neon<clamp,
+                          clamp4,
+                          extract_low_bits_clamp_clamp,
+                          extract_low_bits_clamp4,
+                          true>,
+        nofilter_affine<clamp, clamp>,       filter_affine<clamp, clamp, extract_low_bits_clamp_clamp>,
+    };
+
+    static const SkBitmapProcState::MatrixProc RepeatX_RepeatY_Procs[] = {
+        nofilter_scale_neon<repeat, repeat8, false>,
+        filter_scale_neon<repeat,
+                          repeat4,
+                          extract_low_bits_general,
+                          extract_low_bits_repeat_mirror4,
+                          false>,
+        nofilter_affine<repeat, repeat>,        filter_affine<repeat, repeat, extract_low_bits_general>
+    };
+#else
+
 static const SkBitmapProcState::MatrixProc ClampX_ClampY_Procs[] = {
     nofilter_scale <clamp, clamp, true>, filter_scale <clamp, clamp, extract_low_bits_clamp_clamp, true>,
     nofilter_affine<clamp, clamp>,       filter_affine<clamp, clamp, extract_low_bits_clamp_clamp>,
@@ -255,6 +784,9 @@ static const SkBitmapProcState::MatrixProc RepeatX_RepeatY_Procs[] = {
     nofilter_scale <repeat, repeat, false>, filter_scale <repeat, repeat, extract_low_bits_general, false>,
     nofilter_affine<repeat, repeat>,        filter_affine<repeat, repeat, extract_low_bits_general>
 };
+
+#endif
+
 static const SkBitmapProcState::MatrixProc MirrorX_MirrorY_Procs[] = {
     nofilter_scale <mirror, mirror,  false>, filter_scale <mirror, mirror, extract_low_bits_general, false>,
     nofilter_affine<mirror, mirror>,         filter_affine<mirror, mirror, extract_low_bits_general>,
diff --git a/src/third_party/skia/src/core/SkBlitter_ARGB32.cpp b/src/third_party/skia/src/core/SkBlitter_ARGB32.cpp
index a67d2e250c..1fe65e1d8e 100644
--- a/src/third_party/skia/src/core/SkBlitter_ARGB32.cpp
+++ b/src/third_party/skia/src/core/SkBlitter_ARGB32.cpp
@@ -11,6 +11,7 @@
 #include "src/core/SkCoreBlitters.h"
 #include "src/core/SkUtils.h"
 #include "src/core/SkXfermodePriv.h"
+#include "src/opts/SkBlitMask_opts.h"
 
 static inline int upscale_31_to_32(int value) {
     SkASSERT((unsigned)value <= 31);
@@ -1184,6 +1185,7 @@ static void drive(SkPMColor* dst, const SkPMColor* src, const uint8_t* cov, int
     }
 }
 
+#if 0
 static void blend_row_A8(SkPMColor* dst, const void* mask, const SkPMColor* src, int n) {
     auto cov = (const uint8_t*)mask;
     drive(dst, src, cov, n, [](U8x4 d, U8x4 s, U8x4 c) {
@@ -1192,6 +1194,7 @@ static void blend_row_A8(SkPMColor* dst, const void* mask, const SkPMColor* src,
         return s_aa + skvx::approx_scale(d, 255 - alpha);
     });
 }
+#endif
 
 static void blend_row_A8_opaque(SkPMColor* dst, const void* mask, const SkPMColor* src, int n) {
     auto cov = (const uint8_t*)mask;
@@ -1296,7 +1299,8 @@ void SkARGB32_Shader_Blitter::blitMask(const SkMask& mask, const SkIRect& clip)
         if (mask.fFormat == SkMask::kA8_Format && opaque) {
             blend_row = blend_row_A8_opaque;
         } else if (mask.fFormat == SkMask::kA8_Format) {
-            blend_row = blend_row_A8;
+            // blend_row_A8 has been ported to SkOpts, but not the others yet
+            blend_row = SkOpts::blit_row_s32a_a8;
         } else if (mask.fFormat == SkMask::kLCD16_Format && opaque) {
             blend_row = blend_row_LCD16_opaque;
         } else if (mask.fFormat == SkMask::kLCD16_Format) {
diff --git a/src/third_party/skia/src/core/SkOpts.cpp b/src/third_party/skia/src/core/SkOpts.cpp
index e69bedbfa0..adbb829334 100644
--- a/src/third_party/skia/src/core/SkOpts.cpp
+++ b/src/third_party/skia/src/core/SkOpts.cpp
@@ -58,6 +58,7 @@ namespace SkOpts {
     DEFINE_DEFAULT(create_xfermode);
 
     DEFINE_DEFAULT(blit_mask_d32_a8);
+    DEFINE_DEFAULT(blit_row_s32a_a8);
 
     DEFINE_DEFAULT(blit_row_color32);
     DEFINE_DEFAULT(blit_row_s32a_opaque);
@@ -89,6 +90,11 @@ namespace SkOpts {
     DEFINE_DEFAULT(S32_alpha_D32_filter_DXDY);
 
     DEFINE_DEFAULT(interpret_skvm);
+#if defined(SK_ARM_HAS_NEON) && !defined(__ARM_64BIT_STATE)
+    DEFINE_DEFAULT(S32_opaque_D32_filter_DX);
+#else
+    decltype(S32_opaque_D32_filter_DX) S32_opaque_D32_filter_DX = SK_OPTS_NS::S32_alpha_D32_filter_DX;
+#endif
 #undef DEFINE_DEFAULT
 
 #define M(st) (StageFn)SK_OPTS_NS::st,
diff --git a/src/third_party/skia/src/core/SkOpts.h b/src/third_party/skia/src/core/SkOpts.h
index 75eeffeb0a..c0aee965ca 100644
--- a/src/third_party/skia/src/core/SkOpts.h
+++ b/src/third_party/skia/src/core/SkOpts.h
@@ -29,6 +29,7 @@ namespace SkOpts {
 
     extern void (*blit_mask_d32_a8)(SkPMColor*, size_t, const SkAlpha*, size_t, SkColor, int, int);
     extern void (*blit_row_color32)(SkPMColor*, const SkPMColor*, int, SkPMColor);
+    extern void (*blit_row_s32a_a8)(SkPMColor*, const void*, const SkPMColor*, int);
     extern void (*blit_row_s32a_opaque)(SkPMColor*, const SkPMColor*, int, U8CPU);
 
     // Swizzle input into some sort of 8888 pixel, {premul,unpremul} x {rgba,bgra}.
@@ -66,6 +67,9 @@ namespace SkOpts {
     extern void (*S32_alpha_D32_filter_DXDY)(const SkBitmapProcState&,
                                              const uint32_t* xy, int count, SkPMColor*);
 
+    extern void (*S32_opaque_D32_filter_DX)(const SkBitmapProcState&,
+                                            const uint32_t* xy, int count, SkPMColor*);
+
 #define M(st) +1
     // We can't necessarily express the type of SkJumper stage functions here,
     // so we just use this void(*)(void) as a stand-in.
diff --git a/src/third_party/skia/src/opts/SkBitmapProcState_opts.h b/src/third_party/skia/src/opts/SkBitmapProcState_opts.h
index b8970e9e20..f243d622c9 100644
--- a/src/third_party/skia/src/opts/SkBitmapProcState_opts.h
+++ b/src/third_party/skia/src/opts/SkBitmapProcState_opts.h
@@ -387,6 +387,257 @@ static void decode_packed_coordinates_and_weight(U32 packed, Out* v0, Out* v1, O
         }
     }
 
+#elif defined(SK_ARM_HAS_NEON) && !defined(__ARM_64BIT_STATE)
+
+#define S32_ALPHA_D32_FILTER_DX_1PIX_NEON(opt)               \
+            "ldr         %[x], [%[xy]], #4           \n\t"   \
+            "uxth        %[tmp2], %[x], ror #16      \n\t"   \
+            "lsl         %[tmp3], %[x], #2           \n\t"   \
+            "bic         %[tmp2], #3                 \n\t"   \
+            "uxth        %[tmp3], %[tmp3]            \n\t"   \
+            "add         %[tmp0], %[row0], %[tmp2]   \n\t"   \
+            "add         %[tmp1], %[row0], %[tmp3]   \n\t"   \
+            "add         %[tmp2], %[row1], %[tmp2]   \n\t"   \
+            "add         %[tmp3], %[row1], %[tmp3]   \n\t"   \
+            "lsr         %[x], #14                   \n\t"   \
+            "vldr        s0, [%[tmp0]]               \n\t"   \
+            "and         %[x], #0xf                  \n\t"   \
+            "vldr        s1, [%[tmp1]]               \n\t"   \
+            "vldr        s2, [%[tmp2]]               \n\t"   \
+            "vldr        s3, [%[tmp3]]               \n\t"   \
+            "vdup.16     d2, %[x]                    \n\t"   \
+            "vsub.i16    d3, d23, d2                 \n\t"   \
+            "vmull.u8    q2, d0, d31                 \n\t"   \
+            "vmlal.u8    q2, d1, d30                 \n\t"   \
+            "vmul.u16    d0, d4, d3                  \n\t"   \
+            "vmla.u16    d0, d5, d2                  \n\t"   \
+            "vshr.u16    d0, #8                      \n\t"   \
+            "vmul.u16    d0, d10                     \n\t"   \
+            opt"                                     \n\t"   \
+            "vshrn.u16   d0, q0, #8                  \n\t"   \
+            "vst1.32     {d0[0]}, [%[dst]:32]!       \n\t"   \
+
+void S32_alpha_D32_filter_DX(const SkBitmapProcState& s,
+                             const uint32_t* SK_RESTRICT xy,
+                             int count, SkPMColor* SK_RESTRICT colors) {
+    SkASSERT(count > 0 && colors != nullptr);
+    SkASSERT(s.fFilterQuality != kNone_SkFilterQuality);
+    SkASSERT(4 == s.fPixmap.info().bytesPerPixel());
+    SkASSERT(s.fAlphaScale <= 256);
+
+    int y0, y1, wy;
+    decode_packed_coordinates_and_weight(*xy++, &y0, &y1, &wy);
+
+    auto row0 = (const uint32_t*)( (const char*)s.fPixmap.addr() + y0 * s.fPixmap.rowBytes() ),
+         row1 = (const uint32_t*)( (const char*)s.fPixmap.addr() + y1 * s.fPixmap.rowBytes() );
+
+    uint32_t tmp0, tmp1, tmp2, tmp3, x;
+    __asm__ volatile (
+            "vpush       {q4-q5}                     \n\t"
+            "vmov.i16    d22, #0xf                   \n\t"
+            "vmov.i16    d23, #0x10                  \n\t"
+            "vmov.i32    q12, #0x3fff                \n\t"
+            "vdup.32     q13, %[row0]                \n\t"
+            "vdup.32     q14, %[row1]                \n\t"
+            "vdup.i8     d30, %[subY]                \n\t"
+            "vmov.i8     d31, #16                    \n\t"
+            "vdup.16     q5, %[alpha]                \n\t"
+            "vshl.i32    q12, #2                     \n\t"
+            "tst         %[dst], #0xc                \n\t"
+            "vsub.i8     d31, d30                    \n\t"
+            "beq         2f                          \n\t"
+
+            "1:                                      \n\t"
+            S32_ALPHA_D32_FILTER_DX_1PIX_NEON(
+            "add         %[tmp0], %[dst], #4         \n\t"
+            "subs        %[len], #1                  \n\t"
+            "it          ne                          \n\t"
+            "tstne       %[tmp0], #0xc"
+            )
+            "bne         1b                          \n\t"
+
+            "2:"
+            "subs        %[len], #4                  \n\t"
+            "bmi         13f                         \n\t"
+
+            "vld1.32     {q8}, [%[xy]]!              \n\t"
+            "vshr.u32    q9, q8, #16                 \n\t"
+            "vand        q9, q12                     \n\t"
+            "vadd.i32    q1, q13, q9                 \n\t"
+            "vshl.i32    q0, q8, #2                  \n\t"
+            "vand        q0, q12                     \n\t"
+            "vadd.i32    q2, q13, q0                 \n\t"
+            "vmov        %[tmp0], s4                 \n\t"
+            "vmov        %[tmp1], s5                 \n\t"
+            "vadd.i32    q3, q14, q9                 \n\t"
+            "vmov        %[tmp2], %[tmp3], d3        \n\t"
+
+            "11:                                     \n\t"
+            "vadd.i32    q4, q14, q0                 \n\t"
+            "vldr        s4, [%[tmp0]]               \n\t"
+            "vmov        %[tmp0], s8                 \n\t"
+            "vldr        s5, [%[tmp1]]               \n\t"
+            "vmov        %[tmp1], s9                 \n\t"
+            "vldr        s6, [%[tmp2]]               \n\t"
+            "vmov        %[tmp2], s10                \n\t"
+            "vldr        s7, [%[tmp3]]               \n\t"
+            "vmov        %[tmp3], s11                \n\t"
+            "vldr        s8, [%[tmp0]]               \n\t"
+            "vmov        %[tmp0], s12                \n\t"
+            "vldr        s9, [%[tmp1]]               \n\t"
+            "vmov        %[tmp1], s13                \n\t"
+            "vldr        s10, [%[tmp2]]              \n\t"
+            "vmov        %[tmp2], s14                \n\t"
+            "vldr        s11, [%[tmp3]]              \n\t"
+            "vmov        %[tmp3], s15                \n\t"
+            "vldr        s12, [%[tmp0]]              \n\t"
+            "vmov        %[tmp0], s16                \n\t"
+            "vldr        s13, [%[tmp1]]              \n\t"
+            "vmov        %[tmp1], s17                \n\t"
+            "vldr        s14, [%[tmp2]]              \n\t"
+            "vmov        %[tmp2], s18                \n\t"
+            "vldr        s15, [%[tmp3]]              \n\t"
+            "vmov        %[tmp3], s19                \n\t"
+            "vldr        s16, [%[tmp0]]              \n\t"
+            "vshrn.i32   d1, q8, #14                 \n\t"
+            "vldr        s17, [%[tmp1]]              \n\t"
+            "vand        d1, d22                     \n\t"
+            "vldr        s18, [%[tmp2]]              \n\t"
+            "vsub.i16    d0, d23, d1                 \n\t"
+            "vldr        s19, [%[tmp3]]              \n\t"
+            "vmull.u8    q10, d2, d31                \n\t"
+            "vmlal.u8    q10, d6, d30                \n\t"
+            "vmull.u8    q1, d3, d31                 \n\t"
+            "vmlal.u8    q1, d7, d30                 \n\t"
+            "vmull.u8    q3, d4, d31                 \n\t"
+            "subs        %[len], #4                  \n\t"
+            "vmlal.u8    q3, d8, d30                 \n\t"
+            "bmi         12f                         \n\t"
+
+            "  vld1.32     {q8}, [%[xy]]!            \n\t"
+            "vmull.u8    q2, d5, d31                 \n\t"
+            "vmlal.u8    q2, d9, d30                 \n\t"
+            "vmul.u16    d8, d20, d0[0]              \n\t"
+            "  vshr.u32    d18, d16, #16             \n\t"
+            "vmul.u16    d9, d21, d0[1]              \n\t"
+            "  vshr.u32    d19, d17, #16             \n\t"
+            "vmul.u16    d20, d2, d0[2]              \n\t"
+            "  vand        d18, d24                  \n\t"
+            "vmul.u16    d21, d3, d0[3]              \n\t"
+            "  vand        d19, d25                  \n\t"
+            "vmla.u16    d8, d6, d1[0]               \n\t"
+            "  vadd.i32    d2, d26, d18              \n\t"
+            "vmla.u16    d9, d7, d1[1]               \n\t"
+            "  vadd.i32    d3, d27, d19              \n\t"
+            "vmla.u16    d20, d4, d1[2]              \n\t"
+            "  vshl.i32    d0, d16, #2               \n\t"
+            "vmla.u16    d21, d5, d1[3]              \n\t"
+            "  vshl.i32    d1, d17, #2               \n\t"
+            "  vand        q0, q12                   \n\t"
+            "  vadd.i32    q2, q13, q0               \n\t"
+            "vshr.u16    q4, #8                      \n\t"
+            "vshr.u16    q10, #8                     \n\t"
+            "vmul.u16    q4, q5                      \n\t"
+            "vmul.u16    q10, q5                     \n\t"
+            "  vmov        %[tmp0], %[tmp1], d2      \n\t"
+            "  vadd.i32    q3, q14, q9               \n\t"
+            "  vmov        %[tmp2], %[tmp3], d3      \n\t"
+            "vshrn.u16   d8, q4, #8                  \n\t"
+            "vshrn.u16   d9, q10, #8                 \n\t"
+            "vst1.32     {q4}, [%[dst]:128]!         \n\t"
+            "b           11b                         \n\t"
+
+            "12:                                     \n\t"
+            "vmull.u8    q2, d5, d31                 \n\t"
+            "vmlal.u8    q2, d9, d30                 \n\t"
+            "vmul.u16    d8, d20, d0[0]              \n\t"
+            "vmul.u16    d9, d21, d0[1]              \n\t"
+            "vmul.u16    d20, d2, d0[2]              \n\t"
+            "vmul.u16    d21, d3, d0[3]              \n\t"
+            "vmla.u16    d8, d6, d1[0]               \n\t"
+            "vmla.u16    d9, d7, d1[1]               \n\t"
+            "vmla.u16    d20, d4, d1[2]              \n\t"
+            "vmla.u16    d21, d5, d1[3]              \n\t"
+            "vshr.u16    q4, #8                      \n\t"
+            "vshr.u16    q10, #8                     \n\t"
+            "vmul.u16    q4, q5                      \n\t"
+            "vmul.u16    q10, q5                     \n\t"
+            "vshrn.u16   d8, q4, #8                  \n\t"
+            "vshrn.u16   d9, q10, #8                 \n\t"
+            "vst1.32     {q4}, [%[dst]:128]!         \n\t"
+
+            "13:                                     \n\t"
+            "adds        %[len], #4-1                \n\t"
+            "bmi         22f                         \n\t"
+
+            "21:                                     \n\t"
+            S32_ALPHA_D32_FILTER_DX_1PIX_NEON("subs %[len], #1")
+            "bpl         21b                         \n\t"
+
+            "22:                                     \n\t"
+            "vpop        {q4-q5}                     \n\t"
+    : // Outputs
+             [dst]"+r"(colors),
+              [xy]"+r"(xy),
+             [len]"+r"(count),
+            [tmp0]"=&r"(tmp0),
+            [tmp1]"=&r"(tmp1),
+            [tmp2]"=&r"(tmp2),
+            [tmp3]"=&r"(tmp3),
+               [x]"=&r"(x)
+    : // Inputs
+            [alpha]"r"(s.fAlphaScale),
+             [row0]"r"(row0),
+             [row1]"r"(row1),
+             [subY]"r"(wy)
+    : // Clobbers
+            "cc", "memory"
+    );
+}
+
+        // Copied from just below
+        static void filter_and_scale_by_alpha(unsigned x, unsigned y,
+                                              SkPMColor a00, SkPMColor a01,
+                                              SkPMColor a10, SkPMColor a11,
+                                              SkPMColor *dst,
+                                              uint16_t scale) {
+            uint8x8_t vy, vconst16_8, v16_y, vres;
+            uint16x4_t vx, vconst16_16, v16_x, tmp, vscale;
+            uint32x2_t va0, va1;
+            uint16x8_t tmp1, tmp2;
+
+            vy = vdup_n_u8(y);                // duplicate y into vy
+            vconst16_8 = vmov_n_u8(16);       // set up constant in vconst16_8
+            v16_y = vsub_u8(vconst16_8, vy);  // v16_y = 16-y
+
+            va0 = vdup_n_u32(a00);            // duplicate a00
+            va1 = vdup_n_u32(a10);            // duplicate a10
+            va0 = vset_lane_u32(a01, va0, 1); // set top to a01
+            va1 = vset_lane_u32(a11, va1, 1); // set top to a11
+
+            tmp1 = vmull_u8(vreinterpret_u8_u32(va0), v16_y); // tmp1 = [a01|a00] * (16-y)
+            tmp2 = vmull_u8(vreinterpret_u8_u32(va1), vy);    // tmp2 = [a11|a10] * y
+
+            vx = vdup_n_u16(x);                // duplicate x into vx
+            vconst16_16 = vmov_n_u16(16);      // set up constant in vconst16_16
+            v16_x = vsub_u16(vconst16_16, vx); // v16_x = 16-x
+
+            tmp = vmul_u16(vget_high_u16(tmp1), vx);        // tmp  = a01 * x
+            tmp = vmla_u16(tmp, vget_high_u16(tmp2), vx);   // tmp += a11 * x
+            tmp = vmla_u16(tmp, vget_low_u16(tmp1), v16_x); // tmp += a00 * (16-x)
+            tmp = vmla_u16(tmp, vget_low_u16(tmp2), v16_x); // tmp += a10 * (16-x)
+
+            if (scale < 256) {
+                vscale = vdup_n_u16(scale);        // duplicate scale
+                tmp = vshr_n_u16(tmp, 8);          // shift down result by 8
+                tmp = vmul_u16(tmp, vscale);       // multiply result by scale
+            }
+
+            vres = vshrn_n_u16(vcombine_u16(tmp, vcreate_u16(0)), 8); // shift down result by 8
+            vst1_lane_u32(dst, vreinterpret_u32_u8(vres), 0);         // store result
+        }
+
+
 #else
 
     // The NEON code only actually differs from the portable code in the
@@ -533,6 +784,203 @@ static void decode_packed_coordinates_and_weight(U32 packed, Out* v0, Out* v1, O
                                                        const uint32_t*, int, SkPMColor*) = nullptr;
 #endif
 
+#if defined(SK_ARM_HAS_NEON) && !defined(__ARM_64BIT_STATE)
+
+#define S32_OPAQUE_D32_FILTER_DX_1PIX_NEON(opt)              \
+            "ldr         %[x], [%[xy]], #4           \n\t"   \
+            "uxth        %[tmp2], %[x], ror #16      \n\t"   \
+            "lsl         %[tmp3], %[x], #2           \n\t"   \
+            "bic         %[tmp2], #3                 \n\t"   \
+            "uxth        %[tmp3], %[tmp3]            \n\t"   \
+            "add         %[tmp0], %[row0], %[tmp2]   \n\t"   \
+            "add         %[tmp1], %[row0], %[tmp3]   \n\t"   \
+            "add         %[tmp2], %[row1], %[tmp2]   \n\t"   \
+            "add         %[tmp3], %[row1], %[tmp3]   \n\t"   \
+            "lsr         %[x], #14                   \n\t"   \
+            "vldr        s0, [%[tmp0]]               \n\t"   \
+            "and         %[x], #0xf                  \n\t"   \
+            "vldr        s1, [%[tmp1]]               \n\t"   \
+            "vldr        s2, [%[tmp2]]               \n\t"   \
+            "vldr        s3, [%[tmp3]]               \n\t"   \
+            "vdup.16     d2, %[x]                    \n\t"   \
+            "vsub.i16    d3, d23, d2                 \n\t"   \
+            "vmull.u8    q2, d0, d31                 \n\t"   \
+            "vmlal.u8    q2, d1, d30                 \n\t"   \
+            "vmul.u16    d0, d4, d3                  \n\t"   \
+            "vmla.u16    d0, d5, d2                  \n\t"   \
+            opt"                                     \n\t"   \
+            "vshrn.u16   d0, q0, #8                  \n\t"   \
+            "vst1.32     {d0[0]}, [%[dst]:32]!       \n\t"   \
+
+void S32_opaque_D32_filter_DX(const SkBitmapProcState& s,
+                              const uint32_t* SK_RESTRICT xy,
+                              int count, SkPMColor* SK_RESTRICT colors) {
+    SkASSERT(count > 0 && colors != nullptr);
+    SkASSERT(s.fFilterQuality != kNone_SkFilterQuality);
+    SkASSERT(4 == s.fPixmap.info().bytesPerPixel());
+    SkASSERT(s.fAlphaScale == 256);
+
+    int y0, y1, wy;
+    decode_packed_coordinates_and_weight(*xy++, &y0, &y1, &wy);
+
+    auto row0 = (const uint32_t*)( (const char*)s.fPixmap.addr() + y0 * s.fPixmap.rowBytes() ),
+         row1 = (const uint32_t*)( (const char*)s.fPixmap.addr() + y1 * s.fPixmap.rowBytes() );
+
+    uint32_t tmp0, tmp1, tmp2, tmp3, x;
+    __asm__ volatile (
+            "vpush       {q4}                        \n\t"
+            "vmov.i16    d22, #0xf                   \n\t"
+            "vmov.i16    d23, #0x10                  \n\t"
+            "vmov.i32    q12, #0x3fff                \n\t"
+            "vdup.32     q13, %[row0]                \n\t"
+            "vdup.32     q14, %[row1]                \n\t"
+            "vdup.i8     d30, %[subY]                \n\t"
+            "vmov.i8     d31, #16                    \n\t"
+            "vshl.i32    q12, #2                     \n\t"
+            "tst         %[dst], #0xc                \n\t"
+            "vsub.i8     d31, d30                    \n\t"
+            "beq         2f                          \n\t"
+
+            "1:                                      \n\t"
+            S32_OPAQUE_D32_FILTER_DX_1PIX_NEON(
+            "add         %[tmp0], %[dst], #4         \n\t"
+            "subs        %[len], #1                  \n\t"
+            "it          ne                          \n\t"
+            "tstne       %[tmp0], #0xc"
+            )
+            "bne         1b                          \n\t"
+
+            "2:"
+            "subs        %[len], #4                  \n\t"
+            "bmi         13f                         \n\t"
+
+            "vld1.32     {q8}, [%[xy]]!              \n\t"
+            "vshr.u32    q9, q8, #16                 \n\t"
+            "vand        q9, q12                     \n\t"
+            "vadd.i32    q1, q13, q9                 \n\t"
+            "vshl.i32    q0, q8, #2                  \n\t"
+            "vand        q0, q12                     \n\t"
+            "vadd.i32    q2, q13, q0                 \n\t"
+            "vmov        %[tmp0], s4                 \n\t"
+            "vmov        %[tmp1], s5                 \n\t"
+
+            "11:                                     \n\t"
+            "vadd.i32    q3, q14, q9                 \n\t"
+            "vmov        %[tmp2], %[tmp3], d3        \n\t"
+            "vadd.i32    q4, q14, q0                 \n\t"
+            "vldr        s4, [%[tmp0]]               \n\t"
+            "vmov        %[tmp0], s8                 \n\t"
+            "vldr        s5, [%[tmp1]]               \n\t"
+            "vmov        %[tmp1], s9                 \n\t"
+            "vldr        s6, [%[tmp2]]               \n\t"
+            "vmov        %[tmp2], s10                \n\t"
+            "vldr        s7, [%[tmp3]]               \n\t"
+            "vmov        %[tmp3], s11                \n\t"
+            "vldr        s8, [%[tmp0]]               \n\t"
+            "vmov        %[tmp0], s12                \n\t"
+            "vldr        s9, [%[tmp1]]               \n\t"
+            "vmov        %[tmp1], s13                \n\t"
+            "vldr        s10, [%[tmp2]]              \n\t"
+            "vmov        %[tmp2], s14                \n\t"
+            "vldr        s11, [%[tmp3]]              \n\t"
+            "vmov        %[tmp3], s15                \n\t"
+            "vldr        s12, [%[tmp0]]              \n\t"
+            "vmov        %[tmp0], s16                \n\t"
+            "vldr        s13, [%[tmp1]]              \n\t"
+            "vmov        %[tmp1], s17                \n\t"
+            "vldr        s14, [%[tmp2]]              \n\t"
+            "vmov        %[tmp2], s18                \n\t"
+            "vldr        s15, [%[tmp3]]              \n\t"
+            "vmov        %[tmp3], s19                \n\t"
+            "vldr        s16, [%[tmp0]]              \n\t"
+            "vshrn.i32   d1, q8, #14                 \n\t"
+            "vldr        s17, [%[tmp1]]              \n\t"
+            "vand        d1, d22                     \n\t"
+            "vldr        s18, [%[tmp2]]              \n\t"
+            "vsub.i16    d0, d23, d1                 \n\t"
+            "vldr        s19, [%[tmp3]]              \n\t"
+            "vmull.u8    q10, d2, d31                \n\t"
+            "vmlal.u8    q10, d6, d30                \n\t"
+            "vmull.u8    q1, d3, d31                 \n\t"
+            "vmlal.u8    q1, d7, d30                 \n\t"
+            "vmull.u8    q3, d4, d31                 \n\t"
+            "subs        %[len], #4                  \n\t"
+            "vmlal.u8    q3, d8, d30                 \n\t"
+            "bmi         12f                         \n\t"
+
+            "  vld1.32     {q8}, [%[xy]]!            \n\t"
+            "vmull.u8    q2, d5, d31                 \n\t"
+            "vmlal.u8    q2, d9, d30                 \n\t"
+            "vmul.u16    d8, d20, d0[0]              \n\t"
+            "  vshr.u32    d18, d16, #16             \n\t"
+            "vmul.u16    d9, d21, d0[1]              \n\t"
+            "  vshr.u32    d19, d17, #16             \n\t"
+            "vmul.u16    d20, d2, d0[2]              \n\t"
+            "  vand        d18, d24                  \n\t"
+            "vmul.u16    d21, d3, d0[3]              \n\t"
+            "  vand        d19, d25                  \n\t"
+            "vmla.u16    d8, d6, d1[0]               \n\t"
+            "  vadd.i32    d2, d26, d18              \n\t"
+            "vmla.u16    d9, d7, d1[1]               \n\t"
+            "  vadd.i32    d3, d27, d19              \n\t"
+            "vmla.u16    d20, d4, d1[2]              \n\t"
+            "  vshl.i32    d0, d16, #2               \n\t"
+            "vmla.u16    d21, d5, d1[3]              \n\t"
+            "  vshl.i32    d1, d17, #2               \n\t"
+            "  vand        q0, q12                   \n\t"
+            "  vadd.i32    q2, q13, q0               \n\t"
+            "  vmov        %[tmp0], s4               \n\t"
+            "  vmov        %[tmp1], s5               \n\t"
+            "vshrn.u16   d8, q4, #8                  \n\t"
+            "vshrn.u16   d9, q10, #8                 \n\t"
+            "vst1.32     {q4}, [%[dst]:128]!         \n\t"
+            "b           11b                         \n\t"
+
+            "12:                                     \n\t"
+            "vmull.u8    q2, d5, d31                 \n\t"
+            "vmlal.u8    q2, d9, d30                 \n\t"
+            "vmul.u16    d8, d20, d0[0]              \n\t"
+            "vmul.u16    d9, d21, d0[1]              \n\t"
+            "vmul.u16    d20, d2, d0[2]              \n\t"
+            "vmul.u16    d21, d3, d0[3]              \n\t"
+            "vmla.u16    d8, d6, d1[0]               \n\t"
+            "vmla.u16    d9, d7, d1[1]               \n\t"
+            "vmla.u16    d20, d4, d1[2]              \n\t"
+            "vmla.u16    d21, d5, d1[3]              \n\t"
+            "vshrn.u16   d8, q4, #8                  \n\t"
+            "vshrn.u16   d9, q10, #8                 \n\t"
+            "vst1.32     {q4}, [%[dst]:128]!         \n\t"
+
+            "13:                                     \n\t"
+            "adds        %[len], #4-1                \n\t"
+            "bmi         22f                         \n\t"
+
+            "21:                                     \n\t"
+            S32_OPAQUE_D32_FILTER_DX_1PIX_NEON("subs %[len], #1")
+            "bpl         21b                         \n\t"
+
+            "22:                                     \n\t"
+            "vpop        {q4}                        \n\t"
+    : // Outputs
+             [dst]"+r"(colors),
+              [xy]"+r"(xy),
+             [len]"+r"(count),
+            [tmp0]"=&r"(tmp0),
+            [tmp1]"=&r"(tmp1),
+            [tmp2]"=&r"(tmp2),
+            [tmp3]"=&r"(tmp3),
+               [x]"=&r"(x)
+    : // Inputs
+            [row0]"r"(row0),
+            [row1]"r"(row1),
+            [subY]"r"(wy)
+    : // Clobbers
+            "cc", "memory"
+    );
+}
+
+#endif
+
 }  // namespace SK_OPTS_NS
 
 #endif
diff --git a/src/third_party/skia/src/opts/SkBlitMask_opts.h b/src/third_party/skia/src/opts/SkBlitMask_opts.h
index 93ae81c3e2..949b8ff137 100644
--- a/src/third_party/skia/src/opts/SkBlitMask_opts.h
+++ b/src/third_party/skia/src/opts/SkBlitMask_opts.h
@@ -226,6 +226,322 @@ namespace SK_OPTS_NS {
     }
 }
 
+#if defined(SK_ARM_HAS_NEON) && !defined(__ARM_64BIT_STATE)
+
+// These macros permit optionally-included features to be switched using a parameter to another macro
+#define YES(x) x
+#define NO(x)
+
+// How far ahead (pixels) to preload (undefine to disable prefetch) - determined empirically
+#define PREFETCH_DISTANCE "52"
+
+#ifdef PREFETCH_DISTANCE
+#define IF_PRELOAD YES
+#else
+#define IF_PRELOAD NO
+#endif
+
+/// Macro to load 1..7 source and mask pixels in growing powers-of-2 in size - suitable for leading pixels
+#define S32A_A8_LOAD_SM_LEADING_7(r0, r1, r2, r3, s_base, r4, m_base, opt1, opt2)                       \
+                opt1"                                                                           \n\t"   \
+                "tst         %[group_size], #1                                                  \n\t"   \
+                opt2"                                                                           \n\t"   \
+                "beq         1f                                                                 \n\t"   \
+                "vld1.8      {"#r4"[1]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[1],"#r1"[1],"#r2"[1],"#r3"[1]}, [%["#s_base"]:32]!          \n\t"   \
+                "1:                                                                             \n\t"   \
+                "lsls        %[tmp], %[group_size], #30                                         \n\t"   \
+                "bpl         1f                                                                 \n\t"   \
+                "vld1.8      {"#r4"[2]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[2],"#r1"[2],"#r2"[2],"#r3"[2]}, [%["#s_base"]:32]!          \n\t"   \
+                "vld1.8      {"#r4"[3]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[3],"#r1"[3],"#r2"[3],"#r3"[3]}, [%["#s_base"]:32]!          \n\t"   \
+                "1:                                                                             \n\t"   \
+                "bcc         1f                                                                 \n\t"   \
+                "vld1.8      {"#r4"[4]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[4],"#r1"[4],"#r2"[4],"#r3"[4]}, [%["#s_base"]:32]!          \n\t"   \
+                "vld1.8      {"#r4"[5]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[5],"#r1"[5],"#r2"[5],"#r3"[5]}, [%["#s_base"]:32]!          \n\t"   \
+                "vld1.8      {"#r4"[6]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[6],"#r1"[6],"#r2"[6],"#r3"[6]}, [%["#s_base"]:32]!          \n\t"   \
+                "vld1.8      {"#r4"[7]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[7],"#r1"[7],"#r2"[7],"#r3"[7]}, [%["#s_base"]:32]!          \n\t"   \
+                "1:                                                                             \n\t"   \
+
+/// Macro to load or store 1..7 destination pixels in growing powers-of-2 in size - suitable for leading pixels
+#define S32A_A8_LOADSTORE_D_LEADING_7(ls, r0, r1, r2, r3, d_base)                                       \
+                "tst         %[group_size], #1                                                  \n\t"   \
+                "beq         1f                                                                 \n\t"   \
+                "v"#ls"4.8   {"#r0"[1],"#r1"[1],"#r2"[1],"#r3"[1]}, [%["#d_base"]:32]!          \n\t"   \
+                "1:                                                                             \n\t"   \
+                "lsls        %[tmp], %[group_size], #30                                         \n\t"   \
+                "add         %[tmp], %["#d_base"], #4                                           \n\t"   \
+                "bpl         1f                                                                 \n\t"   \
+                "v"#ls"4.8   {"#r0"[2],"#r1"[2],"#r2"[2],"#r3"[2]}, [%["#d_base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[3],"#r1"[3],"#r2"[3],"#r3"[3]}, [%[tmp]:32], %[eight]       \n\t"   \
+                "1:                                                                             \n\t"   \
+                "bcc         1f                                                                 \n\t"   \
+                "v"#ls"4.8   {"#r0"[4],"#r1"[4],"#r2"[4],"#r3"[4]}, [%["#d_base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[5],"#r1"[5],"#r2"[5],"#r3"[5]}, [%[tmp]:32], %[eight]       \n\t"   \
+                "v"#ls"4.8   {"#r0"[6],"#r1"[6],"#r2"[6],"#r3"[6]}, [%["#d_base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[7],"#r1"[7],"#r2"[7],"#r3"[7]}, [%[tmp]:32], %[eight]       \n\t"   \
+                "1:                                                                             \n\t"   \
+
+/// Macro to load 1..7 source and mask pixels in shrinking powers-of-2 in size - suitable for trailing pixels
+#define S32A_A8_LOAD_SM_TRAILING_7(r0, r1, r2, r3, s_base, r4, m_base, opt1, opt2)                      \
+                opt1"                                                                           \n\t"   \
+                "lsls        %[tmp], %[group_size], #30                                         \n\t"   \
+                opt2"                                                                           \n\t"   \
+                "bcc         1f                                                                 \n\t"   \
+                "vld1.8      {"#r4"[0]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[0],"#r1"[0],"#r2"[0],"#r3"[0]}, [%["#s_base"]:32]!          \n\t"   \
+                "vld1.8      {"#r4"[1]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[1],"#r1"[1],"#r2"[1],"#r3"[1]}, [%["#s_base"]:32]!          \n\t"   \
+                "vld1.8      {"#r4"[2]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[2],"#r1"[2],"#r2"[2],"#r3"[2]}, [%["#s_base"]:32]!          \n\t"   \
+                "vld1.8      {"#r4"[3]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[3],"#r1"[3],"#r2"[3],"#r3"[3]}, [%["#s_base"]:32]!          \n\t"   \
+                "1:                                                                             \n\t"   \
+                "bpl         1f                                                                 \n\t"   \
+                "vld1.8      {"#r4"[4]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[4],"#r1"[4],"#r2"[4],"#r3"[4]}, [%["#s_base"]:32]!          \n\t"   \
+                "vld1.8      {"#r4"[5]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[5],"#r1"[5],"#r2"[5],"#r3"[5]}, [%["#s_base"]:32]!          \n\t"   \
+                "1:                                                                             \n\t"   \
+                "tst         %[group_size], #1                                                  \n\t"   \
+                "beq         1f                                                                 \n\t"   \
+                "vld1.8      {"#r4"[6]}, [%["#m_base"]]!                                        \n\t"   \
+                "vld4.8      {"#r0"[6],"#r1"[6],"#r2"[6],"#r3"[6]}, [%["#s_base"]:32]!          \n\t"   \
+                "1:                                                                             \n\t"   \
+
+/// Macro to load or store 1..7 destination pixels in shrinking powers-of-2 in size - suitable for trailing pixels
+#define S32A_A8_LOADSTORE_D_TRAILING_7(ls, r0, r1, r2, r3, d_base)                                      \
+                "lsls        %[tmp], %[group_size], #30                                         \n\t"   \
+                "add         %[tmp], %["#d_base"], #4                                           \n\t"   \
+                "bcc         1f                                                                 \n\t"   \
+                "v"#ls"4.8   {"#r0"[0],"#r1"[0],"#r2"[0],"#r3"[0]}, [%["#d_base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[1],"#r1"[1],"#r2"[1],"#r3"[1]}, [%[tmp]:32], %[eight]       \n\t"   \
+                "v"#ls"4.8   {"#r0"[2],"#r1"[2],"#r2"[2],"#r3"[2]}, [%["#d_base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[3],"#r1"[3],"#r2"[3],"#r3"[3]}, [%[tmp]:32], %[eight]       \n\t"   \
+                "1:                                                                             \n\t"   \
+                "bpl         1f                                                                 \n\t"   \
+                "v"#ls"4.8   {"#r0"[4],"#r1"[4],"#r2"[4],"#r3"[4]}, [%["#d_base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[5],"#r1"[5],"#r2"[5],"#r3"[5]}, [%[tmp]:32], %[eight]       \n\t"   \
+                "1:                                                                             \n\t"   \
+                "tst         %[group_size], #1                                                  \n\t"   \
+                "beq         1f                                                                 \n\t"   \
+                "v"#ls"4.8   {"#r0"[6],"#r1"[6],"#r2"[6],"#r3"[6]}, [%["#d_base"]:32]!          \n\t"   \
+                "1:                                                                             \n\t"   \
+
+/// Macro to do shortcut testing for "over" compositing of 32bpp premultiplied ARGB source and 8-bit alpha mask
+#define S32A_A8_TEST(dst_adjust)                                                                        \
+                "vmov        %[mlo], %[mhi], d16                                                \n\t"   \
+                "vmov        %[alo], s6                                                         \n\t"   \
+                "vmov        %[ahi], s7                                                         \n\t"   \
+                "and         %[tmp], %[mlo], %[mhi]                                             \n\t"   \
+                "orrs        %[mlo], %[mhi]                                                     \n\t"   \
+                "it          ne                                                                 \n\t"   \
+                "orrsne      %[mlo], %[alo], %[ahi]                                             \n\t"   \
+                "it          eq                                                                 \n\t"   \
+                "addeq       %[dst], " dst_adjust "                                             \n\t"   \
+                "beq         9f                                                                 \n\t"   \
+                "and         %[tmp], %[alo]                                                     \n\t"   \
+                "and         %[tmp], %[ahi]                                                     \n\t"   \
+                "cmp         %[tmp], #-1                                                        \n\t"   \
+                "beq         5f                                                                 \n\t"   \
+
+/// Macro to do testing and "over" compositing of a group of 1..7 32bpp premultiplied ARGB source and 1..7 8-bit alpha mask leading or trailing pixels
+#define S32A_A8_7PIX_PROCESS(load_sm_7, loadstore_d_7, size)                                            \
+    do {                                                                                                \
+        __asm__ volatile (                                                                              \
+                /* Load the leading/trailing source pixels,                                             \
+                 * after initialising all the unused indexes from the first pixel                       \
+                 * so the all-opaque and all-transparent tests still work */                            \
+                load_sm_7(d0, d1, d2, d3, src, d16, msk,                                                \
+                "vld1.8      {d16[]}, [%[msk]]",                                                        \
+                "vld4.8      {d0[], d1[], d2[], d3[]}, [%[src]]")                                       \
+                S32A_A8_TEST("%[group_size], lsl #2")                                                   \
+                /* Translucency used, or a mixture of opaque and transparent */                         \
+                loadstore_d_7(ld, d4, d5, d6, d7, dst)                                                  \
+                "sub         %[dst], %[group_size], lsl #2                                      \n\t"   \
+                S32A_A8_8PIX_BLEND(, NO, NO)                                                      \
+                loadstore_d_7(st, d0, d1, d2, d3, dst)                                                  \
+                /* Drop through */                                                                      \
+                "9:                                                                             \n\t"   \
+        : /* Outputs */                                                                                 \
+                [mlo]"=&r"(mlo),                                                                        \
+                [mhi]"=&r"(mhi),                                                                        \
+                [alo]"=&r"(alo),                                                                        \
+                [ahi]"=&r"(ahi),                                                                        \
+                [tmp]"=&r"(tmp),                                                                        \
+                [src]"+r"(src),                                                                         \
+                [msk]"+r"(msk),                                                                         \
+                [dst]"+r"(dst)                                                                          \
+        : /* Inputs */                                                                                  \
+                [group_size]"r"(size),                                                                  \
+                     [eight]"r"(eight)                                                                  \
+        : /* Clobbers */                                                                                \
+                "cc", "memory"                                                                          \
+        );                                                                                              \
+    } while (0)
+
+/// Macro to do "over" compositing blending on 8 32bpp premultiplied ARGB source and 8 8-bit alpha mask pixels
+/// which are with either translucent or a mixture of opaque and transparent.
+/// Relies on A(x) to determine whether to emit code in ARM state (as opposed to Thumb state).
+/// @arg align           bit-alignment specifier on destination loads/stores (optional)
+/// @arg if_loadstore    YES or NO: whether to do load/store of destination
+/// @arg if_preload      YES or NO: whether to insert prefetch instructions
+#define S32A_A8_8PIX_BLEND(align, if_loadstore, if_preload)                                        \
+if_loadstore(   "vld4.8      {d4-d7}, [%[dst]"#align"]                                          \n\t")  \
+if_preload(     "sub         %[tmp], %[len], #1                                                 \n\t")  \
+                "vmull.u8    q9, d3, d16                                                        \n\t"   \
+if_preload(     "cmp         %[tmp], #" PREFETCH_DISTANCE "                                     \n\t")  \
+                "vmull.u8    q10, d0, d16                                                       \n\t"   \
+if_preload(     "it          cs                                                                 \n\t")  \
+if_preload(     "movcs       %[tmp], #" PREFETCH_DISTANCE "                                     \n\t")  \
+                "vmull.u8    q11, d1, d16                                                       \n\t"   \
+                "vmull.u8    q8, d2, d16                                                        \n\t"   \
+                "vrshr.u16   q1, q9, #8                                                         \n\t"   \
+if_preload(     "pld         [%[msk], %[tmp]]                                                   \n\t")  \
+                "vrshr.u16   q0, q10, #8                                                        \n\t"   \
+if_preload(     "pld         [%[src], %[tmp], lsl #2]                                           \n\t")  \
+                "vraddhn.u16 d3, q9, q1                                                         \n\t"   \
+if_preload(     "add         %[tmp], #32/4                                                      \n\t")  \
+                "vrshr.u16   q9, q11, #8                                                        \n\t"   \
+                "vrshr.u16   q12, q8, #8                                                        \n\t"   \
+                "vmvn        d2, d3                                                             \n\t"   \
+if_preload(     "pld         [%[dst], %[tmp], lsl #2]                                           \n\t")  \
+                "vraddhn.u16 d0, q10, q0                                                        \n\t"   \
+                "vmull.u8    q10, d4, d2                                                        \n\t"   \
+                "vmull.u8    q13, d5, d2                                                        \n\t"   \
+                "vmull.u8    q14, d6, d2                                                        \n\t"   \
+                "vmull.u8    q15, d7, d2                                                        \n\t"   \
+                "vrshr.u16   q2, q10, #8                                                        \n\t"   \
+                "vrshr.u16   q3, q13, #8                                                        \n\t"   \
+                "vraddhn.u16 d1, q11, q9                                                        \n\t"   \
+                "vrshr.u16   q9, q14, #8                                                        \n\t"   \
+                "vrshr.u16   q11, q15, #8                                                       \n\t"   \
+                "vraddhn.u16 d4, q10, q2                                                        \n\t"   \
+                "vraddhn.u16 d5, q13, q3                                                        \n\t"   \
+                "vraddhn.u16 d2, q8, q12                                                        \n\t"   \
+                "vraddhn.u16 d6, q14, q9                                                        \n\t"   \
+                "vraddhn.u16 d7, q15, q11                                                       \n\t"   \
+                "vadd.u8     q0, q2                                                             \n\t"   \
+                "vadd.u8     q1, q3                                                             \n\t"   \
+                "5:                                                                             \n\t"   \
+if_loadstore(   "vst4.8      {d0-d3}, [%[dst]"#align"]!                                         \n\t")  \
+
+#endif
+
+/*not static*/ inline
+void blit_row_s32a_a8(SkPMColor* dst, const void* vmask, const SkPMColor* src, int n) {
+#if defined(SK_ARM_HAS_NEON) && !defined(__ARM_64BIT_STATE)
+    const SkAlpha* msk = static_cast<const SkAlpha*>(vmask);
+    uint32_t tmp, mlo, mhi, alo, ahi;
+    const int eight = 8;
+    if (n < 15) {
+        // Too short to attempt aligned processing
+        if (n & 8) {
+            __asm__ (
+                    "vld1.8      {d16}, [%[msk]]!                                                   \n\t"
+                    "vld4.8      {d0-d3}, [%[src]]!                                                 \n\t"
+                    S32A_A8_TEST("#8*4")
+                    /* Translucency used, or a mixture of opaque and transparent */
+                    S32A_A8_8PIX_BLEND(, YES, NO)
+                    /* Drop through */
+                    "9:                                                                             \n\t"
+            :  /* Outputs */
+                    [mlo]"=&r"(mlo),
+                    [mhi]"=&r"(mhi),
+                    [alo]"=&r"(alo),
+                    [ahi]"=&r"(ahi),
+                    [tmp]"=&r"(tmp),
+                    [src]"+r"(src),
+                    [msk]"+r"(msk),
+                    [dst]"+r"(dst)
+            : /* Inputs */
+            : /* Clobbers */
+                    "cc", "memory"
+            );
+        }
+        if (n & 7)
+            S32A_A8_7PIX_PROCESS(S32A_A8_LOAD_SM_TRAILING_7, S32A_A8_LOADSTORE_D_TRAILING_7, n & 7);
+    } else {
+        // The last 0 - 7 pixels (starting from a 4-pixel boundary) are handled together
+        uintptr_t startrup = (uintptr_t) dst / sizeof (*dst) + 3;
+        uintptr_t end = (uintptr_t) dst / sizeof (*dst) + n;
+        size_t trailing;
+        if ((end & 3) == 0)
+            // No blocks of <8 pixels used at end in these cases
+            trailing = 0;
+        else
+            // If length (discounting alignment to 4-pixel boundaries) is an odd number of 4-pixels,
+            // assign 4 pixels to trailing end to avoid possibility of a leading run of exactly 4,
+            // otherwise use <4 trailing pixels to maximise central 8-pixel blocks
+            trailing = ((startrup ^ end) & 4) + (end & 3);
+        // The inner loop handles an integer number (0+) of 8-pixel blocks at 4-pixel boundaries
+        // The 0 - 7 pixels leading up to this are handled together
+        size_t leading = (n - trailing) & 7;
+
+        // Do leading pixels
+        if (leading != 0) {
+            n -= leading;
+            S32A_A8_7PIX_PROCESS(S32A_A8_LOAD_SM_LEADING_7, S32A_A8_LOADSTORE_D_LEADING_7, leading);
+        }
+
+        // Do inner loop
+        __asm__ (
+                "subs        %[len], #8                                                         \n\t"
+                "bcc         50f                                                                \n\t"
+
+                "10:                                                                            \n\t"
+                "vld1.8      {d16}, [%[msk]]!                                                   \n\t"
+                "vld4.8      {d0-d3}, [%[src]]!                                                 \n\t"
+                S32A_A8_TEST("#8*4")
+                /* Translucency used, or a mixture of opaque and transparent */
+                S32A_A8_8PIX_BLEND(:128, YES, IF_PRELOAD)
+                /* Drop through */
+                "9:                                                                             \n\t"
+                "subs        %[len], #8                                                         \n\t"
+                "bcs         10b                                                                \n\t"
+                "50:                                                                            \n\t"
+        : // Outputs
+                [mlo]"=&r"(mlo),
+                [mhi]"=&r"(mhi),
+                [alo]"=&r"(alo),
+                [ahi]"=&r"(ahi),
+                [tmp]"=&r"(tmp),
+                [src]"+r"(src),
+                [msk]"+r"(msk),
+                [dst]"+r"(dst),
+                [len]"+r"(n)
+        : // Inputs
+        : // Clobbers
+                "cc", "memory"
+        );
+
+        // Do trailing pixels.
+        if (n & 7)
+            S32A_A8_7PIX_PROCESS(S32A_A8_LOAD_SM_TRAILING_7, S32A_A8_LOADSTORE_D_TRAILING_7, n & 7);
+    }
+#else
+    auto mask = (const uint8_t*)vmask;
+
+#ifdef SK_SUPPORT_LEGACY_A8_MASKBLITTER
+    for (int i = 0; i < n; ++i) {
+        if (mask[i]) {
+            dst[i] = SkBlendARGB32(src[i], dst[i], mask[i]);
+        }
+    }
+#else
+    Sk4px::MapDstSrcAlpha(n, dst, src, mask, [](const Sk4px& d, const Sk4px& s, const Sk4px& aa) {
+        const auto s_aa = s.approxMulDiv255(aa);
+        return s_aa + d.approxMulDiv255(s_aa.alphas().inv());
+    });
+#endif
+#endif
+}
+
 }  // namespace SK_OPTS_NS
 
 #endif//SkBlitMask_opts_DEFINED
diff --git a/src/third_party/skia/src/opts/SkBlitRow_opts.h b/src/third_party/skia/src/opts/SkBlitRow_opts.h
index fd5cbbacbe..378d45036d 100644
--- a/src/third_party/skia/src/opts/SkBlitRow_opts.h
+++ b/src/third_party/skia/src/opts/SkBlitRow_opts.h
@@ -120,6 +120,10 @@
 #endif
 
 #if defined(SK_ARM_HAS_NEON)
+#ifdef __ARM_64BIT_STATE
+// No attempt has been made to adapt the inline assembly version for AArch64
+// so fall back to the less performant version that uses intrinsics instead
+
     #include <arm_neon.h>
 
     // SkMulDiv255Round() applied to each lane.
@@ -145,8 +149,193 @@
         return vadd_u8(src, SkMulDiv255Round_neon8(nalphas, dst));
     }
 
+#else // __ARM_64BIT_STATE
+// Inline ARM AArch32 assembly version
+
+// Macros to specify instructions to only include if targeting ARM or Thumb instruction sets
+#ifdef __thumb__
+#define A(x)
+#define T(x) x
+#else
+#define A(x) x
+#define T(x)
+#endif
+
+// These macros permit optionally-included features to be switched using a parameter to another macro
+#define YES(x) x
+#define NO(x)
+
+// How far ahead (pixels) to preload (undefine to disable prefetch) - determined empirically
+#undef PREFETCH_DISTANCE
+#define PREFETCH_DISTANCE "24"
+
+#ifdef PREFETCH_DISTANCE
+#define IF_PRELOAD YES
+#else
+#define IF_PRELOAD NO
 #endif
 
+/// Macro to load or store 1..7 pixels in growing powers-of-2 in size - suitable for leading pixels
+#define S32A_LOADSTORE_LEADING_7(ls, r0, r1, r2, r3, base, opt)                                       \
+                "tst         %[group_size], #1                                                \n\t"   \
+                opt"                                                                          \n\t"   \
+                "beq         1f                                                               \n\t"   \
+                "v"#ls"4.8   {"#r0"[1],"#r1"[1],"#r2"[1],"#r3"[1]}, [%["#base"]:32]!          \n\t"   \
+                "1:                                                                           \n\t"   \
+                "lsls        %[tmp], %[group_size], #30                                       \n\t"   \
+                "add         %[tmp], %["#base"], #4                                           \n\t"   \
+                "bpl         1f                                                               \n\t"   \
+                "v"#ls"4.8   {"#r0"[2],"#r1"[2],"#r2"[2],"#r3"[2]}, [%["#base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[3],"#r1"[3],"#r2"[3],"#r3"[3]}, [%[tmp]:32], %[eight]     \n\t"   \
+                "1:                                                                           \n\t"   \
+                "bcc         1f                                                               \n\t"   \
+                "v"#ls"4.8   {"#r0"[4],"#r1"[4],"#r2"[4],"#r3"[4]}, [%["#base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[5],"#r1"[5],"#r2"[5],"#r3"[5]}, [%[tmp]:32], %[eight]     \n\t"   \
+                "v"#ls"4.8   {"#r0"[6],"#r1"[6],"#r2"[6],"#r3"[6]}, [%["#base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[7],"#r1"[7],"#r2"[7],"#r3"[7]}, [%[tmp]:32], %[eight]     \n\t"   \
+                "1:                                                                           \n\t"   \
+
+/// Macro to load or store 1..7 pixels in shrink powers-of-2 in size - suitable for trailing pixels
+#define S32A_LOADSTORE_TRAILING_7(ls, r0, r1, r2, r3, base, opt)                                      \
+                "lsls        %[tmp], %[group_size], #30                                       \n\t"   \
+                "add         %[tmp], %["#base"], #4                                           \n\t"   \
+                opt"                                                                          \n\t"   \
+                "bcc         1f                                                               \n\t"   \
+                "v"#ls"4.8   {"#r0"[0],"#r1"[0],"#r2"[0],"#r3"[0]}, [%["#base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[1],"#r1"[1],"#r2"[1],"#r3"[1]}, [%[tmp]:32], %[eight]     \n\t"   \
+                "v"#ls"4.8   {"#r0"[2],"#r1"[2],"#r2"[2],"#r3"[2]}, [%["#base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[3],"#r1"[3],"#r2"[3],"#r3"[3]}, [%[tmp]:32], %[eight]     \n\t"   \
+                "1:                                                                           \n\t"   \
+                "bpl         1f                                                               \n\t"   \
+                "v"#ls"4.8   {"#r0"[4],"#r1"[4],"#r2"[4],"#r3"[4]}, [%["#base"]:32], %[eight] \n\t"   \
+                "v"#ls"4.8   {"#r0"[5],"#r1"[5],"#r2"[5],"#r3"[5]}, [%[tmp]:32], %[eight]     \n\t"   \
+                "1:                                                                           \n\t"   \
+                "tst         %[group_size], #1                                                \n\t"   \
+                "beq         1f                                                               \n\t"   \
+                "v"#ls"4.8   {"#r0"[6],"#r1"[6],"#r2"[6],"#r3"[6]}, [%["#base"]:32]!          \n\t"   \
+                "1:                                                                           \n\t"   \
+
+/// Macro to do testing and "over" compositing of a group of 1..7 32bpp premultiplied ARGB leading or trailing pixels
+#define S32A_OPAQUE_7PIX_PROCESS(loadstore_7, size)                                                   \
+    do {                                                                                              \
+        __asm__ volatile (                                                                            \
+                /* Load the leading/trailing source pixels,                                           \
+                 * after initialising all the unused indexes from the first pixel                     \
+                 * so the all-opaque and all-transparent tests still work */                          \
+                loadstore_7(ld, d0, d1, d2, d3, src,                                                  \
+                "vld4.8      {d0[],d1[],d2[],d3[]}, [%[src]]")                                        \
+                /* Test for all-opaque or all-transparent */                                          \
+                "vmov        %[alo], s6                                                       \n\t"   \
+                "vmov        %[ahi], s7                                                       \n\t"   \
+                "vmvn        d31, d3                                                          \n\t"   \
+                "orrs        %[tmp], %[alo], %[ahi]                                           \n\t"   \
+                "it          eq                                                               \n\t"   \
+                "addeq       %[dst], %[group_size], lsl #2                                    \n\t"   \
+                "beq         9f                                                               \n\t"   \
+                "cmp         %[alo], #-1                                                      \n\t"   \
+                "it          eq                                                               \n\t"   \
+                "cmpeq       %[ahi], #-1                                                      \n\t"   \
+                "beq         5f                                                               \n\t"   \
+                /* Translucency used, or a mixture of opaque and transparent */                       \
+                loadstore_7(ld, d20, d21, d22, d23, dst, )                                            \
+                "sub         %[dst], %[group_size], lsl #2                                    \n\t"   \
+                S32A_OPAQUE_8PIX_BLEND(, , q0, q1,, NO, NO, NO)                                       \
+                "5:                                                                           \n\t"   \
+                loadstore_7(st, d0, d1, d2, d3, dst, )                                                \
+                /* Drop through */                                                                    \
+                "9:                                                                           \n\t"   \
+        : /* Outputs */                                                                               \
+                [alo]"=&r"(alo),                                                                      \
+                [ahi]"=&r"(ahi),                                                                      \
+                [tmp]"=&r"(tmp),                                                                      \
+                [src]"+r"(src),                                                                       \
+                [dst]"+r"(dst)                                                                        \
+        : /* Inputs */                                                                                \
+                [group_size]"r"(size),                                                                \
+                     [eight]"r"(eight)                                                                \
+        : /* Clobbers */                                                                              \
+                "cc", "memory"                                                                        \
+        );                                                                                            \
+    } while (0)
+
+/// Macro to do testing and "over" compositing of an aligned group of 8 32bpp premultiplied ARGB leading or trailing pixels
+#define S32A_OPAQUE_8PIX_PROCESS(align, if_load)                                                      \
+    do {                                                                                              \
+        __asm__ (                                                                                     \
+if_load(        "vld4.8      {d0-d3}, [%[src]]!                                               \n\t")  \
+                /* Test for all-opaque or all-transparent */                                          \
+                "vmov        %[alo], s6                                                       \n\t"   \
+                "vmov        %[ahi], s7                                                       \n\t"   \
+                "vmvn        d31, d3                                                          \n\t"   \
+                "orrs        %[tmp], %[alo], %[ahi]                                           \n\t"   \
+                "it          eq                                                               \n\t"   \
+                "addeq       %[dst], #8*4                                                     \n\t"   \
+                "beq         9f                                                               \n\t"   \
+                "cmp         %[alo], #-1                                                      \n\t"   \
+                "it          eq                                                               \n\t"   \
+                "cmpeq       %[ahi], #-1                                                      \n\t"   \
+                "beq         5f                                                               \n\t"   \
+                /* Translucency used, or a mixture of opaque and transparent */                       \
+                S32A_OPAQUE_8PIX_BLEND(align, , q0, q1, "5:", YES, NO, NO)                            \
+                /* Drop through */                                                                    \
+                "9:                                                                           \n\t"   \
+        :  /* Outputs */                                                                              \
+                [alo]"=&r"(alo),                                                                      \
+                [ahi]"=&r"(ahi),                                                                      \
+                [tmp]"=&r"(tmp),                                                                      \
+                [src]"+r"(src),                                                                       \
+                [dst]"+r"(dst)                                                                        \
+        : /* Inputs */                                                                                \
+        : /* Clobbers */                                                                              \
+                "cc", "memory"                                                                        \
+        );                                                                                            \
+    } while (0)
+
+/// Macro to do "over" compositing blending on 8 32bpp premultiplied ARGB pixels
+/// which are with either translucent or a mixture of opaque and transparent.
+/// Relies on A(x) to determine whether to emit code in ARM state (as opposed to Thumb state).
+/// @arg align           bit-alignment specifier on destination loads/stores (optional)
+/// @arg other_src_alpha D-register specifier for alpha source in other bank (only IF_OVERLAP)
+/// @arg src0            Q-register specifier for blue/green source in this bank
+/// @arg src1            Q-register specifier for red/alpha source in this bank
+/// @arg opt             optional instruction to emit
+/// @arg if_loadstore    YES or NO: whether to do load/store
+/// @arg if_overlap      YES or NO: whether to interleave processing of next iteration
+/// @arg if_preload      YES or NO: whether to insert prefetch instructions
+#define S32A_OPAQUE_8PIX_BLEND(align, other_src_alpha, src0, src1, opt, if_loadstore, if_overlap, if_preload) \
+if_loadstore(   "vld4.8      {d20-d23}, [%[dst]"#align"]                                      \n\t")  \
+if_preload(     "sub         %[tmp], %[len], #1                                               \n\t")  \
+if_overlap(     "vmov        %[alo], %[ahi], "#other_src_alpha"                               \n\t")  \
+if_preload(     "cmp         %[tmp], #" PREFETCH_DISTANCE "                                   \n\t")  \
+                "vmull.u8    q8, d20, d31                                                     \n\t"   \
+if_preload(     "it          cs                                                               \n\t")  \
+if_preload(     "movcs       %[tmp], #" PREFETCH_DISTANCE "                                   \n\t")  \
+                "vmull.u8    q9, d21, d31                                                     \n\t"   \
+                "vmull.u8    q10, d22, d31                                                    \n\t"   \
+                "vmull.u8    q11, d23, d31                                                    \n\t"   \
+if_preload(     "pld         [%[src], %[tmp], lsl #2]                                         \n\t")  \
+                "vrshr.u16   q12, q8, #8                                                      \n\t"   \
+if_preload(     "add         %[tmp], #(32+32)/4                                               \n\t")  \
+                "vrshr.u16   q13, q9, #8                                                      \n\t"   \
+                "vrshr.u16   q14, q10, #8                                                     \n\t"   \
+                "vrshr.u16   q15, q11, #8                                                     \n\t"   \
+if_preload(     "pld         [%[dst], %[tmp], lsl #2]                                         \n\t")  \
+                "vraddhn.u16 d16, q8, q12                                                     \n\t"   \
+                "vraddhn.u16 d17, q9, q13                                                     \n\t"   \
+                "vraddhn.u16 d18, q10, q14                                                    \n\t"   \
+                "vraddhn.u16 d19, q11, q15                                                    \n\t"   \
+if_overlap(     "mvn         %[tmp], %[alo]                                                   \n\t")  \
+if_overlap(     "vmvn        d31, "#other_src_alpha"                                          \n\t")  \
+if_overlap(A(   "orr         %[alo], %[ahi]                                                   \n\t")) \
+                "vadd.i8     "#src0", q8                                                      \n\t"   \
+if_overlap(A(   "mvn         %[ahi], %[ahi]                                                   \n\t")) \
+                "vadd.i8     "#src1", q9                                                      \n\t"   \
+                opt"                                                                          \n\t"   \
+if_loadstore(   "vst4.8      {"#src0", "#src1"}, [%[dst]"#align"]!                            \n\t")  \
+
+#endif // __ARM_64BIT_STATE
+#endif // defined(SK_ARM_HAS_NEON)
+
 namespace SK_OPTS_NS {
 
 /*not static*/
@@ -187,6 +376,10 @@ inline void blit_row_s32a_opaque(SkPMColor* dst, const SkPMColor* src, int len,
 #endif
 
 #if defined(SK_ARM_HAS_NEON)
+#ifdef __ARM_64BIT_STATE
+    // No attempt has been made to adapt the inline assembly version for AArch64
+    // so fall back to the less performant version that uses intrinsics instead
+
     while (len >= 8) {
         vst4_u8((uint8_t*)dst, SkPMSrcOver_neon8(vld4_u8((const uint8_t*)dst),
                                                  vld4_u8((const uint8_t*)src)));
@@ -209,6 +402,154 @@ inline void blit_row_s32a_opaque(SkPMColor* dst, const SkPMColor* src, int len,
         vst1_lane_u32(dst, vreinterpret_u32_u8(result), 0);
     }
     return;
+
+#else // __ARM_64BIT_STATE
+    // Inline ARM AArch32 assembly version
+    uint32_t tmp, alo, ahi;
+    const int eight = 8;
+    if (len < 15) {
+        // Too short to attempt aligned processing
+        if (len & 8)
+            S32A_OPAQUE_8PIX_PROCESS(, YES);
+        if (len & 7)
+            S32A_OPAQUE_7PIX_PROCESS(S32A_LOADSTORE_TRAILING_7, len & 7);
+    } else {
+        // The last 8 - 15 pixels (starting from a 4-pixel boundary) are handled together
+        uintptr_t startrup = (uintptr_t) dst / sizeof (*dst) + 3;
+        uintptr_t end = (uintptr_t) dst / sizeof (*dst) + len;
+        size_t trailing;
+        if ((end & 3) == 0)
+            // No blocks of <8 pixels used at end in these cases
+            trailing = 8;
+        else
+            // If length (discounting alignment to 4-pixel boundaries) is an odd number of 4-pixels,
+            // assign this to trailing end to avoid possibility of a leading run of exactly 4
+            trailing = 8 + ((startrup ^ end) & 4) + (end & 3);
+        // The inner loop handles an integer number (0+) of 16-pixel blocks at 4-pixel boundaries
+        // The 0..15 pixels leading up to this are handled together
+        size_t leading8 = (len - trailing) & 8;
+        size_t leading7 = (len - trailing) & 7;
+
+        // Do leading pixels
+        if (leading7 != 0) {
+            len -= leading7;
+            S32A_OPAQUE_7PIX_PROCESS(S32A_LOADSTORE_LEADING_7, leading7);
+        }
+        if (leading8 != 0) {
+            len -= 8;
+            S32A_OPAQUE_8PIX_PROCESS(:128, YES);
+        }
+
+        // Do inner loop
+        __asm__ (
+                // We enter and leave each iteration of the inner loop with the source
+                // pointer 8 pixels ahead and the destination pointer 8 pixels behind
+                // in order to permit good pipelining. The count of remaining pixels is
+                // reduced by 16 to allow the loop termination test to be combined with
+                // the decrementing of the remaining length.
+                "sub         %[dst], #8*4                                                     \n\t"
+                "vld4.8      {d0-d3}, [%[src]]!                                               \n\t"
+                "subs        %[len], #16                                                      \n\t"
+                "bcc         49f                                                              \n\t"
+
+                "10:                                                                          \n\t"
+                // Move alpha to ARM registers for comparison
+                "vmov        %[alo], s6                                                       \n\t"
+                "vmov        %[ahi], s7                                                       \n\t"
+                // Fetch source data for next iteration
+                "vld4.8      {d4-d7}, [%[src]]!                                               \n\t"
+                "add         %[dst], #8*4                                                     \n\t"
+                // Test if all source pixels are transparent (alpha=0)
+                "orrs        %[tmp], %[alo], %[ahi]                                           \n\t"
+                "beq         19f                                                              \n\t"
+                // Find inverse alpha in case full blending required
+                "vmvn        d31, d3                                                          \n\t"
+                // Test if all source pixels are opaque (alpha=0xff)
+                "cmp         %[alo], #-1                                                      \n\t"
+                "it          eq                                                               \n\t"
+                "cmpeq       %[ahi], #-1                                                      \n\t"
+                "bne         30f                                                              \n\t"
+                // Opaque case: copy source to destination
+                "vst4.8      {d0-d3}, [%[dst]:128]                                            \n\t"
+                // Drop through
+                "19:                                                                          \n\t"
+
+                // Move alpha to ARM registers for comparison
+                "vmov        %[alo], s14                                                      \n\t"
+                "vmov        %[ahi], s15                                                      \n\t"
+                // Fetch source data for next iteration
+                "vld4.8      {d0-d3}, [%[src]]!                                               \n\t"
+                "add         %[dst], #8*4                                                     \n\t"
+                // Test if all source pixels are transparent (alpha=0)
+                "orrs        %[tmp], %[alo], %[ahi]                                           \n\t"
+                "beq         29f                                                              \n\t"
+                // Find inverse alpha in case full blending required
+                "vmvn        d31, d7                                                          \n\t"
+                // Test if all source pixels are opaque (alpha=0xff)
+                "cmp         %[alo], #-1                                                      \n\t"
+                "it          eq                                                               \n\t"
+                "cmpeq       %[ahi], #-1                                                      \n\t"
+                "bne         40f                                                              \n\t"
+                // Opaque case: copy source to destination
+                "vst4.8      {d4-d7}, [%[dst]:128]                                            \n\t"
+                // Drop through
+                "29:                                                                          \n\t"
+                "subs        %[len], #16                                                      \n\t"
+                "bcs         10b                                                              \n\t"
+                "b           49f                                                              \n\t"
+
+                // Mixed or translucent pixels in d0-d3
+                "30:                                                                          \n\t"
+                S32A_OPAQUE_8PIX_BLEND(:128, d7, q0, q1,, YES, YES, IF_PRELOAD)
+A(              "teq         %[alo], #0                                                       \n\t")
+T(              "orrs        %[alo], %[alo], %[ahi]                                           \n\t")
+                "vld4.8      {d0-d3}, [%[src]]!                                               \n\t"
+                "beq         29b                                                              \n\t"
+A(              "orrs        %[tmp], %[tmp], %[ahi]                                           \n\t")
+T(              "orns        %[tmp], %[tmp], %[ahi]                                           \n\t")
+                "bne         40f                                                              \n\t"
+                "vst4.8      {d4-d7}, [%[dst]:128]                                            \n\t"
+                "b           29b                                                              \n\t"
+
+                // Mixed or translucent pixels in d4-d7
+                "40:                                                                          \n\t"
+                S32A_OPAQUE_8PIX_BLEND(:128, d3, q2, q3, \
+                "subs        %[len], #16", YES, YES, NO)
+                "bcc         50f                                                              \n\t"
+A(              "teq         %[alo], #0                                                       \n\t")
+T(              "orrs        %[alo], %[alo], %[ahi]                                           \n\t")
+                "vld4.8      {d4-d7}, [%[src]]!                                               \n\t"
+                "beq         19b                                                              \n\t"
+A(              "orrs        %[tmp], %[tmp], %[ahi]                                           \n\t")
+T(              "orns        %[tmp], %[tmp], %[ahi]                                           \n\t")
+                "bne         30b                                                              \n\t"
+                "vst4.8      {d0-d3}, [%[dst]:128]                                            \n\t"
+                "b           19b                                                              \n\t"
+
+                "49:                                                                          \n\t"
+                "add         %[dst], #8*4                                                     \n\t"
+                "50:                                                                          \n\t"
+        : // Outputs
+                [dst]"+r"(dst),
+                [src]"+r"(src),
+                [len]"+r"(len),
+                [alo]"+r"(alo),
+                [ahi]"+r"(ahi),
+                [tmp]"+r"(tmp)
+        : // Inputs
+        : // Clobbers
+                "cc", "memory"
+        );
+
+        // Do trailing pixels.
+        // There will always be more than 8 of these, and the first 8 are already in d0-d3
+        S32A_OPAQUE_8PIX_PROCESS(:128, NO);
+        if (len & 7)
+            S32A_OPAQUE_7PIX_PROCESS(S32A_LOADSTORE_TRAILING_7, len & 7);
+    }
+    return;
+
+#endif // __ARM_64BIT_STATE
 #endif
 
     while (len --> 0) {
diff --git a/src/third_party/skia/src/opts/SkUtils_opts.h b/src/third_party/skia/src/opts/SkUtils_opts.h
index 257d9bf73b..d45e8a8c1e 100644
--- a/src/third_party/skia/src/opts/SkUtils_opts.h
+++ b/src/third_party/skia/src/opts/SkUtils_opts.h
@@ -34,7 +34,81 @@ namespace SK_OPTS_NS {
         memsetT(buffer, value, count);
     }
     /*not static*/ inline void memset32(uint32_t buffer[], uint32_t value, int count) {
+#if defined(SK_ARM_HAS_NEON) && !defined(__ARM_64BIT_STATE)
+        uint32_t *p1 = buffer;
+        uint32_t off;
+        __asm__ volatile (
+                "vdup.32     q0, %[p2]                     \n\t"
+                "cmp         %[n], #3+16                   \n\t"
+                "vdup.32     q1, %[p2]                     \n\t"
+                "blo         20f                           \n\t"
+
+                // Long case (at least one 16-byte-aligned 64-byte block)
+                "ands        %[off], %[buffer], #12        \n\t"
+                "bne         15f                           \n\t"
+
+                // 16-byte aligned. Set up inner loop
+                "10:                                       \n\t"
+                "mov         %[off], #64                   \n\t"
+                "sub         %[n], #16                     \n\t"
+                "add         %[p2], %[p1], #32             \n\t"
+
+                // Inner loop
+                "11:                                       \n\t"
+                "vst1.32     {q0-q1}, [%[p1] :128], %[off] \n\t"
+                "subs        %[n], #16                     \n\t"
+                "vst1.32     {q0-q1}, [%[p2] :128], %[off] \n\t"
+                "bhs         11b                           \n\t"
+
+                // Handle trailing 1..15 words
+                "12:                                       \n\t"
+                "lsls        %[n], #29                     \n\t"
+                "bcc         1f                            \n\t"
+                "vst1.32     {q0-q1}, [%[p1]]!             \n\t"
+                "1:                                        \n\t"
+                "bpl         1f                            \n\t"
+                "vst1.32     {q0}, [%[p1]]!                \n\t"
+                "1:                                        \n\t"
+                "lsls        %[n], #2                      \n\t"
+                "it          cs                            \n\t"
+                "vstmcs      %[p1]!, {d0}                  \n\t"
+                "it          mi                            \n\t"
+                "vstmmi      %[p1]!, {s0}                  \n\t"
+                "b           90f                           \n\t"
+
+                // Handle first 1..3 words to achieve 16-byte alignment
+                "15:                                       \n\t"
+                "rsb         %[off], #16                   \n\t"
+                "sub         %[n], %[off], lsr #2          \n\t"
+                "lsls        %[off], #29                   \n\t"
+                "it          mi                            \n\t"
+                "vstmmi      %[p1]!, {s0}                  \n\t"
+                "it          cs                            \n\t"
+                "vstmcs      %[p1]!, {d0}                  \n\t"
+                "b           10b                           \n\t"
+
+                // Short case
+                "20:                                       \n\t"
+                "cmp         %[n], #8                      \n\t"
+                "blo         12b                           \n\t"
+                "sub         %[n], #8                      \n\t"
+                "vst1.8      {q0-q1}, [%[p1]]!             \n\t"
+                "b           12b                           \n\t"
+
+                "90:                                       \n\t"
+        : // Outputs
+                 [p2]"+r"(value),
+                  [n]"+r"(count),
+                 [p1]"+r"(p1),
+                [off]"=&r"(off)
+        : // Inputs
+                [buffer]"r"(buffer)
+        : // Clobbers
+                "cc", "memory"
+        );
+#else
         memsetT(buffer, value, count);
+#endif
     }
     /*not static*/ inline void memset64(uint64_t buffer[], uint64_t value, int count) {
         memsetT(buffer, value, count);
diff --git a/src/third_party/skia/src/sksl/codegen/SkSLVMCodeGenerator.cpp b/src/third_party/skia/src/sksl/codegen/SkSLVMCodeGenerator.cpp
index dcf052ad77..918c093343 100644
--- a/src/third_party/skia/src/sksl/codegen/SkSLVMCodeGenerator.cpp
+++ b/src/third_party/skia/src/sksl/codegen/SkSLVMCodeGenerator.cpp
@@ -1645,7 +1645,7 @@ skvm::Color ProgramToSkVM(const Program& program,
 
     SkVMGenerator generator(
             program, builder, uniforms, device, local, inputColor, std::move(sampleChild));
-    generator.writeFunction(function, {args, argSlots}, SkMakeSpan(result));
+    generator.writeFunction(function, {args, argSlots}, SkMakeSpan(result, 4));
 
     return skvm::Color{{builder, result[0]},
                        {builder, result[1]},
diff --git a/src/third_party/webrtc/modules/desktop_capture/BUILD.gn b/src/third_party/webrtc/modules/desktop_capture/BUILD.gn
index 25b92bed45..1bd1405d3c 100644
--- a/src/third_party/webrtc/modules/desktop_capture/BUILD.gn
+++ b/src/third_party/webrtc/modules/desktop_capture/BUILD.gn
@@ -14,6 +14,9 @@ import("../../webrtc.gni")
 if (rtc_use_pipewire) {
   assert(rtc_pipewire_version == "0.2" || rtc_pipewire_version == "0.3",
          "Unsupported PipeWire version")
+  if (current_cpu != "arm" && current_cpu != "arm64") {
+    rtc_pipewire_version = "0.3"
+  }
 }
 
 use_desktop_capture_differ_sse2 = current_cpu == "x86" || current_cpu == "x64"
